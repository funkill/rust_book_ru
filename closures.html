<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="INTRODUCTION.html"><strong>1.</strong> Введение</a></li><li><a href="getting-started.html"><strong>2.</strong> C чего начать</a></li><li><ul class="section"><li><a href="installing-rust.html"><strong>2.1.</strong> Установка Rust</a></li><li><a href="hello-world.html"><strong>2.2.</strong> Привет, мир!</a></li><li><a href="hello-cargo.html"><strong>2.3.</strong> Hello, Cargo!</a></li></ul></li><li><a href="learn-rust.html"><strong>3.</strong> Изучение Rust</a></li><li><ul class="section"><li><a href="guessing-game.html"><strong>3.1.</strong> Угадайка</a></li><li><a href="dining-philosophers.html"><strong>3.2.</strong> Обедающие философы</a></li><li><a href="rust-inside-other-languages.html"><strong>3.3.</strong> Вызов кода на Rust из других языков</a></li></ul></li><li><a href="effective-rust.html"><strong>4.</strong> Эффективное использование Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> Стек и куча</a></li><li><a href="testing.html"><strong>4.2.</strong> Тестирование</a></li><li><a href="conditional-compilation.html"><strong>4.3.</strong> Условная компиляция</a></li><li><a href="documentation.html"><strong>4.4.</strong> Документация</a></li><li><a href="iterators.html"><strong>4.5.</strong> Итераторы</a></li><li><a href="concurrency.html"><strong>4.6.</strong> Многозадачность</a></li><li><a href="error-handling.html"><strong>4.7.</strong> Обработка ошибок</a></li><li><a href="choosing-your-guarantees.html"><strong>4.8.</strong> Выбор гарантий</a></li><li><a href="ffi.html"><strong>4.9.</strong> Интерфейс внешних функций (FFI)</a></li><li><a href="borrow-and-asref.html"><strong>4.10.</strong> Типажи `Borrow` и `AsRef`</a></li><li><a href="release-channels.html"><strong>4.11.</strong> Каналы сборок</a></li></ul></li><li><a href="syntax-and-semantics.html"><strong>5.</strong> Синтаксис и семантика</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>5.1.</strong> Связывание имён</a></li><li><a href="functions.html"><strong>5.2.</strong> Функции</a></li><li><a href="primitive-types.html"><strong>5.3.</strong> Простые типы</a></li><li><a href="comments.html"><strong>5.4.</strong> Комментарии</a></li><li><a href="if.html"><strong>5.5.</strong> Конструкция `if`</a></li><li><a href="loops.html"><strong>5.6.</strong> Циклы</a></li><li><a href="ownership.html"><strong>5.7.</strong> Владение</a></li><li><a href="references-and-borrowing.html"><strong>5.8.</strong> Ссылки и заимствование</a></li><li><a href="lifetimes.html"><strong>5.9.</strong> Время жизни</a></li><li><a href="mutability.html"><strong>5.10.</strong> Изменяемость (mutability)</a></li><li><a href="structs.html"><strong>5.11.</strong> Структуры</a></li><li><a href="enums.html"><strong>5.12.</strong> Перечисления</a></li><li><a href="match.html"><strong>5.13.</strong> Конструкция `match`</a></li><li><a href="patterns.html"><strong>5.14.</strong> Шаблоны сопоставления `match`</a></li><li><a href="method-syntax.html"><strong>5.15.</strong> Синтаксис методов</a></li><li><a href="vectors.html"><strong>5.16.</strong> Вектора</a></li><li><a href="strings.html"><strong>5.17.</strong> Строки</a></li><li><a href="generics.html"><strong>5.18.</strong> Обобщённое программирование</a></li><li><a href="traits.html"><strong>5.19.</strong> Типажи</a></li><li><a href="drop.html"><strong>5.20.</strong> Типаж `Drop` (сброс)</a></li><li><a href="if-let.html"><strong>5.21.</strong> Конструкция `if let`</a></li><li><a href="trait-objects.html"><strong>5.22.</strong> Типажи-объекты</a></li><li><a href="closures.html" class="active"><strong>5.23.</strong> Замыкания</a></li><li><a href="ufcs.html"><strong>5.24.</strong> Универсальный синтаксис вызова функций (UFCS)</a></li><li><a href="crates-and-modules.html"><strong>5.25.</strong> Контейнеры (crates) и модули (modules)</a></li><li><a href="const-and-static.html"><strong>5.26.</strong> `const` и `static`</a></li><li><a href="attributes.html"><strong>5.27.</strong> Атрибуты</a></li><li><a href="type-aliases.html"><strong>5.28.</strong> Псевдонимы типов</a></li><li><a href="casting-between-types.html"><strong>5.29.</strong> Приведение типов</a></li><li><a href="associated-types.html"><strong>5.30.</strong> Ассоциированные типы</a></li><li><a href="unsized-types.html"><strong>5.31.</strong> Безразмерные типы</a></li><li><a href="operators-and-overloading.html"><strong>5.32.</strong> Перегрузка операций</a></li><li><a href="deref-coercions.html"><strong>5.33.</strong> Преобразования при разыменовании (deref coercions)</a></li><li><a href="macros.html"><strong>5.34.</strong> Макросы</a></li><li><a href="raw-pointers.html"><strong>5.35.</strong> Сырые указатели</a></li><li><a href="unsafe.html"><strong>5.36.</strong> Небезопасный код</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Нестабильные возможности Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Плагины к компилятору</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Встроенный ассемблерный код</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> Без stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Внутренние средства (intrinsics)</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Элементы языка (lang items)</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Продвинутое руководство по компоновке (advanced linking)</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Тесты производительности</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Синтаксис упаковки и шаблоны `match`</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Шаблоны `match` для срезов</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Ассоциированные константы</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Пользовательские менеджеры памяти</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> Глоссарий</a></li><li><a href="academic-research.html"><strong>8.</strong> Академические исследования</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>% Замыкания</p>
<p>Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные
функции, которые имеют связанное окружение, называются 'замыкания'. Они так
называются потому что они замыкают свое окружение. Как мы увидим далее, Rust
имеет реально крутую реализацию замыканий.</p>
<h1>Синтаксис</h1>
<p>Замыкания выглядят следующим образом:</p>
<pre><code class="language-rust">let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
</code></pre>
<p>Мы создаем связывание, <code>plus_one</code>, и присваиваем ему замыкание. Аргументы
замыкания располагаются между двумя символами <code>|</code>, а телом замыкания является
выражение, в данном случае: <code>x + 1</code>. Помните, что <code>{ }</code> также является
выражением, поэтому тело замыкания может содержать много строк:</p>
<pre><code class="language-rust">let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
</code></pre>
<p>Обратите внимание, что есть несколько небольших различий между замыканиями и
обычными функциями, определенными с помощью <code>fn</code>. Первое отличие состоит в том,
что для замыкания мы не должны указывать ни типы аргументов, которые оно
принимает, ни тип возвращаемого им значения. Мы можем:</p>
<pre><code class="language-rust">let plus_one = |x: i32| -&gt; i32 { x + 1 };

assert_eq!(2, plus_one(1));
</code></pre>
<p>Но мы не должны. Почему так? В основном, это было сделано из эргономических
соображений (соображений удобства). В то время как для именованных функций явное
указание типа является полезным для таких аспектов как документация и вывод
типа, типы замыканий редко документируют, поскольку они анонимны. К тому же, они
не вызывают «ошибок на расстоянии» (error-at-a-distance), которые могут вызывать
именованные функции. Такие ошибки могут возникать, когда локальное изменение
(например, в теле одной из функций) вызывает изменение вывода типов. Компилятор
пытается подобрать типы в окружающей программе под уже другие типы в изменённой
функции, и часто оказывается, что имена имеют другие типы, нежели мы ожидали. В
результате происходит ошибка «на расстоянии» — возможно, в другой функции,
использующей изменённую.</p>
<p>Второе отличие — синтаксис очень похож, но все же немного отличается. Мы
добавили пробелы здесь, чтобы было нагляднее:</p>
<pre><code class="language-rust">fn  plus_one_v1   (x: i32 ) -&gt; i32 { x + 1 }
let plus_one_v2 = |x: i32 | -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32 |          x + 1  ;
</code></pre>
<p>Есть небольшие различия, но принцип аналогичен.</p>
<h1>Замыкания и их окружение</h1>
<p>Замыкания называются так потому, что они 'замыкают свое окружение.' Это выглядит
следующим образом:</p>
<pre><code class="language-rust">let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
</code></pre>
<p>Это замыкание, <code>plus_num</code>, ссылается на связанную с помощью оператора <code>let</code>
переменную <code>num</code>, расположенную в своей области видимости. Если говорить более
конкретно, то оно заимствует связывание. Если мы сделаем что-то, что
противоречило бы связыванию, то получим ошибку. Например этот код:</p>
<pre><code class="language-rust,ignore">let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &amp;mut num;
</code></pre>
<p>Который выдаст следующие ошибки:</p>
<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &amp;mut num;
}
^
</code></pre>
<p>Подробное и к тому же полезное сообщение об ошибке! Как говорится в этом
сообщении, мы не можем получить изменяемый заем переменной <code>num</code> потому что
замыкание уже заимствует его. Если же мы обеспечим выход замыкания из области
видимости, то мы сможем:</p>
<pre><code class="language-rust">let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &amp;mut num;
</code></pre>
<p>Однако, Rust также может забирать право владения и перемещать свое окружение,
если этого требует замыкание:</p>
<pre><code class="language-rust,ignore">let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!(&quot;{:?}&quot;, nums);
</code></pre>
<p>Этот код выдаст:</p>
<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
</code></pre>
<p><code>Vec&lt;T&gt;</code> обладает правом владения на свое содержимое, и поэтому, когда мы
ссылаемся на него в нашем замыкании, мы должны забрать право владения на <code>nums</code>.
Это тоже самое, как если бы мы передавали <code>nums</code> в функцию, которая забирала бы
право владения на него.</p>
<h2>Перемещающие замыкания (<code>move</code> closures)</h2>
<p>Мы можем заставить наше замыкание забирать право владения на свое окружение с
помощью ключевого слова <code>move</code>:</p>
<pre><code class="language-rust">let num = 5;

let owns_num = move |x: i32| x + num;
</code></pre>
<p>Теперь, когда указано ключевое слово <code>move</code>, переменные следуют нормальной
семантике перемещения. В данном примере <code>5</code> реализует <code>Copy</code>, поэтому <code>owns_num</code>
становится владельцем копии <code>num</code>. Так в чем же разница?</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
</code></pre>
<p>Итак, в этом примере наше замыкание принимает изменяемую ссылку на <code>num</code>. Затем,
когда мы вызываем замыкание <code>add_num</code>, то, как мы и ожидали, оно изменяет
значение внутри. Нам также необходимо объявить <code>add_num</code> как <code>mut</code>, потому что
оно изменяет свое окружение.</p>
<p>Если же мы будем использовать <code>move</code> замыкание, то получим следующие отличия:</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
</code></pre>
<p>Мы всего лишь получаем <code>5</code>. Вместо того, чтобы получать изменяемый заем на
<code>num</code>, мы получаем право владения на копию.</p>
<p>Вот еще один способ думать о <code>move</code> замыканиях: они предоставляют замыкание со
своим собственным фреймом стека. Без <code>move</code> замыкание может быть связано с
фреймом стека, который его создал, в то время как <code>move</code> замыкание содержит свой
собственный фрейм стека. Это означает, например, что вы не можете вернуть не
<code>move</code> замыкание из функции.</p>
<p>Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания,
мы должны поговорить о том, как реализуются замыкания. Как системный язык
программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и
замыкания не являются исключением.</p>
<h1>Реализация замыканий</h1>
<p>Реализация замыканий в Rust немного отличается от других языков. Фактически, она
представляет из себя просто синтаксический сахар для типажей. Перед тем как
читать дальше, настоятельно рекомендуем изучить главу <a href="traits.html">Типажи</a>, а также
главу <a href="trait-objects.html">Типажи-объекты</a>, в которой говорится о типажах-объектах.</p>
<p>Изучили? Хорошо.</p>
<p>Ключ к пониманию того, как замыкания работают изнутри звучит немного странно:
использование <code>()</code> для вызова функции, как например <code>foo()</code>, представляет собой
перегружаемую операцию. Исходя из этого, все остальное встает на свои места. В
Rust мы используем систему типажей для перегрузки операций. Вызов функций не
является исключением. Существуют три отдельных типажа для их перегрузки:</p>
<pre><code class="language-rust"># mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
# }
</code></pre>
<p>Вы можете заметить некоторые различия между этими типажами, но есть одно главное
различие — <code>self</code>: <code>Fn</code> принимает <code>&amp;self</code>, <code>FnMut</code> принимает <code>&amp;mut self</code>,
<code>FnOnce</code> принимает <code>self</code>. Это покрывает все три вида <code>self</code> с помощью обычного
синтаксиса вызова методов. Мы разделили их на три типажа, вместо того, чтобы
иметь один. Это дает нам большее количество контроля над тем, какого вида
замыкания мы можем принять.</p>
<p>Использование <code>|| {}</code> при создании замыканий является синтаксическим сахаром для
этих трех типажей. Rust будет генерировать структуру для окружения, реализующую
(<code>impl</code>) соответствующий типаж, а затем использовать его.</p>
<h1>Передача замыканий в качестве аргументов</h1>
<p>Теперь, когда мы знаем, что замыкания являются типажами, получается, что мы уже
знаем, как принимать и возвращать замыкания: как и любой другой типаж!</p>
<p>Это также означает, что мы можем выбирать между статической и динамической
диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то
вызываемое, вызывает это что-то и возвращает результат:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>Мы передаем наше замыкание <code>|x| x + 2</code>, в функцию <code>call_with_one</code>. Она же
делает то, о чем говорит ее название: вызывает замыкание, передавая ему <code>1</code> в
качестве аргумента.</p>
<p>Давайте рассмотрим сигнатуру функции <code>call_with_one</code> более подробно:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
#    where F : Fn(i32) -&gt; i32 {
#    some_closure(1) }
</code></pre>
<p>Мы принимаем один параметр, который имеет тип <code>F</code>. Мы также возвращаем <code>i32</code>.
Эта часть не интересна. Следующим важным моментом является:</p>
<pre><code class="language-rust"># fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
#   some_closure(1) }
</code></pre>
<p>Так как <code>Fn</code> является типажом, мы можем связать с ним наш обобщенный параметр. В
этом примере, замыкание принимает <code>i32</code> в качестве аргумента и возвращает <code>i32</code>,
поэтому связывание, которое мы используем, выглядит так: <code>Fn(i32) -&gt; i32</code>.</p>
<p>Здесь есть еще один ключевой момент: так как мы ограничиваем обобщённый параметр
с помощью типажа, то будет применена мономорфизация, и поэтому в замыкании будет
использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно).
Во многих языках для замыканий по существу используется выделение памяти в куче,
и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы
можем выделить память для окружения замыкания в стеке и использовать статическую
диспетчеризацию вызова. Это случается довольно часто с итераторами и их
адаптерами, которые нередко принимают замыкания в качестве аргументов.</p>
<p>Конечно, если нам нужна динамическая диспетчеризация, мы также можем
использовать и ее. Обычно для этого случая используется типаж-объект:</p>
<pre><code class="language-rust">fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

let answer = call_with_one(&amp;|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>Теперь наша функция в качетве аргумента принимает типаж-объект <code>&amp;Fn</code>. Поэтому мы
должны создать ссылку на замыкание а затем передать ее в функцию
<code>call_with_one</code>, для этого мы используем <code>&amp;||</code>.</p>
<h1>Возврат замыканий</h1>
<p>Что очень характерно для кода в функциональном стиле — возвращать замыкания в
различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете
столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим
разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Это выдаст следующие длинные, взаимосвязанные ошибки:</p>
<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>
<p>Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет
тип возвращаемого значения. Но так как <code>Fn</code> является типажом, то в качестве него
могут выступать совершенно разные объекты, с разными размерами: много различных
типов могут реализовать <code>Fn</code>. Самый простой способ передать что-то
неопределенного размера — передать ссылку на это что-то, так как ссылки имеют
известный размер. Таким образом, следовало бы написать так:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но тогда мы получим другую ошибку:</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>
<p>Верно. Так как у нас используется ссылка, то мы должны задать ее время жизни.
Так наша функция <code>factory()</code> не принимает никаких аргументов, то элизия
(сокрытие) здесь не уместна. Какое время жизни мы должны выбрать? <code>'static</code>:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но мы получим еще ошибку:</p>
<pre><code class="language-text">error: mismatched types:
 expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
    found `[closure &lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>
<p>Эта ошибка сообщает нам, что ожидается использование <code>&amp;'static Fn(i32) -&gt; i32</code>,
а используется <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Подождите, что?</p>
<p>Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою
собственную <code>struct</code> для окружения и реализует <code>Fn</code> и компанию, то эти типы
являются анонимными. Они существуют исключительно для этого замыкания. Поэтому
Rust показывает их как <code>closure &lt;anon&gt;</code>, а не в виде какого-то автоматически
сгенерированного имени.</p>
<p>Но почему же наше замыкание не реализует <code>&amp;'static Fn</code>? Как мы обсуждали ранее,
замыкание заимствует свое окружение. И в этом случае наше окружение представляет
собой выделеную в стеке память, содержащую значение связанной переменной <code>num</code> -
<code>5</code>. Из-за этого заем имеет срок жизни фрейма стека. Так что, когда мы вернем
это замыкание, то вызов функции будет завершен, а фрейм стека уйдет, и наше
замыкание захватит окружение, содержащее в памяти мусор!</p>
<p>Так что же делать? Этот код <em>почти</em> работает:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>Мы используем типаж-объект, полученный в результате упаковки (<code>Box</code>) типажа
<code>Fn</code>. И остаётся только одна, последняя проблема:</p>
<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>
<p>Мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этим последним
исправлением мы сможем наконец выполнить нашу задачу:</p>
<pre><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>Благодаря изменению внутреннего замыкания на <code>move Fn</code> будет создаваться новый
фрейм стека для нашего замыкания. А благодаря упаковке (<code>Box</code>) замыкания,
получается известный размер возвращаемого значения, и позволяет ему избежать
(быть независимым от) нашего фрейма стека.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="trait-objects.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ufcs.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="trait-objects.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ufcs.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
