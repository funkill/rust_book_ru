<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="INTRODUCTION.html"><strong>1.</strong> Введение</a></li><li><a href="getting-started.html"><strong>2.</strong> C чего начать</a></li><li><ul class="section"><li><a href="installing-rust.html"><strong>2.1.</strong> Установка Rust</a></li><li><a href="hello-world.html"><strong>2.2.</strong> Привет, мир!</a></li><li><a href="hello-cargo.html"><strong>2.3.</strong> Hello, Cargo!</a></li></ul></li><li><a href="learn-rust.html"><strong>3.</strong> Изучение Rust</a></li><li><ul class="section"><li><a href="guessing-game.html"><strong>3.1.</strong> Угадайка</a></li><li><a href="dining-philosophers.html"><strong>3.2.</strong> Обедающие философы</a></li><li><a href="rust-inside-other-languages.html"><strong>3.3.</strong> Вызов кода на Rust из других языков</a></li></ul></li><li><a href="effective-rust.html"><strong>4.</strong> Эффективное использование Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> Стек и куча</a></li><li><a href="testing.html" class="active"><strong>4.2.</strong> Тестирование</a></li><li><a href="conditional-compilation.html"><strong>4.3.</strong> Условная компиляция</a></li><li><a href="documentation.html"><strong>4.4.</strong> Документация</a></li><li><a href="iterators.html"><strong>4.5.</strong> Итераторы</a></li><li><a href="concurrency.html"><strong>4.6.</strong> Многозадачность</a></li><li><a href="error-handling.html"><strong>4.7.</strong> Обработка ошибок</a></li><li><a href="choosing-your-guarantees.html"><strong>4.8.</strong> Выбор гарантий</a></li><li><a href="ffi.html"><strong>4.9.</strong> Интерфейс внешних функций (FFI)</a></li><li><a href="borrow-and-asref.html"><strong>4.10.</strong> Типажи `Borrow` и `AsRef`</a></li><li><a href="release-channels.html"><strong>4.11.</strong> Каналы сборок</a></li></ul></li><li><a href="syntax-and-semantics.html"><strong>5.</strong> Синтаксис и семантика</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>5.1.</strong> Связывание имён</a></li><li><a href="functions.html"><strong>5.2.</strong> Функции</a></li><li><a href="primitive-types.html"><strong>5.3.</strong> Простые типы</a></li><li><a href="comments.html"><strong>5.4.</strong> Комментарии</a></li><li><a href="if.html"><strong>5.5.</strong> Конструкция `if`</a></li><li><a href="loops.html"><strong>5.6.</strong> Циклы</a></li><li><a href="ownership.html"><strong>5.7.</strong> Владение</a></li><li><a href="references-and-borrowing.html"><strong>5.8.</strong> Ссылки и заимствование</a></li><li><a href="lifetimes.html"><strong>5.9.</strong> Время жизни</a></li><li><a href="mutability.html"><strong>5.10.</strong> Изменяемость (mutability)</a></li><li><a href="structs.html"><strong>5.11.</strong> Структуры</a></li><li><a href="enums.html"><strong>5.12.</strong> Перечисления</a></li><li><a href="match.html"><strong>5.13.</strong> Конструкция `match`</a></li><li><a href="patterns.html"><strong>5.14.</strong> Шаблоны сопоставления `match`</a></li><li><a href="method-syntax.html"><strong>5.15.</strong> Синтаксис методов</a></li><li><a href="vectors.html"><strong>5.16.</strong> Вектора</a></li><li><a href="strings.html"><strong>5.17.</strong> Строки</a></li><li><a href="generics.html"><strong>5.18.</strong> Обобщённое программирование</a></li><li><a href="traits.html"><strong>5.19.</strong> Типажи</a></li><li><a href="drop.html"><strong>5.20.</strong> Типаж `Drop` (сброс)</a></li><li><a href="if-let.html"><strong>5.21.</strong> Конструкция `if let`</a></li><li><a href="trait-objects.html"><strong>5.22.</strong> Типажи-объекты</a></li><li><a href="closures.html"><strong>5.23.</strong> Замыкания</a></li><li><a href="ufcs.html"><strong>5.24.</strong> Универсальный синтаксис вызова функций (UFCS)</a></li><li><a href="crates-and-modules.html"><strong>5.25.</strong> Контейнеры (crates) и модули (modules)</a></li><li><a href="const-and-static.html"><strong>5.26.</strong> `const` и `static`</a></li><li><a href="attributes.html"><strong>5.27.</strong> Атрибуты</a></li><li><a href="type-aliases.html"><strong>5.28.</strong> Псевдонимы типов</a></li><li><a href="casting-between-types.html"><strong>5.29.</strong> Приведение типов</a></li><li><a href="associated-types.html"><strong>5.30.</strong> Ассоциированные типы</a></li><li><a href="unsized-types.html"><strong>5.31.</strong> Безразмерные типы</a></li><li><a href="operators-and-overloading.html"><strong>5.32.</strong> Перегрузка операций</a></li><li><a href="deref-coercions.html"><strong>5.33.</strong> Преобразования при разыменовании (deref coercions)</a></li><li><a href="macros.html"><strong>5.34.</strong> Макросы</a></li><li><a href="raw-pointers.html"><strong>5.35.</strong> Сырые указатели</a></li><li><a href="unsafe.html"><strong>5.36.</strong> Небезопасный код</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Нестабильные возможности Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Плагины к компилятору</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Встроенный ассемблерный код</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> Без stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Внутренние средства (intrinsics)</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Элементы языка (lang items)</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Продвинутое руководство по компоновке (advanced linking)</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Тесты производительности</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Синтаксис упаковки и шаблоны `match`</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Шаблоны `match` для срезов</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Ассоциированные константы</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Пользовательские менеджеры памяти</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> Глоссарий</a></li><li><a href="academic-research.html"><strong>8.</strong> Академические исследования</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>% Тестирование</p>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<blockquote>
<p>Тестирование программы может быть очень эффективным способом показать наличие
ошибок, но оно безнадёжно неподходяще для доказательства их отсутствия.</p>
<p>Дейкстра, Эдсгер Вибе, «The Humble Programmer» (1972)</p>
</blockquote>
<p>Давайте поговорим о том, как тестировать код на Rust. Мы не будем рассказывать о
том, какой подход к тестированию Rust кода является верным. Есть много подходов,
каждый из которых имеет свое представление о правильном написании тестов. Но все
эти подходы используют одни и те же основные инструменты, и мы покажем вам
синтаксис их использования.</p>
<h1>Тесты с атрибутом <code>test</code></h1>
<p>В самом простом случае, тест в Rust — это функция, аннотированная атрибутом
<code>test</code>. Давайте создадим новый проект Cargo, который будет называться <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>При создании нового проекта, Cargo автоматически сгенерирует простой тест. Ниже
представлено содержимое <code>src/lib.rs</code>:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
}
</code></pre>
<p>Обратите внимание на <code>#[test]</code>. Этот атрибут указывает, что это тестовая
функция. В этом примере она не имеет тела. Но такого вида функции достаточно,
чтобы удачно выполнить тест. Запуск тестов осуществляется командой <code>cargo test</code>.</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Cargo скомпилировал и запустил наши тесты. В результате мы получили выходные
данные, поделенные на два раздела: один содержит информацию о тесте, который мы
написали, а другой — информацию о тестах из документации. Но об этом позже. А
сейчас посмотрим на эту строку:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Обратите внимание на <code>it_works</code>. Это название нашей функции:</p>
<pre><code class="language-rust">fn it_works() {
# }
</code></pre>
<p>Мы также получили итоговую строку:</p>
<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Так почему же наш ничего не делающий тест был выполнен удачно? Любой тест,
который не вызывает <code>panic!</code>, выполняется удачно, а любой тест, который вызывает
<code>panic!</code>, выполняется неудачно. Давайте сделаем тест, который выполнится
неудачно:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
    assert!(false);
}
</code></pre>
<p><code>assert!</code> — это макрос, определенный в Rust, и принимающий один аргумент: если
аргумент имеет значение <code>true</code>, то ничего не происходит; если аргумент является
<code>false</code>, то вызывается <code>panic!</code>. Давайте запустим наши тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust сообщает, что наш тест выполнен неудачно:</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Это же отражается в итоговой строке:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Мы также получаем ненулевой код состояния:</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>Это бывает полезно, если вы хотите интегрировать <code>cargo test</code> в сторонний
инструмент.</p>
<p>Мы можем инвертировать ожидаемый результат теста с помощью атрибута:
<code>should_panic</code>:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
</code></pre>
<p>Теперь этот тест будет выполнен удачно, если вызывается <code>panic!</code>, и неудачно,
если <code>panic!</code> не вызывается. Давайте попробуем:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust предоставляет и другой макрос, <code>assert_eq!</code>, который проверяет равенство
двух аргументов:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>А теперь этот тест будет выполнен удачно или неудачно? Из-за атрибута
<code>should_panic</code> он завершится удачно:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Тесты <code>should_panic</code> могут быть хрупкими, поскольку трудно гарантировать, что
тест не вызовет панику по неожиданной причине. Чтобы помочь в этом аспекте, к
атрибуту <code>should_panic</code> может быть добавлен необязательный параметр <code>expected</code>.
Тогда тест также будет проверять, что сообщение об ошибке содержит ожидаемый
текст. Ниже представлен более безопасный вариант приведенного выше примера:</p>
<pre><code class="language-rust">#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>Вот и все, что касается основ! Давайте напишем один «настоящий» тест:</p>
<pre><code class="language-rust,ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>Это распространенное использование макроса <code>assert_eq!</code>: вызывать некоторую
функцию с известными аргументами и сравнить результат её вызова с ожидаемым
результатом.</p>
<h1>Тесты в модуле <code>test</code></h1>
<p>Есть один нюанс, из-за которого наш пример нельзя назвать идиоматичным:
отсутствует модуль тестирования. Идиоматичный вариант нашего примера будет
выглядеть примерно так:</p>
<pre><code class="language-rust,ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Здесь есть несколько изменений. Первое — это введение <code>mod test</code> с атрибутом
<code>cfg</code>. Модуль позволяет сгруппировать все наши тесты вместе, а также, если
нужно, определить вспомогательные функции, которые будут отделены от остальной
части контейнера. Атрибут <code>cfg</code> указывает на то, что тест будет скомпилирован,
только когда мы попытаемся запустить тесты. Это может сэкономить время
компиляции, а также гарантирует, что наши тесты полностью исключены из обычной
сборки.</p>
<p>Второе изменение заключается в объявлении <code>use</code>. Так как мы находимся во
внутреннем модуле, то мы должны объявить использование тестируемой функции в его
области видимости. Это может раздражать, если у вас большой модуль, и поэтому
обычно используют возможность <code>glob</code>. Давайте изменим <code>src/lib.rs</code>
соответствующим образом:</p>
<pre><code class="language-rust,ignore">
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на различие в строке с <code>use</code>. Теперь запустим наши тесты:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Работает!</p>
<p>Данный подход представляет собой использование модуля <code>test</code>, содержащего
модульные тесты (unit tests). Любой код, задачей которого является только лишь
тестирование небольшого кусочка функциональности, имеет смысл перенести в этот
модуль. Но что если мы хотим написать «интеграционные тесты» (integration
tests)? Для этого следует использовать директорию <code>tests</code>.</p>
<h1>Тесты в директории <code>tests</code></h1>
<p>Чтобы написать интеграционный тест, давайте создадим директорию <code>tests</code>, и
положим в нее файл <code>tests/lib.rs</code> со следующим содержимым:</p>
<pre><code class="language-rust,ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Выглядит примерно так же, как и наши предыдущие тесты, но есть некоторые
отличия. Теперь сверху у нас <code>extern crate adder</code>. Это потому, что тесты в
директории <code>tests</code> — это отдельный контейнер, и, следовательно, мы должны
компоноваться с нашей библиотекой. Это также объясняет, почему директория
<code>tests</code> — наиболее подходящее место для написания интеграционных тестов: они
используют библиотеку, как это делал бы любой другой потребитель.</p>
<p>Давайте запустим их:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас появилось три раздела: запускается старый модульный тест, а также
новый интеграционный тест.</p>
<p>Это все, что касается директории <code>tests</code>. Модуль <code>test</code> здесь не нужен, так как
здесь всё относится к тестам.</p>
<p>Давайте, наконец, перейдем к третьей части: тесты в документации.</p>
<h1>Тесты в документации</h1>
<p>Нет ничего лучше, чем документация с примерами. Нет ничего хуже, чем примеры,
которые на самом деле не работают, потому что код изменился с тех пор, как была
написана документация. Для того, чтобы такой ситуации не возникало, Rust
поддерживает автоматический запуск примеров в документации. Вот дополненный
<code>src/lib.rs</code> с примерами:</p>
<pre><code class="language-rust,ignore">//! Контейнер `adder` предоставляет функции сложения чисел.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// Эта функция прибавляет 2 к своему аргументу.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на документацию уровня модуля, начинающуюся с <code>//!</code> и на
документацию уровня функции, начинающуюся с <code>///</code>. Документация Rust
поддерживает Markdown в комментариях, поэтому блоки кода помечают тройными
символами `. В комментарии документации обычно включают раздел <code># Examples</code>,
содержащий примеры, такие как этот. (Примечание переводчика: заголовок <code># Examples</code> имеет особое значение: его нельзя написать по-другому или написать на
русском языке, иначе Rust не найдёт примеров кода в документации.)</p>
<p>Давайте запустим тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас запускаются все три вида тестов! Обратите внимание на имена тестов
из документации: <code>_0</code> генерируется для модульных тестов, и <code>add_two_0</code> — для
функциональных тестов. Цифры на конце будут увеличиваться автоматически, если вы
добавите еще примеров. Например, при добавлении ещё одного функционального
теста, он получит имя <code>add_two_1</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="the-stack-and-the-heap.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="conditional-compilation.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="the-stack-and-the-heap.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="conditional-compilation.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
