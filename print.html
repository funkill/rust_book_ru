<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="INTRODUCTION.html"><strong>1.</strong> Введение</a></li><li><a href="getting-started.html"><strong>2.</strong> C чего начать</a></li><li><ul class="section"><li><a href="installing-rust.html"><strong>2.1.</strong> Установка Rust</a></li><li><a href="hello-world.html"><strong>2.2.</strong> Привет, мир!</a></li><li><a href="hello-cargo.html"><strong>2.3.</strong> Hello, Cargo!</a></li></ul></li><li><a href="learn-rust.html"><strong>3.</strong> Изучение Rust</a></li><li><ul class="section"><li><a href="guessing-game.html"><strong>3.1.</strong> Угадайка</a></li><li><a href="dining-philosophers.html"><strong>3.2.</strong> Обедающие философы</a></li><li><a href="rust-inside-other-languages.html"><strong>3.3.</strong> Вызов кода на Rust из других языков</a></li></ul></li><li><a href="effective-rust.html"><strong>4.</strong> Эффективное использование Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> Стек и куча</a></li><li><a href="testing.html"><strong>4.2.</strong> Тестирование</a></li><li><a href="conditional-compilation.html"><strong>4.3.</strong> Условная компиляция</a></li><li><a href="documentation.html"><strong>4.4.</strong> Документация</a></li><li><a href="iterators.html"><strong>4.5.</strong> Итераторы</a></li><li><a href="concurrency.html"><strong>4.6.</strong> Многозадачность</a></li><li><a href="error-handling.html"><strong>4.7.</strong> Обработка ошибок</a></li><li><a href="choosing-your-guarantees.html"><strong>4.8.</strong> Выбор гарантий</a></li><li><a href="ffi.html"><strong>4.9.</strong> Интерфейс внешних функций (FFI)</a></li><li><a href="borrow-and-asref.html"><strong>4.10.</strong> Типажи `Borrow` и `AsRef`</a></li><li><a href="release-channels.html"><strong>4.11.</strong> Каналы сборок</a></li></ul></li><li><a href="syntax-and-semantics.html"><strong>5.</strong> Синтаксис и семантика</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>5.1.</strong> Связывание имён</a></li><li><a href="functions.html"><strong>5.2.</strong> Функции</a></li><li><a href="primitive-types.html"><strong>5.3.</strong> Простые типы</a></li><li><a href="comments.html"><strong>5.4.</strong> Комментарии</a></li><li><a href="if.html"><strong>5.5.</strong> Конструкция `if`</a></li><li><a href="loops.html"><strong>5.6.</strong> Циклы</a></li><li><a href="ownership.html"><strong>5.7.</strong> Владение</a></li><li><a href="references-and-borrowing.html"><strong>5.8.</strong> Ссылки и заимствование</a></li><li><a href="lifetimes.html"><strong>5.9.</strong> Время жизни</a></li><li><a href="mutability.html"><strong>5.10.</strong> Изменяемость (mutability)</a></li><li><a href="structs.html"><strong>5.11.</strong> Структуры</a></li><li><a href="enums.html"><strong>5.12.</strong> Перечисления</a></li><li><a href="match.html"><strong>5.13.</strong> Конструкция `match`</a></li><li><a href="patterns.html"><strong>5.14.</strong> Шаблоны сопоставления `match`</a></li><li><a href="method-syntax.html"><strong>5.15.</strong> Синтаксис методов</a></li><li><a href="vectors.html"><strong>5.16.</strong> Вектора</a></li><li><a href="strings.html"><strong>5.17.</strong> Строки</a></li><li><a href="generics.html"><strong>5.18.</strong> Обобщённое программирование</a></li><li><a href="traits.html"><strong>5.19.</strong> Типажи</a></li><li><a href="drop.html"><strong>5.20.</strong> Типаж `Drop` (сброс)</a></li><li><a href="if-let.html"><strong>5.21.</strong> Конструкция `if let`</a></li><li><a href="trait-objects.html"><strong>5.22.</strong> Типажи-объекты</a></li><li><a href="closures.html"><strong>5.23.</strong> Замыкания</a></li><li><a href="ufcs.html"><strong>5.24.</strong> Универсальный синтаксис вызова функций (UFCS)</a></li><li><a href="crates-and-modules.html"><strong>5.25.</strong> Контейнеры (crates) и модули (modules)</a></li><li><a href="const-and-static.html"><strong>5.26.</strong> `const` и `static`</a></li><li><a href="attributes.html"><strong>5.27.</strong> Атрибуты</a></li><li><a href="type-aliases.html"><strong>5.28.</strong> Псевдонимы типов</a></li><li><a href="casting-between-types.html"><strong>5.29.</strong> Приведение типов</a></li><li><a href="associated-types.html"><strong>5.30.</strong> Ассоциированные типы</a></li><li><a href="unsized-types.html"><strong>5.31.</strong> Безразмерные типы</a></li><li><a href="operators-and-overloading.html"><strong>5.32.</strong> Перегрузка операций</a></li><li><a href="deref-coercions.html"><strong>5.33.</strong> Преобразования при разыменовании (deref coercions)</a></li><li><a href="macros.html"><strong>5.34.</strong> Макросы</a></li><li><a href="raw-pointers.html"><strong>5.35.</strong> Сырые указатели</a></li><li><a href="unsafe.html"><strong>5.36.</strong> Небезопасный код</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Нестабильные возможности Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Плагины к компилятору</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Встроенный ассемблерный код</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> Без stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Внутренние средства (intrinsics)</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Элементы языка (lang items)</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Продвинутое руководство по компоновке (advanced linking)</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Тесты производительности</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Синтаксис упаковки и шаблоны `match`</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Шаблоны `match` для срезов</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Ассоциированные константы</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Пользовательские менеджеры памяти</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> Глоссарий</a></li><li><a href="academic-research.html"><strong>8.</strong> Академические исследования</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Введение</h1>
<p>Добро пожаловать! Эта книга обучает основным принципам работы с языком
программирования <a href="http://rust-lang.org">Rust</a>. Rust — это системный язык программирования,
внимание которого сосредоточено на трёх задачах: безопасность, скорость и
параллелизм. Он решает эти задачи без сборщика мусора, что делает его полезным в
ряде случаев, когда использование других языков было бы нецелесообразно: при
встраивании в другие языки, при написании программ с особыми пространственными и
временными требованиями, при написании низкоуровневого кода, такого как драйверы
устройств и операционные системы. Во время компиляции Rust делает ряд проверок
безопасности. За счёт этого не возникает накладных расходов во время выполнения
приложения и устраняются все гонки данных.  Это даёт Rust преимущество над
другими языками программирования, имеющими аналогичную направленность. Rust
также направлен на достижение «абстракции с нулевой стоимостью». Хотя некоторые
из этих абстракций и ведут себя как в языках высокого уровня, но даже тогда Rust
по-прежнему обеспечивает точный контроль, как делал бы язык низкого уровня.</p>
<p>Книга «Язык программирования Rust» делится на восемь разделов. Это введение
является первым из них. Затем идут:</p>
<ul>
<li><a href="getting-started.html">C чего начать</a> — Настройка компьютера для разработки на Rust.</li>
<li><a href="learn-rust.html">Изучение Rust</a> — Обучение программированию на Rust на примере небольших
проектов.</li>
<li><a href="effective-rust.html">Эффективное использование Rust</a> — Понятия более высокого уровня для
написания качественного кода на Rust.</li>
<li><a href="syntax-and-semantics.html">Синтаксис и семантика</a> — Каждое понятие Rust разбивается на небольшие
кусочки.</li>
<li><a href="nightly-rust.html">Нестабильные возможности Rust</a> — Передовые возможности, которые пока не
добавлены в стабильную сборку.</li>
<li><a href="glossary.html">Глоссарий</a> — Ссылки на термины, используемые в книге.</li>
<li><a href="academic-research.html">Академические исследования</a> — Литература, которая оказала влияние на Rust.</li>
</ul>
<p>После прочтения этого введения, в зависимости от ваших предпочтений, вы можете
продолжить дальнейшее изучение либо в направлении «Изучение Rust», либо в
направлении «Синтаксис и семантика». Если вы предпочитаете изучить язык на
примере реального проекта, лучшим выбором будет раздел «Изучение Rust». Раздел
«Синтаксис и семантика» подойдёт тем, кто предпочитает тщательно изучить каждое
понятие языка отдельно, перед тем как двигаться дальше. Большое количество
перекрёстных ссылок соединяет эти части воедино.</p>
<h3>Содействие</h3>
<p>Исходные файлы, из которых генерируется оригинал этой книги, могут быть найдены
на Github:
<a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
<p>Исходные файлы перевода этой книги на русский язык также находятся на GitHub:
<a href="https://github.com/kgv/rust_book_ru">github.com/kgv/rust_book_ru</a></p>
<h2>Краткое введение в Rust</h2>
<p>Чем же Rust может заинтересовать вас? Давайте рассмотрим несколько небольших
примеров кода, чтобы продемонстрировать некоторые из его сильных сторон.</p>
<p>Основное понятие, которое делает Rust уникальным, называется «владение».
Рассмотрим следующий небольшой пример:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];
}
</code></pre>
<p>Эта программа создаёт <a href="variable-bindings.html">связанное имя</a> <code>x</code>. Его значением является <code>Vec&lt;T&gt;</code>,
«вектор», который мы создаём с помощью <a href="macros.html">макроса</a>, определённого в
стандартной библиотеке. Этот макрос называется <code>vec</code>, и при его вызове
используется символ <code>!</code>. Это следует из общего принципа Rust: делать вещи
явными. Макрос может делать значительно более сложные вещи, чем вызовы функций,
и поэтому они визуально отличаются. Символ <code>!</code> также помогает при разборе, что
облегчает написание инструментов, а это тоже важно.</p>
<p>Мы использовали <code>mut</code>, чтобы сделать <code>x</code> изменяемым: связанные имена в Rust по
умолчанию неизменяемы. Дальше в примере мы будем изменять этот вектор.</p>
<p>Стоит также отметить, что здесь нам не нужно указывать тип, несмотря на то, что
Rust является статически типизированным. Rust может выводить типы, что позволяет
достичь компромисса между мощью статической типизации и многословностью указания
типов.</p>
<p>Rust предпочитает выделять память в стеке, а не в куче: <code>x</code> находится
непосредственно в стеке. Однако тип <code>Vec&lt;T&gt;</code> выделяет пространство для элементов
вектора в куче. Если вы не знакомы с различиями этих двух видов выделения
памяти, можете пока просто проигнорировать эту информацию или же ознакомиться с
разделом «<a href="the-stack-and-the-heap.html">Стек и Куча</a>». Как системный язык программирования, Rust даёт
вам возможность контролировать выделение памяти. Но не будем забегать вперёд, мы
только начинаем изучение языка.</p>
<p>Ранее мы упоминали, что «владение» — это то, что делает Rust уникальным. В
терминологии Rust, <code>x</code> «владеет» вектором. Это означает, что как только <code>x</code>
выходит из области видимости, выделенная для вектора память будет освобождена.
Когда это будет происходить, определяется средствами компилятора Rust, а не
через механизмы наподобие сборщика мусора. Другими словами, в Rust вы не
вызываете функции вроде <code>malloc</code> и <code>free</code> собственноручно: компилятор статически
определяет, когда нужно выделить или освободить память, и вставляет эти вызовы
самостоятельно. Человек может совершить ошибку при использовании этих вызовов, а
компилятор — никогда.</p>
<p>Давайте добавим ещё одну строку в наш пример:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = &amp;x[0];
}
</code></pre>
<p>Мы создаём ещё одно имя, <code>y</code>. В этом случае, <code>y</code> является «ссылкой» на первый
элемент вектора. Ссылки в Rust похожи на указатели в других языках, но с
дополнительными проверками безопасности на этапе компиляции. Ссылки
взаимодействуют с системой прав владения при помощи
«<a href="references-and-borrowing.html">заимствования</a>». Ссылки заимствуют то, на что они указывают, а не
получают права владения им. Разница в том, что при заимствовании ссылка не
освобождает основную память, когда выходит за пределы области видимости. Если бы
это было не так, то память освобождалась бы два раза — плохо!</p>
<p>Давайте добавим третью строку. На первый взгляд в коде нет ничего такого, но он
вызывает ошибку компиляции:</p>
<pre><code class="language-rust,ignore">fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = &amp;x[0];

    x.push(&quot;foo&quot;);
}
</code></pre>
<p><code>push</code> — это метод, который добавляет ещё один элемент в конец вектора. Когда мы
пытаемся скомпилировать эту программу, то получаем ошибку:</p>
<pre><code class="language-text">error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push(&quot;foo&quot;);
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &amp;x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Вот так! Компилятор Rust в некоторых случаях выдаёт достаточно подробные ошибки,
и это как раз один из таких случаев. Как объясняется в ошибке, несмотря на то,
что мы и сделали наше имя изменяемым, мы всё ещё не можем вызвать метод
<code>push</code>. Это потому, что у нас уже есть ссылка на элемент вектора, <code>y</code>. Изменять
вектор, пока существует другая ссылка на него, опасно, потому что можно сделать
ссылку недействительной. В данном конкретном случае, когда мы создаём вектор, у
нас есть выделенное пространство памяти только для двух элементов. Добавление
третьего элемента будет означать выделение новой области памяти для всех этих
элементов, копирование старых значений и обновление внутреннего указателя на эту
память.  Всё это работает просто отлично. Проблема заключается в том, что <code>y</code> не
будет обновлена, из-за чего мы получим «зависший указатель». И это плохо. В этом
случае любое использование <code>y</code> будет означать ошибку. Компилятор обнаружил
данную проблему.</p>
<p>Так как же нам решить эту проблему? Есть два подхода, которые мы можем
использовать. Первый заключается в создании копии вместо ссылки:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = x[0].clone();

    x.push(&quot;foo&quot;);
}
</code></pre>
<p>По умолчанию, Rust использует <a href="ownership.html#move-semantics">семантику перемещения</a>, поэтому, если мы
хотим сделать копию некоторых данных, мы должны вызывать метод <code>clone()</code>. В этом
примере <code>y</code> больше не является ссылкой на вектор, хранящийся в <code>x</code>, но является
копией его первого элемента, <code>&quot;Hello&quot;</code>. Теперь, когда у нас больше нет ссылки,
метод <code>push()</code> прекрасно работает.</p>
<p>Если нам всё же нужна ссылка, то следует использовать другой вариант: убедиться,
что наша ссылка выходит из области видимости, прежде чем мы попытаемся сделать
изменения. Это выглядит примерно так:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    {
        let y = &amp;x[0];
    }

    x.push(&quot;foo&quot;);
}
</code></pre>
<p>Мы создали внутреннюю область видимости с помощью дополнительных фигурных
скобок. <code>y</code> выйдет за пределы этой области видимости до вызова метода <code>push()</code>,
и поэтому все будет хорошо.</p>
<p>Концепция владения хороша не только для предотвращения проблемы повисших
указателей, но также и для всей совокупности связанных с этим проблем, таких
как: недействительность итератора, параллелизм и многое другое.</p>
<h1>C чего начать</h1>
<p>Первый раздел книги рассказывает о том, как начать работать с Rust и его
инструментами. Сначала мы установим Rust, затем напишем классическую программу
«Hello World», и, наконец, поговорим о Cargo, который представляет из себя
систему сборки и менеджер пакетов в Rust.</p>
<h1>Установка Rust</h1>
<p>Первым шагом к использованию Rust является его установка! Есть несколько
способов установить Rust, но самый простой из них — использовать скрипт
<code>rustup</code>. Если вы используете Linux или Mac, то всё, что вам нужно сделать — это
ввести следующую команду в консоль:</p>
<blockquote>
<p>Примечание: вам не нужно вводить символы <code>$</code>, они просто обозначают начало
команд. В интернете вы найдёте много руководств и примеров, которые следуют
этому соглашению: <code>$</code> для команд, запускаемых из-под обычного пользователя, и
<code>#</code> для команд, которые нужно выполнять из-под администратора.</p>
</blockquote>
<pre><code class="language-bash">$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>Если вы беспокоитесь о <a href="http://curlpipesh.tumblr.com">потенциальной безопасности</a> использования
команды <code>curl | sh</code>, то продолжайте читать далее. Вы также можете использовать
двухступенчатый вариант установки и изучить наш установочный скрипт:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh
</code></pre>
<p>Если же вы используете Windows, то, пожалуйста, скачайте соответствующий
<a href="http://www.rust-lang.org/install.html">установщик</a>:</p>
<h2>Удаление</h2>
<p>Если вы решили, что Rust вам больше не нужен, то мы будем чуть-чуть огорчены, но
это нормально. Не каждый язык программирования подходит всем. Просто запустите
скрипт удаления:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>
<p>Некоторые люди, причём не безосновательно, насторожились, когда мы сказали
использовать <code>curl | sh</code>. Когда вы делаете так, вы должны доверять тем хорошим
людям, которые поддерживают Rust, и не бояться, что они попытаются взломать ваш
компьютер и сделать какие-либо плохие вещи. Озабоченность своей безопасностью -
это очень хорошо. Если вы один из таких людей, пожалуйста посмотрите в
документации как <a href="https://github.com/rust-lang/rust#building-from-source">собрать Rust из исходных кодов</a> или скачайте уже
<a href="http://www.rust-lang.org/install.html">скомпилированный Rust</a>.</p>
<p>Мы также должны упомянуть официально поддерживаемые платформы:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 и более новые, разные дистрибутивы), x86 и x86-64</li>
<li>OSX 10.7 (Lion) и более новые, x86 и x86-64</li>
</ul>
<p>Rust активно тестируется на всех этих платформах, а также на некоторых других,
например на Android. Но мы указали те, на которых Rust точно должен работать,
ибо для этих платформ он тестируется больше всего.</p>
<p>Напоследок, замечание о Windows. Windows для Rust — это такая же первоклассная
целевая платформа. К сожалению, если честно, разрабатывать программы на Rust на
Windows не так приятно, как на Linux и OS X. Но мы занимаемся этим! Если что-то
не работает, то это ошибка. Пожалуйста, дайте нам знать, если такое произойдёт.
Каждый коммит тестируется на Windows, впрочем, как и на всех остальных
платформах.</p>
<p>Если вы уже установили Rust, то откройте терминал и введите это:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Вы должны увидеть версию, хэш коммита, дату коммита и дату сборки:</p>
<pre><code class="language-bash">rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
</code></pre>
<p>Итак, теперь у вас есть установленный Rust! Поздравляем!</p>
<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в директории
<code>/usr/local/share/doc/rust</code>. В Windows — в директории <code>share/doc</code>, относительно
того куда вы установили Rust.</p>
<p>Есть ещё несколько мест, где можно получить помощь.  Есть
<a href="irc://irc.mozilla.org/#rust">Канал #rust на irc.mozilla.org</a>, к которому вы можете подключиться через
<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться в чате с другими
Rustaceans (это дурашливое прозвище, которым мы себя называем), и мы поможем
вам. Другие полезные ресурсы, посвящённые Rust: <a href="http://users.rust-lang.org/">форум пользователей</a>,
<a href="http://www.reddit.com/r/rust">/r/rust subreddit</a>, <a href="http://stackoverflow.com/questions/tagged/rust">stack overflow</a>. Русскоязычные
ресурсы: <a href="irc://irc.mozilla.org/#rust-ru">канал #rust-ru на irc.mozilla.org</a>,
<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-ru">веб-подключение к #rust-ru</a>, <a href="https://groups.google.com/forum/#!forum/rust-russian">google groups</a>.</p>
<h1>Привет, мир!</h1>
<p>Теперь, когда вы установили Rust, давайте напишем первую программу на Rust.
Традиционно, в любом новом изучаемом языке программирования, первая программа
просто выводит на экран текст «Привет, мир!». Хорошо начинать с такой простой
программы, т.к. вы можете убедиться, что ваш компилятор не только установлен, но
и работает правильно. Вывод информации на экран будет замечательным способом
проверить это.</p>
<p>Первое, с чего мы должны начать, это создать файл для нашего кода. Мне нравится
размещать директорию <code>projects</code> в домашней директории и хранить там все мои
проекты. Для Rust не имеет значения, где располагается ваш код.</p>
<p>На самом деле это приводит к ещё одной проблеме, о которой мы должны
предупредить: данное руководство предполагает, что у вас есть базовые навыки
работы в командной строке. У Rust нет специфичных требований к вашей среде
разработки или тому, где вы храните свой код. Если вы больше предпочитаете
использовать IDE, можно посмотреть на проект <a href="https://github.com/oakes/SolidOak">SolidOak</a>, или на
плагины к вашей любимой IDE. Существует множество расширений разного качества,
созданных сообществом. Команда разработчиков Rust так же предоставила
<a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">плагины для различных редакторов</a>. Настройка вашего редактора или IDE
выходит за пределы данного руководства. Посмотрите руководство по использованию
выбранного вами плагина.</p>
<p>С учётом вышесказанного, давайте сделаем поддиректорию для нашей программы в
директории с проектами.</p>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Если вы используете Windows и не используете PowerShell, <code>~</code> может не работать.
Обратитесь к документации вашей оболочки для уточнения деталей.</p>
<p>Теперь создадим новый файл для текста программы. Назовём наш файл <code>main.rs</code>.
Файлы с исходными текстами на Rust всегда имеют расширение <code>.rs</code>. Если вы
хотите использовать в имени вашего файла больше одного слова, разделяйте их
подчёркиванием: <code>hello_world.rs</code>, а не <code>helloworld.rs</code>.</p>
<p>Теперь когда файл открыт, добавьте в него следующий код:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Привет, мир!&quot;);
}
</code></pre>
<p>Сохраните файл, а затем введите эти команды в ваше окно терминала:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main # или main.exe в Windows
Привет, мир!
</code></pre>
<p>Работает! Разберём подробнее что же произошло. (Примечание переводчика: вам
нужен терминал с поддержкой юникода, чтобы вывод русских символов работал
правильно. Большинство современных терминалов поддерживают юникод из коробки.)</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<p>Эти строки определяют «функцию» в Rust. Функция <code>main</code> особенна: это начало
каждой программы на Rust. Первая строка говорит: «Мы объявляем функцию,
именуемую <code>main</code>, которая не получает параметров и ничего не возвращает». Если
бы мы хотели передать в функцию параметры, то указали бы их в скобках (<code>(</code> и
<code>)</code>). Так как нам не надо ничего возвращать из этой функции, мы можем опустить
указание типа возвращаемого значения. Мы вернёмся к этому позже.</p>
<p>Вы должны были заметить, что функция обёрнута в фигурные скобки (<code>{</code> и <code>}</code>).
Rust требует их вокруг тел всех функций. Также хорошим стилем считается ставить
открывающую фигурную скобку на той же строке, что и объявление функции,
отделённую от него одним пробелом.</p>
<p>Теперь эта строка:</p>
<pre><code class="language-rust">    println!(&quot;Привет, мир!&quot;);
</code></pre>
<p>Эта строка делает всю работу в нашей маленькой программе. Тут есть несколько
нюансов, которые имеют существенное значение. Во-первых, отступ в четыре
пробела, а не табуляция. Пожалуйста, настройте выбранный вами редактор так,
чтобы вставлять четыре пробела при помощи клавиши табуляции. Мы предоставляем
некоторые <a href="https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">примеры настроек для различных редакторов</a>.</p>
<p>Теперь разберёмся с <code>println!()</code>. Это вызов <a href="macros.html">макроса</a>, которыми
представлено метапрограммирование в Rust. Если бы вместо макроса была функция,
это бы выглядело следующим образом: <code>println()</code>. Для достижения нашей цели, нас
не должна волновать эта разница. Просто знайте, что иногда вы будете видеть <code>!</code>,
по которому можно понять, что вы вызываете макрос вместо обычной функции.  Rust
реализует <code>println!</code> как макрос вместо функции по веским причинам, но это
достаточно глубокая тема, и мы обсудим этот момент позже. И последнее, что нужно
отметить: макросы Rust значительно отличаются от макросов C, если вы их
использовали. Не бойтесь использовать макросы. В конце концов мы вернёмся к
деталям, а сейчас просто доверьтесь нам.</p>
<p>Идём дальше. <code>&quot;Привет, мир!&quot;</code> — это «строка». Строки — это удивительно сложная
тема в системном языке программирования. Это «статически расположенная в памяти»
строка. Если вы хотите больше узнать про расположении в памяти, рекомендуем
почитать про <a href="the-stack-and-the-heap.html">стек и кучу</a>, но в принципе вы можете пока не
заботиться о таких деталях. Мы передаём строку в качестве аргумента в
<code>println!</code>, который выводит строки на экран. Это достаточно просто!</p>
<p>В завершение, строка заканчивается точкой с запятой (<code>;</code>). Rust — это <code>язык с ориентацией на выражения</code>, а это означает, что в нём большая часть вещей
является выражением. <code>;</code> используется для указания, что выражение закончилось и
начинается следующее. Большинство строк кода на Rust заканчивается на <code>;</code>.</p>
<p>Наконец, скомпилируем и запустим нашу программу. Соберём программу компилятором
<code>rustc</code>, передав ему в качестве аргумента название нашего файла с кодом:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>Это похоже на <code>gcc</code> или <code>clang</code>, если вы программировали раньше на C или C++.
Rust создаст двоичный исполняемый файл. Вы можете убедиться в этом с помощью
<code>ls</code>:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>Или в Windows:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>У нас есть два файла: файл с нашим исходным кодом, с расширением <code>.rs</code>, и
исполняемый файл (<code>main.exe</code> в Windows, <code>main</code> в остальных случаях).</p>
<pre><code class="language-bash">$ ./main  # или main.exe в Windows
</code></pre>
<p>Мы вывели наш текст <code>&quot;Привет, мир!&quot;</code> в окне терминала.</p>
<p>Если вы пришли из динамических языков программирования вроде Ruby, Python или
JavaScript, необходимость предварительной компиляции программы может показаться
вам необычной. Rust — это язык, программы на котором <em>компилируются перед
исполнением</em>. Это означает, что вы можете собрать программу, дать её кому-то
ещё, и ему не нужно устанавливать Rust. Если вы передадите кому-нибудь <code>.rb</code>,
<code>.py</code> или <code>.js</code> файл, им понадобится Ruby/Python/JavaScript, чтобы
скомпилировать и запустить вашу программу, но компиляция и запуск этих программ
делается одной командой (например, <code>python main.py</code>). В мире языков
программирования много компромиссов, и Rust сделал свой выбор.</p>
<p>Поздравляем! Вы написали первую программу на Rust. Это делает вас программистом
на Rust! Добро пожаловать!</p>
<p>Дальше мы познакомимся с новым инструментом <code>Cargo</code>, который используется для
написания настоящих программ на Rust. Использовать <code>rustc</code> удобно лишь для
небольших программ, но по мере роста проекта, потребуется инструмент, который
поможет управлять настройками проекта, а также облегчит обмен кода с другими
людьми и проектами.</p>
<h1>Hello, Cargo!</h1>
<p><a href="http://doc.crates.io">Cargo</a> — это инструмент, который используют разработчики для
управления своими Rust проектами. Работа над Cargo пока ещё не закончена.
Сейчас он находится в состоянии pre-1.0. Тем не менее, он уже
достаточно хорош для использования во многих Rust проектах, и поэтому
предполагается, что проекты на Rust будут использовать Cargo с самого начала.</p>
<p>Cargo делает три вещи: собирает ваш код, скачивает нужные вашему коду
зависимости и собирает их. Поначалу, вашей программе не понадобится никаких
зависимостей, поэтому будем использовать только первую часть его функционала. Со
временем нам понадобится добавить несколько зависимостей, и нам не составит
труда сделать это, поскольку мы начали использовать Cargo.</p>
<p>Если вы использовали официальный установщик, то Cargo установился вместе с
Rust. Если же вы установили Rust каким-либо другим образом, вы можете
посмотреть <a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">инструкции по установке Cargo</a>.</p>
<h2>Переходим на Cargo</h2>
<p>Давайте начнём использовать Cargo для сборки кода нашей программы «Hello World».</p>
<p>Чтобы Cargo-фицировать ваш проект, вы должны сделать две вещи: создать
конфигурационный файл <code>Cargo.toml</code> и поместить файл с исходным кодом в
правильное место. Давайте сделаем это:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
</code></pre>
<p>Отметим, что поскольку мы создаём исполняемый файл, то мы использовали
<code>main.rs</code>. Если же вместо этого мы хотим сделать библиотеку, то мы должны
использовать <code>lib.rs</code>. Специальное расположение файла для точки входа может быть
задано с помощью ключа [<code>[lib]</code> или <code>[[bin]]</code>]<a href="http://doc.crates.io/manifest.html#configuring-a-target">crates-custom</a> в файле TOML,
который описывается ниже.</p>
<p>Cargo ожидает что ваши файлы с исходным кодом находятся в директории <code>src</code>. Это
оставляет верхний уровень для других вещей вроде README, файлов с текстом
лицензии и других не относящихся к вашему коду. Cargo помогает нам сохранять
наши проекты красивыми и аккуратными. Всему своё место и всё на своём месте.</p>
<p>Дальше, создадим конфигурационный файл для Cargo:</p>
<pre><code class="language-bash">$ editor Cargo.toml
</code></pre>
<p>Убедитесь, что имя правильное: вам нужна заглавная <code>C</code>!</p>
<p>Вставьте эту конфигурацию в свой <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Ваше имя &lt;you@example.ru&gt;&quot; ]
</code></pre>
<p>Этот файл в формате <a href="https://github.com/toml-lang/toml">TOML</a>. Позволим ему самому рассказать о себе:</p>
<blockquote>
<p>TOML стремится быть минималистичным форматом для конфигурационных файлов,
который легко читается благодаря понятной семантике. TOML спроектирован для
однозначного отображения в хэш-таблицу. TOML должен легко преобразовываться в
структуры данных широкого спектра языков программирования.</p>
</blockquote>
<p>TOML очень похож на INI, но с некоторыми дополнительными возможностями.</p>
<p>Итак, мы с этим закончили и готовы к сборке! Попробуйте собрать:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Привет, мир!
</code></pre>
<p>Та-да! Мы собрали наш проект вызвав <code>cargo build</code> и запустили его с помощью
<code>./target/debug/hello_world</code>. Мы можем сделать это в один шаг используя <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>Заметьте, что сейчас мы не пересобирали наш проект. Cargo понял, что мы не
изменили файл с исходным кодом и только лишь запустил исполняемый файл. Если бы
мы изменили файл, мы бы увидели оба шага:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>На первый взгляд это кажется сложнее, по сравнению с более простым использованием
<code>rustc</code>, но подумаем о будущем: если бы в нашем проекте было больше одного
файла, мы бы должны были вызвать <code>rustc</code> для каждого и передать ему кучу
параметров, что бы собрать их все вместе. С Cargo, когда наш проект вырастет,
нам понадобится вызвать только команду <code>cargo build</code> и она всё сделает за нас.</p>
<p>Когда вы закончите работать над проектом, и он окончательно будет готов к релизу,
то можете использовать команду <code>cargo build --release</code> для компиляции ваших
контейнеров (crates) с оптимизацией.</p>
<p>Так же вы должны были заметить, что Cargo создал новый файл: <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Этот файл используется Cargo для отслеживания зависимостей в вашем приложении.
Прямо сейчас у нас нет ни одной, поэтому этот файл немного пустоват. Вам не
нужно редактировать этот файл самостоятельно, Cargo сам с ним разберётся.</p>
<p>Так! Мы успешно собрали <code>hello_world</code> с помощью Cargo. Несмотря на то, что наша
программа проста, мы использовали большую часть реальных инструментов, которые
вы будете использовать в своём дальнейшем пути Rust программиста. Вы можете
использовать их во всех Rust проектах:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h2>Новый проект</h2>
<p>Вам не нужно повторять вышеприведённые шаги каждый раз, когда вы хотите создать
новый проект! Cargo может создать директорию проекта, в котором вы сразу сможете
приступить к разработке.</p>
<p>Чтобы создать новый проект с помощью Cargo, нужно ввести команду <code>cargo new</code>:</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>Мы указываем аргумент <code>--bin</code>, т.к. хотим создать исполняемую программу. Если мы
не укажем этот аргумент, то Cargo создаст проект для библиотеки.</p>
<p>Давайте теперь посмотрим на то, что Cargo создал нам:</p>
<pre><code class="language-bash">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 директория, 2 файла
</code></pre>
<p>Если у вас нет команды <code>tree</code>, то скорее всего эта программа не установлена в
вашей системе. Попробуйте установить её через менеджер пакетов вашего
дистрибутива. Это не обязательно, но данная утилита очень полезна.</p>
<p>Все файлы и директории уже на месте. Теперь можем начинать. Для начала проверим
файл <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Ваше Имя &lt;you@example.ru&gt;&quot;]
</code></pre>
<p>Cargo наполнил этот файл значениями по умолчанию на основании переданных
аргументов и глобальной конфигурации <code>git</code>. Обратите внимание, что Cargo уже в
директории <code>hello_world</code> создал репозиторий для <code>git</code>.</p>
<p>Также заглянем в <code>src/main.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Привет, мир!&quot;);
}
</code></pre>
<p>Cargo создал «Hello World!» для нас и вы уже можете приступить к
программированию! У Cargo есть собственное <a href="http://doc.crates.io/guide.html">руководство</a> в котором
про него рассказано более полно.</p>
<p>Теперь давайте отложим инструментарий и узнаем больше о самом языке. Это основы,
которые вы будете часто использовать на протяжении всего вашего взаимодействия с
Rust.</p>
<p>У вас есть два пути: погрузиться в изучение реального проекта, раздел
«<a href="learn-rust.html">Изучение Rust</a>», или начать с самого низа и постепенно продвигаться
наверх, раздел «<a href="syntax-and-semantics.html">Синтаксис и семантика</a>». Программисты, имеющие опыт
работы с системными языками, вероятно, предпочтут «Изучение Rust», в то время
как программисты, имеющие опыт работы с динамическими языками, вполне возможно,
пойдут по второму пути. Разные люди учатся по-разному! Выберите то, что подходит
именно вам.</p>
<h1>Изучение Rust</h1>
<p>Добро пожаловать! Этот раздел книги содержит несколько глав, которые научат вас
создавать проекты на Rust. Вы также получите поверхностное представление о языке</p>
<ul>
<li>мы не будем сильно углубляться в детали.</li>
</ul>
<p>Если вы хотите более основательно изучить язык, читайте раздел
«<a href="syntax-and-semantics.html">Синтаксис и семантика</a>».</p>
<h1>Угадайка</h1>
<p>В качестве нашего первого проекта, мы решим классическую для начинающих
программистов задачу: игра-угадайка. Немного о том, как игра должна работать:
наша программа генерирует случайное целое число из промежутка от 1 до 100. Затем
она просит ввести число, которое она «загадала». Для каждого введённого нами
числа, она говорит, больше ли оно, чем «загаданное», или меньше. Игра
заканчивается когда мы отгадываем число. Звучит не плохо, не так ли?</p>
<h1>Создание нового проекта</h1>
<p>Давайте создадим новый проект. Перейдите в вашу директорию с проектами. Помните,
как мы создавали структуру директорий и <code>Cargo.toml</code> для <code>hello_world</code>? Cargo
может сделать это за нас. Давайте воспользуемся этим:</p>
<pre><code class="language-bash">$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>Мы сказали Cargo, что хотим создать новый проект с именем <code>guessing_game</code>. При
помощи флага <code>--bin</code>, мы указали что хотим создать исполняемый файл, а не
библиотеку.</p>
<p>Давайте посмотрим сгенерированный <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo взял эту информацию из вашего рабочего окружения. Если информация не
корректна, исправьте её.</p>
<p>Наконец, Cargo создал программу <code>Привет, мир!</code>. Посмотрите файл <code>src/main.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Привет, мир!&quot;)
}
</code></pre>
<p>Давайте попробуем скомпилировать созданный Cargo проект:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>Замечательно! Снова откройте <code>src/main.rs</code>. Мы будем писать весь наш код в этом
файле.</p>
<p>Прежде, чем мы начнём работу, давайте рассмотрим ещё одну команду Cargo: <code>run</code>.
<code>cargo run</code> похожа на <code>cargo build</code>, но после завершения компиляции, она
запускает получившийся исполняемый файл:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Привет, мир!
</code></pre>
<p>Великолепно! Команда <code>run</code> помогает, когда надо быстро пересобирать проект. Наша
игра как раз и есть такой проект: нам надо быстро тестировать каждое изменение,
прежде чем мы приступим к следующей части программы.</p>
<h1>Обработка предположения</h1>
<p>Давайте начнём! Первая вещь, которую мы должны сделать для нашей игры — это
позволить игроку вводить предположения. Поместите следующий код в ваш
<code>src/main.rs</code>:</p>
<pre><code class="language-rust,no_run">use std::io;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre>
<p>Здесь много чего! Давайте разберём этот участок по частям.</p>
<pre><code class="language-rust,ignore">use std::io;
</code></pre>
<p>Нам надо получить то, что ввёл пользователь, а затем вывести результат на экран.
Значит нам понадобится библиотека <code>io</code> из стандартной библиотеки. Изначально, во
<a href="http://doc.rust-lang.org/std/prelude/index.html">вступлении</a> (prelude), Rust импортирует в нашу программу лишь самые
необходимые вещи. Если чего-то нет по вступлении, мы должны указать при помощи
<code>use</code>, что хотим это использовать.</p>
<pre><code class="language-rust,ignore">fn main() {
</code></pre>
<p>Как вы уже видели до этого, функция <code>main()</code> — это точка входа в нашу программу.
<code>fn</code> объявляет новую функцию. Пустые круглые скобки <code>()</code> показывают, что она не
принимает аргументов. Открывающая фигурная скобка <code>{</code> начинает тело нашей
функции. Из-за того, что мы не указали тип возвращаемого значения,
предполагается, что будет возвращаться <code>()</code> — пустой <a href="primitive-types.html#tuples">кортеж</a>.</p>
<pre><code class="language-rust,ignore">    println!(&quot;Угадайте число!&quot;);

    println!(&quot;Пожалуйста, введите предположение.&quot;);
</code></pre>
<p>Мы уже изучили, что <code>println!()</code> — это <a href="macros.html">макрос</a>, который выводит
<a href="strings.html">строки</a> на экран.</p>
<pre><code class="language-rust,ignore">    let mut guess = String::new();
</code></pre>
<p>Теперь интереснее! Как же много всего происходит в этой строке! Первая вещь, на
которую следует обратить внимание — <a href="variable-bindings.html">выражение let</a>, которое используется
для <code>создания связи</code>. Оно выглядит так:</p>
<pre><code class="language-rust,ignore">let foo = bar;
</code></pre>
<p>Это создаёт новую связь с именем <code>foo</code> и привязывает ей значение <code>bar</code>. Во
многих языках это называется <code>переменная</code>, но в Rust связывание переменных имеет
несколько трюков в рукаве.</p>
<p>Например, по умолчанию, связи <a href="mutability.html">неизменяемы</a>. По этой причине наш
пример использует <code>mut</code>: этот модификатор разрешает менять связь. С левой
стороны у <code>let</code> может быть не просто имя связи, а <a href="patterns.html">образец</a>. Мы будем
использовать их дальше. Их достаточно просто использовать:</p>
<pre><code class="language-rust">let foo = 5; // неизменяемая связь
let mut bar = 5; // изменяемая связь
</code></pre>
<p>Ах да, <code>//</code> начинает комментарий, который заканчивается в конце строки. Rust
игнорирует всё, что находится в <a href="comments.html">комментариях</a>.</p>
<p>Теперь мы знаем, что <code>let mut guess</code> объявляет изменяемую связь с именем
<code>guess</code>, а по другую сторону от <code>=</code> находится то, что будет привязано:
<code>String::new()</code>.</p>
<p><code>String</code> — это строковый тип, предоставляемый нам стандартной библиотекой.
[<code>String</code>]<a href="http://doc.rust-lang.org/std/string/struct.String.html">string</a> — это текст в кодировке UTF-8 переменной длины.</p>
<p>Синтаксис <code>::new()</code> использует <code>::</code>, так как это привязанная к определённому
типу функция. То есть, она привязана к самому типу <code>String</code>, а не к определённой
переменной типа <code>String</code>. Некоторые языки называют это «статическим методом».</p>
<p>Имя этой функции — <code>new()</code>, так как она создаёт новый, пустой <code>String</code>. Вы
можете найти эту функцию у многих типов, потому что это общее имя для создания
нового значения определённого типа.</p>
<p>Давайте посмотрим дальше:</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Это уже побольше! Давайте это всё разберём. В первой строке есть две части.
Это первая:</p>
<pre><code class="language-rust,ignore">io::stdin()
</code></pre>
<p>Помните, как мы импортировали (<code>use</code>) <code>std::io</code> в самом начале нашей программы?
Сейчас мы вызвали ассоциированную с ним функцию. Если бы мы не сделали <code>use std::io</code>, нам бы пришлось здесь написать <code>std::io::stdin()</code>.</p>
<p>Эта функция возвращает обработчик стандартного ввода нашего терминала. Более
подробно об это можно почитать в <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
<p>Следующая часть использует этот обработчик для получения всего, что введёт
пользователь:</p>
<pre><code class="language-rust,ignore">.read_line(&amp;mut guess)
</code></pre>
<p>Здесь мы вызвали метод [<code>read_line()</code>]<a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line</a> обработчика. <a href="method-syntax.html">Методы</a>
похожи на привязанные функции, но доступны только у определённого экземпляра
типа, а не самого типа. Мы указали один аргумент функции <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
<p>Помните, как мы выше привязали <code>guess</code>? Мы сказали, что она изменяема. Однако,
<code>read_line</code> не получает в качестве аргумента <code>String</code>: она получает <code>&amp;mut String</code>. В Rust есть такая особенность, называемая «<a href="references-and-borrowing.html">ссылки</a>»,
которая позволяет нам иметь несколько ссылок на одни и те же данные, что
позволяет избежать излишнего их копирования. Ссылки — достаточно сложная
особенность, и одним из основных подкупающих достоинств Rust является то, как он
решает вопрос безопасности и простоты их использования. Пока что мы не должны
знать об этих деталях, чтобы завершить нашу программу. Сейчас, всё, что нам
нужно — это знать, что ссылки, как и связывание при помощи <code>let</code>, неизменяемы по
умолчанию. Следовательно, мы должны написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>.</p>
<p>Почему <code>read_line()</code> получает изменяемую ссылку на строку? Его работа — это
взять то, что пользователь написал в стандартный ввод, и положить это в
строку. Итак, функция получает строку в качестве аргумента, и для того, чтобы
добавить в эту строку что-то, она должна быть изменяемой.</p>
<p>Но мы пока что ещё не закончили с этой строкой кода. Пока это одна строка
текста, это только первая часть одной логической строки кода:</p>
<pre><code class="language-rust,ignore">        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Когда мы вызываем метод, используя синтаксис <code>.foo()</code>, мы можем перенести вызов
в новую строку и сделать для него отступ. Это помогает работать с длинными
строками. Мы <em>могли бы</em> сделать и так:</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess).ok().expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Но это достаточно трудно читать. Поэтому мы разделили строку: по строке на
каждый вызов метода. Мы уже поговорили о <code>read_line()</code>, но ещё ничего не сказали
про <code>ok()</code> и <code>expect()</code>. Мы узнали, что <code>read_line()</code> передаёт всё, что
пользователь ввёл в <code>&amp;mut String</code>, которую мы ему передали. Но этот метод так же
и возвращает значение: в данном случае — [<code>io::Result</code>]<a href="http://doc.rust-lang.org/std/io/type.Result.html">ioresult</a>. В стандартной
библиотеке Rust есть несколько типов с именем <code>Result</code>: общая версия
[<code>Result</code>]<a href="http://doc.rust-lang.org/std/result/enum.Result.html">result</a> и несколько отдельных версий в подбиблиотеках, например
<code>io::Result</code>.</p>
<p>Целью типов <code>Result</code> является преобразование информации об ошибках, полученных
от обработчика. У значений типа <code>Result</code>, как и любого другого типа, есть
определённые для него методы. В данном случае, у <code>io::Result</code> имеется метод
<code>ok()</code>, который говорит, что «мы хотим получить это значение, если всё прошло
хорошо. Если это не так, выбрось сообщение об ошибке». Но зачем выбрасывать? Для
небольших программ, мы можем захотеть только вывести сообщение об ошибке и
прекратить выполнение программы. [Метод <code>ok()</code>]<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.ok">ok</a> возвращает значение, у
которого объявлен другой метод: <code>expect()</code>. [Метод <code>expect()</code>]<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a> берёт
значение, для которого он вызван, и если оно не удачное, выполняет
[<code>panic!</code>]<a href="error-handling.html">panic</a> со строкой, заданной методу в качестве аргумента. <code>panic!</code>
остановит нашу программу и выведет сообщение об ошибке.</p>
<p>Eсли мы уберем вызовы этих двух методов, наша программа скомпилируется, но
мы получим следующее предупреждение:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust предупреждает, что мы не используем значение <code>Result</code>. Это предупреждение
пришло из специальной аннотации, которая указана в <code>io::Result</code>. Rust пытается
сказать нам, что мы не обрабатываем ошибки, которые могут возникнуть. Наиболее
правильным решением предотвращения ошибки будет её обработка. К счастью, если
мы только хотим обрушить приложение, если есть проблема, мы можем использовать
эти два небольших метода. Если мы можем восстановить что-либо из ошибки, мы
должны сделать что-либо другое, но мы сохраним это для будущего проекта.</p>
<p>Там всего одна строка из первого примера:</p>
<pre><code class="language-rust,ignore">    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre>
<p>Здесь выводится на экран строка, которая была получена с нашего ввода. <code>{}</code> -
это указатель места заполнения. В качестве второго аргумента макроса <code>println!</code>
мы указали <code>guess</code>. Если нам надо вывести несколько привязок, в самом простом
случае, мы должны поставить несколько указателей, по одному на каждую привязку:</p>
<pre><code class="language-rust">let x = 5;
let y = 10;

println!(&quot;x и y: {} и {}&quot;, x, y);
</code></pre>
<p>Просто.</p>
<p>Мы можем запустить то, что у нас есть при помощи <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Угадайте число!
Пожалуйста, введите предположение.
6
Ваша попытка: 6
</code></pre>
<p>Всё правильно! Наша первая часть завершена: мы можем получать данные с
клавиатуры и потом печатать их на экран.</p>
<h1>Генерация секретного числа</h1>
<p>Далее, нам надо сгенерировать секретное число. В стандартной библиотеке Rust нет
ничего, что могло бы нам предоставить функционал для генерации случайных чисел.
Однако, разработчики Rust для этого предоставили [контейнер (crate) <code>rand</code>]
<a href="https://crates.io/crates/rand">randcrate</a>.
«Контейнер» — это пакет с кодом Rust. Наш проект — «бинарный контейнер», из
которого в итоге получится исполняемый файл. <code>rand</code> — «библиотечный контейнер»,
который содержит код, предназначенный для использования с другими программами.</p>
<p>Прежде, чем мы начнём писать код с использованием <code>rand</code>, мы должны
модифицировать наш <code>Cargo.toml</code>. Откроем его и добавим в конец следующие
строчки:</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p>Секция <code>[dependencies]</code> похожа на секцию <code>[package]</code>: всё, что расположено после
объявления секции и до начала следующей, является частью этой секции. Cargo
использует секцию с зависимостями чтобы знать о том, какие сторонние контейнеры
потребуются, а так же какие их версии необходимы. В данном случае, мы используем
версию <code>0.3.0</code>. Cargo понимает <a href="http://semver.org/lang/ru">семантическое версионирование</a>, которое
является стандартом нумерации версий. Если мы хотим использовать последнюю
версию контейнера, мы можем использовать <code>*</code>. Так же мы можем указать
необходимый промежуток версий. В <a href="http://doc.crates.io/crates-io.html">документации Cargo</a> есть больше
информации.</p>
<p>Теперь, без каких-либо изменений в нашем коде, давайте соберём наш проект:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>(Конечно же, вы можете видеть другие версии.)</p>
<p>Много нового! Теперь, когда у нас есть внешние зависимости, Cargo скачал
последние версии каждой из них из своего реестра, являющегося копией реестра с
<a href="https://crates.io">Crates.io</a>. Crates.io — это место, где программисты на Rust могут
публиковать свои проекты с открытым исходным кодом, чтобы их использовали в
других проектах.</p>
<p>После обновления реестра, Cargo проверяет раздел <code>[dependencies]</code> и скачивает
всё, что нам необходимо. В нашем случае, мы сказали, что наш проект зависит от
<code>rand</code>. Самому контейнеру <code>rand</code> для работы нужен контейнер <code>libc</code>. По этой
причине Cargo скачал и <code>libc</code>. После загрузки всего необходимого, оно
компилируется, а затем компилируется и наш проект.</p>
<p>Если мы запустим <code>cargo build</code> снова, текст вывода будет другим:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>Всё правильно, ничего не будет выведено! Cargo знает, что уже собраны и наш
проект, и все его зависимости, а значит незачем делать это снова. Раз делать
ничего не надо, Cargo просто завершил работу. Если мы снова откроем файл
<code>src/main.rs</code>, сделаем какие-нибудь изменения и затем сохраним их, мы увидим
только одну строку:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>Итак, мы сказали Cargo, что нам нужна библиотека <code>rand</code> с любой версией ветки
<code>0.3.x</code>, и он взял последнюю версию, на тот момент, когда его запустили -
<code>v0.3.8</code>. Но что делать, когда на следующей неделе выйдет версия <code>v0.3.9</code>,
содержащая важные изменения? Что если исправления настолько масштабны, что
версия <code>0.3.9</code> становится несовместимой с нашим кодом?</p>
<p>Решением этой проблемы является файл <code>Cargo.lock</code>, который находится в
директории с нашим проектом. Когда мы в первый раз собирали наш проект, Cargo
подобрал версии, подходящие под наши условия, и записал их в файл <code>Cargo.lock</code>.
Когда мы в будущем будем собирать наш проект, Cargo будет проверять, существует
ли <code>Cargo.lock</code>, и затем использовать указанные в нём версии контейнеров.
Благодаря этому мы автоматически получаем повторяемые сборки. Другими словами,
мы будем использовать контейнер версии <code>0.3.8</code> до тех пор, пока явно не обновим
информацию о его версии в <code>Cargo.lock</code>.</p>
<p>А что, если мы захотим использовать версию <code>v0.3.9</code>? У Cargo есть другая
команда, <code>update</code>, которая скажет «игнорируй Cargo.lock, найди последние версии
библиотек из той ветки, которую мы указали в Cargo.toml. Когда всё сделаешь,
запиши информацию о версиях в Cargo.lock». Но по умолчанию, Cargo смотрит только
версию больше, чем <code>0.3.0</code>, и меньше <code>0.4.0</code>. Если мы хотим перейти на версии
<code>0.4.x</code>, мы должны указать это в <code>Cargo.toml</code>. Потом, когда мы запустим <code>cargo build</code>, Cargo обновит индекс и пересмотрит наши требования к <code>rand</code>.</p>
<p>В <a href="http://doc.crates.io">документации</a> по Cargo можно узнать о нём, а так же о
<a href="http://doc.crates.io/crates-io.html">его экосистеме</a> намного больше, но пока что это всё, что нам
нужно знать. Cargo делает повторное использование библиотек намного проще, и
программисты на Rust, как правило, пишут небольшие проекты, которые входят в
состав других более крупных проектов.</p>
<p>Давайте использовать <code>rand</code>. Вот наш следующий шаг:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre>
<p>Первое, что мы сделали — изменили первую строку. Теперь она выглядит так:
<code>extern crate rand</code>. Так как мы указали <code>rand</code> в разделе <code>[dependencies]</code>, мы
можем использовать <code>extern crate</code> для того, чтобы Rust знал, что мы собираемся
использовать эту зависимость. <code>extern crate</code> также выполняет эквивалент
оператора <code>use rand;</code>, т.е. теперь мы можем использовать всё, что есть в
контейнере <code>rand</code>, используя префикс <code>rand::</code>.</p>
<p>Далее, мы добавили новую строку <code>use</code>: <code>use rand::Rng</code>. Мы собираемся
использовать метод, а ему нужно, чтобы Rng был в области видимости. Основная
идея такова: методы, объявленные где-то в другом месте, называются «типажами»
(traits), и для того, чтобы этот метод можно было использовать, необходимо чтобы
типаж был в области видимости. Чтобы узнать об этом более подробно, можно
прочитать секцию о <a href="traits.html">типажах</a>.</p>
<p>Мы добавили две новые строки в середину кода:</p>
<pre><code class="language-rust,ignore">    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);
</code></pre>
<p>Мы используем функцию <code>rand::thread_rng()</code> для получения копии генератора
случайных чисел, который будет локальным для текущего <a href="concurrency.html">потока</a>
выполнения. Выше мы добавили <code>use rand::Rng</code> и теперь можем использовать метод
<code>gen_range()</code>. Этот метод получает два аргумента и генерирует число, которое
может быть больше либо равно первому аргументу и меньше, чем второй аргумент.
Таким образом, если мы укажем числа 1 и 101, то от генератора можно получить
числа от 1 до 100 включительно.</p>
<p>Вторая строка печатает наше секретное число. Это поможет нам во время
тестирования, пока мы разрабатываем нашу программу. Но мы обязательно удалим эту
строчку в финальной версии. Будет не интересно играть в игру, если она сразу
печатает ответ!</p>
<p>Давайте запустим изменённую программу:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 7
Пожалуйста, введите предположение.
4
Ваша попытка: 4
$ cargo run
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 83
Пожалуйста, введите предположение.
5
Ваша попытка: 5
</code></pre>
<p>Замечательно! Следующий шаг: сравнение нашего предположения с «загаданным»
числом.</p>
<h1>Сравнение</h1>
<p>Теперь, когда мы знаем, что ввёл пользователь, давайте сравним «загаданное»
число с предполагаемым ответом. Здесь приведён наш следующий шаг, который, к
сожалению, не будет работать:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
        Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
    }
}
</code></pre>
<p>Здесь мы видим что-то новое. Первое — это ещё один <code>use</code>. Мы ввели в область
видимости тип <code>std::cmp::Ordering</code>. Далее, ещё пять новых строк в конце, которые
используют его:</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
    Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
    Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
}
</code></pre>
<p>Метод <code>cmp()</code> может быть вызван у чего-либо, что может сравниваться, и
получает ссылку на то, с чем мы хотим его сравнить. Результатом сравнения будет
тип <code>Ordering</code>, который мы добавили выше. Мы используем оператор
[<code>match</code>]<a href="match.html">match</a> для определения <code>Ordering</code> — результата сравнения.
<code>Ordering</code> — [<code>перечисление</code>]<a href="enums.html">enum</a>. Они обозначаются <code>enum</code>, сокращённо от
<code>enumeration</code> (перечисление). Перечисления выглядят следующим образом:</p>
<pre><code class="language-rust">enum Foo {
    Bar,
    Baz,
}
</code></pre>
<p>С таким определением, всё, что имеет тип <code>Foo</code> может иметь значение либо
<code>Foo::Bar</code>, либо <code>Foo::Baz</code>. Мы используем <code>::</code> для обозначения пространства
имён для вариантов перечисления.</p>
<p>У перечисления [<code>Ordering</code>]<a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html">ordering</a> есть три возможных варианта: <code>Less</code>,
<code>Equal</code> и <code>Greater</code>. Выражение <code>match</code> получает переменную какого-либо типа и
предлагает вам создать «ветви» для каждого возможного значения. Так как у нас
есть три возможных значения <code>Ordering</code>, у нас будет три ветви:</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
    Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
    Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
}
</code></pre>
<p>Если результатом сравнения будет значение <code>Less</code>, мы выведем на экран <code>Слишком маленькое!</code>; если будет <code>Greater</code>, то <code>Слишком большое!</code>; и если <code>Equal</code>, то
<code>Вы выиграли!</code>. <code>match</code> очень удобен и он часто используется в Rust.</p>
<p>Мы упоминали, что это не совсем корректный код, но всё же давайте попробуем:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>У-у-у! Это большая ошибка. Суть этой ошибки в «несоответствии типов» (mismatched
types). В Rust строгая статическая система типов. Однако, у нас также есть вывод
типов. Когда мы пишем <code>let guess = String::new()</code>, Rust понимает, что
<code>guess</code> должна быть типа <code>String</code>, благодаря чему мы можем не указывать тип
явно. <code>secret_number</code> — число, которое может иметь значение от одного до ста.
Оно может иметь тип <code>i32</code> — 32-битное целое, или <code>u32</code> — 32-битное целое без
знака, или <code>i64</code> — 64-битное целое, или какой-нибудь другой. По умолчанию, Rust
сделает его 32-битным целым, <code>i32</code>. Однако, здесь Rust не знает как сравнить
<code>guess</code> и <code>secret_number</code>. Они должны быть одного типа. В итоге, чтобы можно
было сравнить <code>guess</code> и <code>secret_number</code>, мы должны преобразовать переменную
<code>guess</code>, которую мы прочитали с ввода, из типа <code>String</code> в настоящий числовой
тип. Мы можем сделать это, добавив несколько строчек. Вот как будет выглядеть
наша программа:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Не удалось прочитать строку&quot;);

    let guess: u32 = guess.trim().parse()
        .ok()
        .expect(&quot;Пожалуйста, введите число!&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
        Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
    }
}
</code></pre>
<p>Вот строки, которые мы добавили:</p>
<pre><code class="language-rust,ignore">    let guess: u32 = guess.trim().parse()
        .ok()
        .expect(&quot;Пожалуйста, введите число!&quot;);
</code></pre>
<p>Подождите минутку, у нас ведь уже есть <code>guess</code>? Rust позволил нам «затенить»
(скрыть) предыдущее <code>guess</code> новым. Это часто используется в подобных случаях,
когда <code>guess</code> изначально бывает типа <code>String</code>, но нам требуется преобразовать её
в <code>u32</code>. Затенение позволяет нам переиспользовать имя <code>guess</code>, а не создавать
для каждого типа новое уникальное имя, такое как <code>guess_str</code> и <code>guess</code>
или какое-нибудь другое.</p>
<p>Мы связали <code>guess</code> с выражением, которое похоже на то, что мы писали ранее:</p>
<pre><code class="language-rust,ignore">guess.trim().parse()
</code></pre>
<p>За которым следует вызов <code>ok().expect()</code>. Здесь <code>guess</code> ссылается на старый
<code>guess</code>, который ещё является строкой, которую мы получили с ввода. Метод
<code>trim()</code> у типа <code>String</code> удаляет всё пустое пространство с начала и конца нашей
строки. Это важно, ведь для нормальной работы <code>read_line()</code> нам необходимо
нажать <code>Enter</code> после окончания ввода. Это значит, что если мы набрали <code>5</code> и
нажали <code>Enter</code>, <code>guess</code> выглядит следующим образом: <code>5\n</code>. <code>\n</code> обозначает
«новую строку» (newline) — значение клавиши <code>Enter</code>. <code>trim()</code> удалит его и
оставит только <code>5</code>. [Метод <code>parse()</code>]<a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse">parse</a>, применяемый к строке, преобразует
её в число. Он может анализировать различные числа, но мы можем указать Rust
какой именно тип нам нужен. Поэтому мы указали <code>let guess: u32</code>. Двоеточие <code>:</code>,
идущее после <code>guess</code>, говорит Rust, что мы указали тип значения. <code>u32</code> -
32-битное беззнаковое целое число. У Rust есть <a href="primitive-types.html#numeric-types">несколько встроенных числовых
типов</a>, но мы выбрали именно <code>u32</code>. Это достаточно хороший тип, чтобы
хранить небольшие положительные числа.</p>
<p>Как и <code>read_line()</code>, вызов <code>parse()</code> может вызвать проблемы. Что, если наша
строка будет содержать <code>A👍%</code>? Мы не сможем преобразовать её в число. Как и в
случае с <code>read_line()</code>, мы будем использовать методы <code>ok()</code> и <code>expect()</code> на
случай, если <code>parse()</code> не сможет преобразовать строку.</p>
<p>Давайте запустим нашу программу!</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 58
Пожалуйста, введите предположение.
  76
Ваша попытка: 76
Слишком большое!
</code></pre>
<p>Замечательно! Вы можете видеть, что мы добавили пробел перед нашим числом, но
программа поняла, что мы хотели сказать <code>76</code>. Запустим программу ещё несколько
раз и проверим, что загадывание числа работает.</p>
<p>Теперь большая часть нашей игры работает, но мы можем сделать только одно
предположение. Давайте изменим это, добавив циклы!</p>
<h1>Зацикливание</h1>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Давайте добавим его:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect(&quot;Пожалуйста, введите число!&quot;);

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
        }
    }
}
</code></pre>
<p>И посмотрим на работу приложения. Но подождите, мы же добавили бесконечный цикл?
Всё верно. Помните что мы говорили о <code>parse()</code>? Если мы введём не числовой
ответ, мы просто выйдем из программы. Посмотрите:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 59
Пожалуйста, введите предположение.
45
Ваша попытка: 45
Слишком маленькое!
Пожалуйста, введите предположение.
60
Ваша попытка: 60
Слишком большое!
Пожалуйста, введите предположение.
59
Ваша попытка: 59
Вы выиграли!
Пожалуйста, введите предположение.
quit
thread '&lt;main&gt;' panicked at 'Пожалуйста, введите число!'
</code></pre>
<p>Ха! Если мы введём <code>quit</code>, то действительно выйдем из программы. Как и при вводе
любого другого не числового значения. Что ж, это, мягко говоря, не очень хорошо.
Для начала, давайте сделаем выход из программы, если мы выиграли игру:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = guess.trim().parse()
            .ok()
            .expect(&quot;Пожалуйста, введите число!&quot;);

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>С добавлением строки <code>break</code> после вывода <code>Вы выиграли!</code>, мы получили
возможность выхода из цикла, когда мы угадали загаданное число. Выход из цикла
также означает и завершение нашей программы, так как это последнее, что есть в
<code>main()</code>. Нам надо сделать ещё одно улучшение — при любом не числовом вводе, мы
не должны выходить из программы, мы просто должны проигнорировать ввод. Мы можем
сделать это следующим образом:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Это строка, которую мы изменили:</p>
<pre><code class="language-rust,ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Здесь показано, как мы можем перейти от «сбоя при ошибке» к «обработке ошибки»
заменив <code>ok().expect()</code> на инструкцию <code>match</code>. <code>Result</code>, возвращённый функцией
<code>parse()</code>, как и <code>Ordering</code>, является перечислением. Однако в данном случае
каждый из вариантов имеет некоторые ассоциированные с ним данные: <code>Ok</code> — успех,
<code>Err</code> — ошибку. У каждого есть некоторая дополнительная информация:
преобразованное число, либо тип ошибки. Здесь мы проверили значение результата
работы <code>parse()</code> при помощи <code>match</code>. В случае, если результат равен <code>Ok</code>, то
<code>match</code> привяжет внутреннее значение результата (<code>Ok(num)</code>) к имени <code>num</code> и
вернёт в привязку <code>guess</code>. Когда происходит ошибка (Err), нам не важно, какая
именно это ошибка, поэтому мы используем вместо имени _. Так мы проигнорируем
ошибку и вызовем <code>continue</code>, который отправит нас на следующую итерацию цикла.</p>
<p>Теперь всё должно быть нормально! Давайте посмотрим:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 61
Пожалуйста, введите предположение.
10
Ваша попытка: 10
Слишком маленькое!
Пожалуйста, введите предположение.
99
Ваша попытка: 99
Слишком большое!
Пожалуйста, введите предположение.
foo
Пожалуйста, введите предположение.
61
Ваша попытка: 61
Вы выиграли!
</code></pre>
<p>Замечательно! Если мы ещё чуть-чуть подкрутим нашу программу, игра будет готова.
Догадываетесь, что нужно поменять? Всё правильно, мы не должны выводить наше
секретное число. Знание этого числа хорошо для тестирования, но оно портит всю
игру. Так выглядит окончательный вариант нашего кода:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .ok()
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h1>Готово!</h1>
<p>Вы сделали «Угадайку»! Поздравляем!</p>
<p>Этот первый проект показал вам следующее: <code>let</code>, <code>match</code>, методы, привязанные
функции, использование внешних контейнеров и многое другое. Наш следующий проект
покажет ещё больше.</p>
<h1>Обедающие философы</h1>
<p>Для нашего второго проекта мы выбрали классическую задачу с параллелизмом. Она
называется «Обедающие философы». Задача была сформулирована в 1965 году Эдсгером
Дейкстрой, но мы будем использовать версию задачи, <a href="http://www.usingcsp.com/cspbook.pdf">адаптированную</a> в
1985 году Ричардом Хоаром.</p>
<blockquote>
<p>В древние времена богатые филантропы пригласили погостить пятерых выдающихся
философов. Им выделили каждому по комнате, в которой они могли заниматься своей
профессиональной деятельностью — мышлением. Также была общая столовая, где стоял
большой круглый стол, а вокруг него пять стульев. Каждый стул имел табличку с
именем философа, который должен был сидеть на нем. Слева от каждого философа
лежала золотая вилка, а в центре стола стояла большая миска со спагетти, которая
постоянно пополнялась. Как подобает философам, они большую часть своего времени
проводили в раздумьях. Но однажды они почувствовали голод и отправились в
столовую. Каждый сел на свой стул, взял по вилке и воткнул её в миску со
спагетти. Но сущность запутанных спагетти такова, что необходима вторая вилка,
чтобы отправлять спагетти в рот. То есть философу требовалась еще и вилка справа
от него. Философы положили свои вилки и встали из-за стола, продолжая думать.
Ведь вилка может быть использована только одним философом одновременно. Если
другой философ захочет её взять, то ему придется ждать когда она освободится.</p>
</blockquote>
<p>Эта классическая задача показывает различные элементы параллелизма. Сложность
реализации задачи состоит в том, что простая реализация может зайти в
безвыходное состояние. Давайте рассмотрим простой пример решения этой проблемы:</p>
<ol>
<li>Философ берет вилку в свою левую руку.</li>
<li>Затем берет вилку в свою правую руку.</li>
<li>Ест.</li>
<li>Кладет вилки на место.</li>
</ol>
<p>Теперь представим это как последовательность действий философов:</p>
<ol>
<li>Философ 1 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 2 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 3 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 4 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 5 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>...? Все вилки заняты и никто не может начать есть! Безвыходное состояние.</li>
</ol>
<p>Есть различные пути решения этой задачи. Мы в этом руководстве покажем свое
решение. Сначала давайте начнем с моделирования задачи. Начнем с философов:</p>
<pre><code class="language-rust">struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}

fn main() {
    let p1 = Philosopher::new(&quot;Джудит Батлер&quot;);
    let p2 = Philosopher::new(&quot;Рая Дунаевская&quot;);
    let p3 = Philosopher::new(&quot;Зарубина Наталья&quot;);
    let p4 = Philosopher::new(&quot;Эмма Гольдман&quot;);
    let p5 = Philosopher::new(&quot;Анна Шмидт&quot;);
}
</code></pre>
<p>Здесь мы создаем [<code>struct</code>]<a href="structs.html">struct</a>, представляющую философа. На данный момент
нам нужно всего лишь имя. Мы выбрали тип [<code>String</code>]<a href="strings.html">string</a>, а не <code>&amp;str</code> для
хранения имени. Обычно проще работать с типом, владеющим данными, чем с типом,
использующим ссылки.</p>
<p>Продолжим:</p>
<pre><code class="language-rust"># struct Philosopher {
#     name: String,
# }
impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
</code></pre>
<p>Этот блок <code>impl</code> позволяет объявить что-либо для структуры <code>Philosopher</code>. В
нашем случае мы объявляем «статическую функцию» <code>new</code>. Первая строка этой
функции выглядит так:</p>
<pre><code class="language-rust"># struct Philosopher {
#     name: String,
# }
# impl Philosopher {
fn new(name: &amp;str) -&gt; Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
</code></pre>
<p>Она принимает один аргумент, <code>name</code>, типа <code>&amp;str</code>. Это ссылка на другую строку.
Она возвращает новый экземпляр нашей структуры <code>Philosopher</code>.</p>
<pre><code class="language-rust"># struct Philosopher {
#     name: String,
# }
# impl Philosopher {
#    fn new(name: &amp;str) -&gt; Philosopher {
Philosopher {
    name: name.to_string(),
}
#     }
# }
</code></pre>
<p>Этот код создаёт новый экземпляр <code>Philosopher</code> и присваивает его полю <code>name</code>
значение переданного аргумента <code>name</code>. Но используется не сам аргумент, а
результат вызова его метода <code>.to_string()</code>. Этот вызов создаёт копию строки, на
которую указывает наш <code>&amp;str</code>, и возвращает новый экземпляр <code>String</code>, который и
будет присвоен полю <code>name</code> структуры <code>Philosopher</code>.</p>
<p>Почему бы сразу не передавать строку типа <code>String</code> напрямую? Так легче ее
вызывать. Если бы мы принимали тип <code>String</code>, а тот, кто вызывает функцию, имел
бы ссылку на строку, <code>&amp;str</code>, то ему пришлось бы приводить ее к типу <code>String</code>
перед каждым вызовом. Это уменьшит гибкость кода, и мы будем вынуждены <em>каждый
раз</em> создавать копию строки. Для этой небольшой программы это не очень важно,
так как мы знаем, что будем использовать только короткие строки.</p>
<p>И последнее на что следует обратить внимание: мы просто объявляем структуру
<code>Philosopher</code> и кажется, что ничего больше не делаем. Rust — это язык
программирования, «ориентированный на выражения», что означает, что каждое
выражение возвращает значение. Это верно и для функций, у которых автоматически
возвращается последнее выражение. Так как в нашем примере в последнем выражении
функции мы создаем структуру <code>Philosopher</code>, то она и будет возвращена функцией.</p>
<p>Имя функции <code>new()</code> не регламентируется Rust. Это просто соглашение об
именовании функций, которые возвращают новые экземпляры структур. Давайте снова
посмотрим на функцию <code>main()</code>:</p>
<pre><code class="language-rust"># struct Philosopher {
#     name: String,
# }
# 
# impl Philosopher {
#     fn new(name: &amp;str) -&gt; Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
# 
fn main() {
    let p1 = Philosopher::new(&quot;Джудит Батлер&quot;);
    let p2 = Philosopher::new(&quot;Рая Дунаевская&quot;);
    let p3 = Philosopher::new(&quot;Зарубина Наталья&quot;);
    let p4 = Philosopher::new(&quot;Эмма Гольдман&quot;);
    let p5 = Philosopher::new(&quot;Анна Шмидт&quot;);
}
</code></pre>
<p>Здесь мы связываем пять имен переменных с пятью новыми философами. Здесь указаны
имена некоторых известных философов, но вы можете указать любые другие. Если бы
мы <em>не объявили</em> свою реализацию функции <code>new()</code>, то наш код выглядел бы так:</p>
<pre><code class="language-rust"># struct Philosopher {
#     name: String,
# }
fn main() {
    let p1 = Philosopher { name: &quot;Джудит Батлер&quot;.to_string() };
    let p2 = Philosopher { name: &quot;Рая Дунаевская&quot;.to_string() };
    let p3 = Philosopher { name: &quot;Зарубина Наталья&quot;.to_string() };
    let p4 = Philosopher { name: &quot;Эмма Гольдман&quot;.to_string() };
    let p5 = Philosopher { name: &quot;Анна Шмидт&quot;.to_string() };
}
</code></pre>
<p>Этот код выглядит не слишком изящно. Использование статической функции <code>new</code>
имеет и другие преимущества, но даже в этом простом случае, её использование
было оправдано.</p>
<p>Теперь у нас уже есть каркас программы, и можно заняться решением задачи с
обедающими философами. Начнем с конца: сделаем так, чтобы философ сообщал нам,
когда он закончит есть. Для этого потребуется метод, сообщающий нам об окончании
приема пищи, и цикл, запускающий этот метод для каждого философа.</p>
<pre><code class="language-rust">struct Philosopher {
    name: String,
}   

impl Philosopher { 
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
    
    fn eat(&amp;self) {
        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    for p in &amp;philosophers {
        p.eat();
    }
}
</code></pre>
<p>Давайте сначала рассмотрим функцию <code>main()</code>. Вместо того чтобы создавать пять
отдельных связанных имен для философов, мы создаем для них <code>Vec&lt;T&gt;</code>. <code>Vec&lt;T&gt;</code>
называют «вектор», он является расширяемой версией массива. Затем в цикле
[<code>for</code>]<a href="loops.html#for">for</a> мы перебираем вектор, получая ссылку на очередного философа на
каждой итерации.</p>
<p>В теле цикла мы вызываем метод <code>p.eat()</code>, который объявлен выше:</p>
<pre><code class="language-rust,ignore">fn eat(&amp;self) {
    println!(&quot;{} закончила есть.&quot;, self.name);
}
</code></pre>
<p>В Rust методы явно получают параметр <code>self</code>. Вот почему <code>eat()</code> является
методом, а <code>new</code> — статической функцией: <code>new()</code> не получает параметр <code>self</code>.
Для нашей первой версии метода <code>eat()</code> мы выводим только имя философа и
сообщение о том, что он закончил есть. Запустив эту программу вы получите:</p>
<pre><code class="language-text">Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Это было не сложно! Осталось чуть-чуть и приступим к самой задаче.</p>
<p>Дальше нам нужно сделать так, чтобы философы не только заканчивали, но и
начинали есть. Это новая версия программы:</p>
<pre><code class="language-rust">use std::thread;

struct Philosopher {
    name: String,
}   

impl Philosopher { 
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
    
    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep_ms(1000);

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    for p in &amp;philosophers {
        p.eat();
    }
}
</code></pre>
<p>Появились некоторые небольшие изменения. Давайте посмотрим, что же изменилось:</p>
<pre><code class="language-rust,ignore">use std::thread;
</code></pre>
<p>Конструкция <code>use</code> предоставляет доступ к области видимости модуля <code>thread</code> из
стандартной библиотеки. Мы собираемся использовать этот модуль далее в коде, и
поэтому нам нужно объявить о его использовании.</p>
<pre><code class="language-rust,ignore">    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep_ms(1000);

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
</code></pre>
<p>Здесь мы выводим на экран два сообщения и вызываем функцию <code>sleep_ms</code> между
ними. Эта функция останавливает рабочий поток на 1000 миллисекунд, что
симулирует процесс приема пищи философа.</p>
<p>Если вы запустите программу теперь, то увидите, что каждый философ, по очереди,
начинает есть, ест какое-то время и заканчивает есть:</p>
<pre><code class="language-text">Джудит Батлер начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская начала есть.
Рая Дунаевская закончила есть.
Зарубина Наталья начала есть.
Зарубина Наталья закончила есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Анна Шмидт начала есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Превосходно! Теперь у нас осталась только одна проблема: наши философы едят по
очереди, а не одновременно, то есть мы пока не решили задачу параллелизма.</p>
<p>Для того, чтобы наши философы начали есть одновременно, нам нужно внести
некоторые изменения в код:</p>
<pre><code class="language-rust">use std::thread;

struct Philosopher {
    name: String,
}   

impl Philosopher { 
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep_ms(1000);

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
        thread::spawn(move || {
            p.eat();
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</code></pre>
<p>Мы добавили еще один цикл в функцию <code>main()</code>. Теперь она выглядит так:</p>
<pre><code class="language-rust,ignore">let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
    thread::spawn(move || {
        p.eat();
    })
}).collect();
</code></pre>
<p>Тут добавились трудные к пониманию пять строк кода. Давайте разбираться.</p>
<pre><code class="language-rust,ignore">let handles: Vec&lt;_&gt; = 
</code></pre>
<p>Объявляем новое связанное имя <code>handles</code>. Мы задали такое имя, потому что
собираемся создать несколько потоков, в результате чего получим для них
дескрипторы, с помощью которых сможем контролировать их выполнение. Здесь нам
нужно явно указать тип, а зачем это необходимо, мы расскажем чуть позже. <code>_</code> -
это заполнитель типа. Мы говорим компилятору «<code>handles</code> — это вектор, содержащий
элементы, тип которых Rust должен вывести самостоятельно».</p>
<pre><code class="language-rust,ignore">philosophers.into_iter().map(|p| {
</code></pre>
<p>Мы берем наш список философов и вызываем метод <code>into_iter()</code>. Этот метод создаёт
итератор, который при каждой итерации забирает право владения на соответствующий
элемент. Это нужно для передачи элемента вектора в поток. Мы берем этот итератор
и вызываем метод <code>map</code>, который принимает замыкание в качестве аргумента и
вызывает это замыкание для каждого из элементов итератора.</p>
<pre><code class="language-rust,ignore">    thread::spawn(move || {
        p.eat();
    })
</code></pre>
<p>Вот здесь происходит сам параллелизм. Функция <code>thread::spawn</code> принимает в
качестве аргумента замыкание и исполняет это замыкание в новом потоке. Это
замыкание дополнительно нуждается в указании ключевого слова <code>move</code>, которое
сообщает, что это замыкание получает владение переменными, которые оно
захватывает. В данном случае — переменной <code>p</code> функции <code>map</code>.</p>
<p>Внутри потока мы всего лишь вызываем метод <code>eat()</code> переменной <code>p</code>. Также
обратите внимание, что вызов <code>thread::spawn</code> не оканчивается точкой с запятой,
что превращает его в выражение. Этот нюанс важен, так как возвращается
правильное значение. Для получения более подробной информации, прочитайте главу
<a href="functions.html#expressions-vs.-statements">Выражения и операторы</a>.</p>
<pre><code class="language-rust,ignore">}).collect();
</code></pre>
<p>По завершении мы получаем результат вызова <code>map</code> и собираем полученный результат
в коллекцию с помощью метода <code>collect()</code>. Метод <code>collect()</code> создаёт коллекцию
какого-то типа, и для того, чтобы Rust понял, коллекцию какого типа мы хотим
получить, мы указали для <code>handle</code> тип принимаемого значения <code>Vec&lt;T&gt;</code>. Элементами
коллекции будут возвращаемые из методов <code>thread::spawn</code> значения, которые
являются дескрипторами этих потоков. Вот так!</p>
<pre><code class="language-rust,ignore">for h in handles {
    h.join().unwrap();
}
</code></pre>
<p>В конце функции <code>main()</code> мы в цикле перебираем каждый дескриптор и вызываем для
него метод <code>join()</code>, который блокирует дальнейшее исполнение основного потока,
пока не завершится дочерний поток. Это позволяет нам быть уверенными, что потоки
завершат работу до того как произойдет выход из программы.</p>
<p>Если вы запустите эту программу, то вы увидите, что философы едят не дожидаясь
своей очереди! У нас многопоточность!</p>
<pre><code class="language-text">Джудит Батлер начала есть.
Рая Дунаевская начала есть.
Зарубина Наталья начала есть.
Эмма Гольдман начала есть.
Анна Шмидт начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Но как же быть с вилками? Их мы пока ещё не смоделировали.</p>
<p>Давайте же начнем. Сначала сделаем новую структуру:</p>
<pre><code class="language-rust">use std::sync::Mutex;

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}
</code></pre>
<p>Структура <code>Table</code> содержит вектор мьютексов (<code>Mutex</code>). Мьютекс — способ
управления доступом к данным для параллельно выполняющихся потоков: только один
поток может получить доступ к данным в конкретный момент времени. Это именно то
свойство, которое нужно для реализации наших вилок. В коде мы используем пустой
кортеж, <code>()</code>, внутри мьютекса, так как не собираемся использовать это значение,
а мьютекс используется только для организации доступа.</p>
<p>Давайте изменим программу, используя структуру <code>Table</code>:</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Mutex, Arc};

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&amp;self, table: &amp;Table) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep_ms(1000);

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});

    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;, 0, 1),
        Philosopher::new(&quot;Рая Дунаевская&quot;, 1, 2),
        Philosopher::new(&quot;Зарубина Наталья&quot;, 2, 3),
        Philosopher::new(&quot;Эмма Гольдман&quot;, 3, 4),
        Philosopher::new(&quot;Анна Шмидт&quot;, 0, 4),
    ];

    let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
        let table = table.clone();

        thread::spawn(move || {
            p.eat(&amp;table);
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</code></pre>
<p>Много изменений! Однако, с этими изменениями мы получили корректно работающую
программу. Приступим к рассмотрению:</p>
<pre><code class="language-rust,ignore">use std::sync::{Mutex, Arc};
</code></pre>
<p>Нам далее понадобится структура <code>Arc&lt;T&gt;</code> из модуля стандартной библиотеки
<code>std::sync</code>. Мы поговорим о ней чуть позже.</p>
<pre><code class="language-rust,ignore">struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}
</code></pre>
<p>Нам понадобилось добавить еще два поля в нашу структуру <code>Philosopher</code>. Каждый
философ должен иметь две вилки: одну — для левой руки, другую — для правой руки.
Мы используем тип <code>usize</code> для идентификации каждой вилки. Мы используем его при
создании философа, передавая идентификаторы двух вилок. Эти два значения будут
использоваться полем <code>forks</code> структуры <code>Table</code>.</p>
<pre><code class="language-rust,ignore">fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
    Philosopher {
        name: name.to_string(),
        left: left,
        right: right,
    }
}
</code></pre>
<p>Мы используем функцию <code>new()</code> для задания значений <code>left</code> и <code>right</code>.</p>
<pre><code class="language-rust,ignore">fn eat(&amp;self, table: &amp;Table) {
    let _left = table.forks[self.left].lock().unwrap();
    let _right = table.forks[self.right].lock().unwrap();

    println!(&quot;{} начала есть.&quot;, self.name);

    thread::sleep_ms(1000);

    println!(&quot;{} закончила есть.&quot;, self.name);
}
</code></pre>
<p>Здесь появились две новые строки. Мы также добавили один аргумент, <code>table</code>. Мы
получаем доступ к списку вилок через структуру <code>Table</code>. Затем используем
идентификаторы вилок <code>self.left</code> и <code>self.right</code> для получения доступа к вилке по
определенному индексу. В результате чего мы получаем <code>Mutex</code>, который регулирует
доступ к вилке, и вызываем для него метод <code>lock()</code>, блокируя доступ к вилке.
Если в настоящее время доступ к вилке уже предоставлен кому-то еще, то мы будем
блокированы, пока вилка не станет доступной.</p>
<p>Вызов метода <code>lock()</code> может потерпеть неудачу, и если это случается, то мы
аварийно завершаем работу программы. Может возникнуть ситуация, когда поток
аварийно завершит свою работу, а мьютекс при этом останется заблокированным.
Такой мьютекс называется «<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#poisoning">отравленным (poisoned)</a>». Но в нашем случае
это не может произойти, потому как мы просто используем метод <code>unwrap()</code>.</p>
<p>Результаты выполнения этих двух строк имеют имена <code>_left</code> и <code>_right</code>
соответственно. Зачем мы используем знаки подчеркивания в начале имён? Это для
того, чтобы сказать компилятору, что мы хотим получить значения, которые далее
<em>не планируем использовать</em>. Таким образом Rust не будет выводить предупреждение
о неиспользуемых именах.</p>
<p>Когда же мьютекс будет освобождён? Это произойдет автоматически, когда <code>_left</code> и
<code>_right</code> выйдут из области видимости, то есть по окончании работы функции.</p>
<pre><code class="language-rust,ignore">    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});
</code></pre>
<p>Далее в <code>main()</code> мы создаем новый экземпляр структуры <code>Table</code> и оборачиваем его
в <code>Arc&lt;T&gt;</code>. Это «атомарный счетчик ссылок» (atomic reference count). Он нужен
для обеспечения доступа к нашей структуре <code>Table</code> из нескольких потоков. Когда
он передается в новый поток, то счетчик увеличивается, а когда этот поток
завершает работу, то счетчик уменьшается.</p>
<pre><code class="language-rust,ignore">let philosophers = vec![
    Philosopher::new(&quot;Джудит Батлер&quot;, 0, 1),
    Philosopher::new(&quot;Рая Дунаевская&quot;, 1, 2),
    Philosopher::new(&quot;Зарубина Наталья&quot;, 2, 3),
    Philosopher::new(&quot;Эмма Гольдман&quot;, 3, 4),
    Philosopher::new(&quot;Анна Шмидт&quot;, 0, 4),
];
</code></pre>
<p>Мы добавили наши значения <code>left</code> и <code>right</code> при создании структуры <code>Philosopher</code>.
Здесь есть <em>очень важная</em> деталь, на которую следует обратить внимание.
Посмотрите на последнюю строку создания <code>Philosopher</code>. Конструктор Анны Шмидт
должен был бы принимать в качестве аргументов значения <code>4</code> и <code>0</code>, но вместо
этого он принимает значения <code>0</code> и <code>4</code>. Это помешает нашей программе попасть в
безвыходное состояние, если каждый возьмет по одной вилке одновременно. Так что
давайте представим, что один из философов у нас левша! Это один из способов
решить данную проблему, и, на мой взгляд, самый простой.</p>
<pre><code class="language-rust,ignore">let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
    let table = table.clone();

    thread::spawn(move || {
        p.eat(&amp;table);
    })
}).collect();
</code></pre>
<p>Внутри нашего цикла <code>map()</code>/<code>collect()</code> мы вызываем метод <code>table.clone()</code>. Метод
<code>clone()</code> структуры <code>Arc&lt;T&gt;</code> клонирует значение и инкрементирует счетчик,
который автоматически декрементируется, когда клонированное значение покинет
область видимости. Это необходимо для того, чтобы мы знали, как много ссылок на
<code>table</code> существуют в рамках наших потоков на данный момент времени. Если бы у
нас не было подсчета ссылок, то мы бы не знали, как и когда освободить хранимое
значение.</p>
<p>Вы можете заметить, что здесь мы выполняем новое связывание с именем <code>table</code>,
затеняя старое связанное имя <code>table</code>. Это позволяет нам не вводить новое
уникальное имя.</p>
<p>Теперь наша программа работает! Только два философа могут обедать одновременно.
После запуска программы вы можете получить такой результат.</p>
<pre><code class="language-text">Рая Дунаевская начала есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Рая Дунаевская закончила есть.
Джудит Батлер начала есть.
Зарубина Наталья начала есть.
Джудит Батлер закончила есть.
Анна Шмидт начала есть.
Зарубина Наталья закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Поздравляем! Вы реализовали классическую задачу параллелизма на языке Rust.</p>
<h1>Вызов кода на Rust из других языков</h1>
<p>Для нашего третьего проекта мы собираемся выбрать что-то, что подчеркнёт одну из
самых сильных сторон в Rust: фактическое отсутствие среды исполнения.</p>
<p>По мере роста организации, программисты все больше полагаются на множество
языков программирования. У каждого языка программирования есть свои сильные и
слабые стороны, а знание нескольких языков позволяет использовать определенный
язык там, где проявляется его сильные стороны, и использовать другой язык там,
где первый не очень хорош.</p>
<p>Существует несколько областей, где многие языки программирования слабы в плане
производительности выполнения программ. Часто компромисс заключается в том,
чтобы использовать более медленный язык, который взамен способствует повышению
производительности программиста. Чтобы решить эту проблему, часть кода системы
можно написать на C, а затем вызвать этот код, написанный на C, как если бы он
был написан на языке высокого уровня. Это называется «интерфейс внешних функций»
(foreign function interface), часто сокращается до FFI.</p>
<p>Rust включает поддержку FFI в обоих направлениях: он легко может вызвать C код,
и он так же легко, как и C код, может быть вызван <em>извне</em>. Rust сочетает в себе
отсутствие сборщика мусора и низкие требования к среде исполнения, что делает
Rust отличным кандидатом на роль вызываемого из других языков, когда нужны
некоторые дополнительные возможности.</p>
<p>В этой книге есть целая <a href="ffi.html">глава, посвящённая FFI</a> и его специфике, а в этой
главе мы рассмотрим именно конкретный частный случай FFI, с тремя примерами, на
Ruby, Python и JavaScript.</p>
<h1>Проблема</h1>
<p>Есть много различных проектов, которые мы могли бы выбрать, но мы хотим
подобрать такой пример, который продемонстрирует явное преимущество Rust над
многими другими языками: сложные вычисления и многопоточность.</p>
<p>Во многих языках числа размещаются в куче, а не в стеке. Это обеспечивает
целостность поведения языка при работе с числами и с другими объектами. Особенно
в языках, которые сосредотачиваются на объектно-ориентированном программировании
и использовании сборщика мусора, по умолчанию память выделяется из кучи. Иногда,
при оптимизации, для конкретных чисел память может выделяться в стеке, но вместо
того, чтобы полагаться на работу оптимизации, мы можем захотеть убедиться в том,
что мы используем примитивные типы чисел, а не какой-либо тип объекта.</p>
<p>Во-вторых, многие языки имеют «глобальную блокировку интерпретатора» (global
interpreter lock), которая ограничивает параллелизм во многих ситуациях. Это
делается во имя безопасности, что оказывает положительный эффект, но это также и
ограничивает объем работ, который может быть выполнен одновременно, что, в свою
очередь, оказывает большой отрицательный эффект.</p>
<p>Чтобы подчеркнуть эти два аспекта, мы собираемся создать небольшой проект,
который в значительной степени их использует. Поскольку внимание в этом примере
сфокусировано на встраивание Rust в другие языки, а не самой проблеме, мы будем
использовать игрушечный пример:</p>
<blockquote>
<p>Запустить десять потоков. Внутри каждого потока считать от одного до пяти
миллионов. После того как все десять потоков завершатся, напечатать
&quot;сделано!&quot;.</p>
</blockquote>
<p>Мы выбрали пять миллионов руководствуясь тем, сколько времени занимает эта
работа на современном компьютере. Вот пример этого кода на Ruby:</p>
<pre><code class="language-ruby">threads = []

10.times do
  threads &lt;&lt; Thread.new do
    count = 0

    5_000_000.times do
      count += 1
    end
  end
end

threads.each { |t| t.join }
puts &quot;сделано!&quot;
</code></pre>
<p>Попробуйте запустить этот пример, и подберите число, которое обеспечит работу в
течение нескольких секунд. В зависимости от аппаратного обеспечения компьютера,
возможно, придется увеличить или уменьшить это число.</p>
<p>На выбранной нами системе эта программа работает <code>2.156</code> секунд. И если мы
воспользуемся какой-нибудь утилитой для мониторинга процессов (например, <code>top</code>),
то увидим, что она использует только одно ядро. Это GIL делает свое дело.</p>
<p>Хотя это и игрушечная программа, на ее примере можно продемонстрировать много
проблем, аналогичных этой, характерных для реального мира. Для наших целей,
долго крутящиеся занятые потоки представляют собой параллельные, требующие
больших затрат, вычисления.</p>
<h1>Библиотека на Rust</h1>
<p>Давайте перепишем эту задачу на Rust. Во-первых, давайте сделаем новый проект с
помощью Cargo:</p>
<pre><code class="language-bash">$ cargo new embed
$ cd embed
</code></pre>
<p>Эту программу легко переписать на Rust:</p>
<pre><code class="language-rust">use std::thread;

fn process() {
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        thread::spawn(|| {
            let mut x = 0;
            for _ in (0..5_000_000) {
                x += 1
            }
        x
        })
    }).collect();

    for h in handles {
        println!(&quot;Thread finished with count={}&quot;,
        h.join().map_err(|_| &quot;Could not join a thread!&quot;).unwrap());
    }
    println!(&quot;done!&quot;);
</code></pre>
<p>Мы уже знакомы с частью этого кода из предыдущих примеров. Мы создаем десять
потоков, собирая их в вектор <code>handles</code>. Внутри каждого потока мы осуществляем
пять миллионов повторений в цикле, и прибавляем к <code>x</code> единицу каждый раз.
Наконец, мы воссоединяем все потоки.</p>
<p>Сейчас, однако, это просто библиотека Rust, которая не включает все необходимое
для успешного вызова из другого языка. Если мы попытаемся подключить её к
другому языку в том виде, в котором она сейчас, то это не будет работать. Нам
нужно сделать два небольших изменения, чтобы исправить это. Первое, что мы
должны сделать, это изменить начало нашего кода:</p>
<pre><code class="language-rust,ignore">#[no_mangle]
pub extern fn process() {
</code></pre>
<p>Мы добавили новый атрибут, <code>no_mangle</code>. В процессе создания библиотеки Rust, в
выходном скомпилированном файле происходит изменение имени функции. Причины
этого выходят за рамки данного руководства, но для того, чтобы и другие языки
знали, как вызвать функцию, мы должны не делать этого. Указанный атрибут
выключает такое поведение.</p>
<p>Другим изменением, которое мы добавили, является <code>pub extern</code>. <code>pub</code> означает,
что эта функция может быть вызвана за пределами этого модуля, а <code>extern</code>
говорит, что её возможно вызвать из С. Вот и все! Не так и много изменений.</p>
<p>Второе, что мы должны сделать, это изменить настройки в <code>Cargo.toml</code>. Добавьте
это в конец файла:</p>
<pre><code class="language-toml">[lib]
name = &quot;embed&quot;
crate-type = [&quot;dylib&quot;]
</code></pre>
<p>Это говорит Rust, что мы хотим скомпилировать нашу библиотеку в виде стандартной
динамической библиотеки. По умолчанию, Rust компилирует в rlib, Rust-
специфичный формат.</p>
<p>Давайте теперь соберем проект:</p>
<pre><code class="language-bash">$ cargo build --release
   Compiling embed v0.1.0 (file:///home/steve/src/embed)
</code></pre>
<p>Мы ввели команду <code>cargo build --release</code>, которая выполняет сборку с включенной
оптимизацией. Мы хотим, чтобы код был как можно более быстрым! Вы можете найти
собранную библиотеку в <code>target/release</code>:</p>
<pre><code class="language-bash">$ ls target/release/
build  deps  examples  libembed.so  native
</code></pre>
<p>Файл <code>libembed.so</code> — и есть наша динамическая библиотека (shared object). Мы
можем использовать этот файл также как и любую другую динамическую библиотеку,
написанную на C! Попутно следует отметить, это может быть <code>embed.dll</code> или
<code>libembed.dylib</code>, в зависимости от платформы.</p>
<p>Теперь, когда мы получили нашу собранную библиотеку Rust, давайте используем её
из нашего кода на Ruby.</p>
<h1>Ruby</h1>
<p>Откройте файл <code>embed.rb</code> внутри нашего проекта, и сделайте следующее:</p>
<pre><code class="language-ruby">require 'ffi'

module Hello
  extend FFI::Library
  ffi_lib 'target/release/libembed.so'
  attach_function :process, [], :void
end

Hello.process

puts 'сделано!'
</code></pre>
<p>Прежде чем мы сможем запустить этот код, нам нужно установить пакет <code>ffi</code>:</p>
<pre><code class="language-bash">$ gem install ffi # this may need sudo
Fetching: ffi-1.9.8.gem (100%)
Building native extensions.  This could take a while...
Successfully installed ffi-1.9.8
Parsing documentation for ffi-1.9.8
Installing ri documentation for ffi-1.9.8
Done installing documentation for ffi after 0 seconds
1 gem installed
</code></pre>
<p>И, наконец, мы можем попробовать запустить его:</p>
<pre><code class="language-bash">$ ruby embed.rb
сделано!
$
</code></pre>
<p>Ничего себе, это было быстро! На моей системе это заняло <code>0.086</code> секунд, а не
две секунды как это было на чистом Ruby. Давайте разберем этот Ruby код:</p>
<pre><code class="language-ruby">require 'ffi'
</code></pre>
<p>Первый делом, нам надо объявить пакет <code>ffi</code>. Он предоставляет нам интерфейс для
использования нашей библиотеки на Rust, как библиотеку на C.</p>
<pre><code class="language-ruby">module Hello
  extend FFI::Library
  ffi_lib 'target/release/libembed.so'
</code></pre>
<p>Автор пакета <code>ffi</code> рекомендует использовать модуль, чтобы ограничить область
действия функции, которую мы импортировали из разделяемой библиотеки. Внутри мы
указали <code>extend</code>, чтобы воспользоваться необходимым модулем <code>FFI::Library</code>, а
затем вызвали <code>ffi_lib</code>, чтобы подгрузить нашу библиотеку. Мы просто передаем
путь к библиотеке, который мы уже видели раньше, это
<code>target/release/libembed.so</code>.</p>
<pre><code class="language-ruby">attach_function :process, [], :void
</code></pre>
<p>Метод <code>attach_function</code> предоставляется пакетом <code>FFI</code>. Здесь соединяются наша
функция <code>process()</code>, написанная на Rust, и одноименная функция на Ruby. Так как
<code>process()</code> не принимает аргументов, второй параметр является пустым массивом, и
поскольку функция ничего не возвращает, мы передаем <code>:void</code> в качестве
завершающего аргумента.</p>
<pre><code class="language-ruby">Hello.process
</code></pre>
<p>Здесь мы совершаем вызов нашей Rust функции. Сочетание нашего <code>module</code> и вызова
к <code>attach_function</code> завершает подготовку. Это выглядит как функция Ruby, но на
самом деле это Rust!</p>
<pre><code class="language-ruby">puts 'сделано!'
</code></pre>
<p>Наконец, в соответствие с нашими требованиями к проекту, мы пишем <code>сделано!</code> по
окончанию работы программы.</p>
<p>Вот и все! Как мы увидели, совместить два языка очень просто, и взамен мы
получили большую производительность.</p>
<p>Теперь давайте попробуем на Python!</p>
<h1>Python</h1>
<p>Создайте файл <code>embed.py</code> в этой директории и поместите в него следующее:</p>
<pre><code class="language-python">from ctypes import cdll

lib = cdll.LoadLibrary(&quot;target/release/libembed.so&quot;)

lib.process()

print(&quot;сделано!&quot;)
</code></pre>
<p>Довольно просто! Мы импортируем <code>cdll</code> из модуля <code>ctypes</code>. Затем вызваем
<code>LoadLibrary</code>. И теперь мы можем вызвать <code>process()</code>.</p>
<p>На моей системе это заняло <code>0.017</code> секунд. Быстро!</p>
<h1>Node.js</h1>
<p>Node — это не язык, но, в настоящее время, это доминирующая реализация
исполнения JavaScript на сервере.</p>
<p>Для того, чтобы сделать FFI в Node, нам сначала надо установить библиотеку:</p>
<pre><code class="language-bash">$ npm install ffi
</code></pre>
<p>После установки, мы можем ей воспользоваться:</p>
<pre><code class="language-javascript">var ffi = require('ffi');

var lib = ffi.Library('target/release/libembed', {
  'process': ['void', []]
});

lib.process();

console.log(&quot;сделано!&quot;);
</code></pre>
<p>Пример больше похож на Ruby, чем на Python. Мы используем модуль <code>ffi</code>, чтобы
получить доступ к <code>ffi.Library()</code>, который загружает нашу библиотеку. Нам нужно
указать тип возвращаемого значения и типы аргументов функции: <code>void</code> для
возвращаемого значения и пустой массив для указания отсутствия аргументов. После
этого мы просто вызываем функцию и печатаем результат.</p>
<p>На моей системе это заняло <code>0.092</code> секунды.</p>
<h1>Заключение</h1>
<p>Как вы можете видеть, основы, рассмотренные здесь, являются <em>очень</em> простыми.
Конечно, мы могли бы сделать куда больше того, что мы здесь показали. Посмотрите
главу <a href="ffi.html">FFI</a> для более подробной информации.</p>
<h1>Эффективное использование Rust</h1>
<p>Итак, вы узнали, как писать код на Rust. Но есть разница между написанием
<em>какого-то</em> кода на Rust и написанием <em>хорошего</em> кода на Rust.</p>
<p>Этот раздел состоит из относительно самостоятельных уроков, которые показывают,
как повысить уровень вашего кода на Rust. В нем представлены общие шаблоны и
стандартные функции библиотеки. Главы в этом разделе могут быть прочитаны в
любом порядке по вашему выбору.</p>
<h1>Стек и куча</h1>
<p>Как любой системный язык программирования, Rust работает на низком уровне. Если
вы пришли из языка высокого уровня, то вам могут быть незнакомы некоторые
аспекты системного программирования. Наиболее важными из них являются те,
которые касаются работы с памятью в стеке и в куче. Если вы уже знакомы с тем,
как в C-подобных языках используется выделение памяти в стеке, то эта глава
освежит ваши знания. Если же вы еще не знакомы с этим, то в общих чертах узнаете
об этом понятии, но с акцентом на Rust.</p>
<h1>Управление памятью</h1>
<p>Эти два термина касаются управления памятью. Стек и куча — это абстракции,
которые помогают вам определить, когда требуется выделение и освобождение
памяти.</p>
<p>Вот высокоуровневое сравнение.</p>
<p>Стек работает очень быстро; в Rust память
выделяется в стеке по умолчанию. Выделение памяти в стеке является локальным по
отношению к вызову функции, и имеет ограниченный размер. Куча, с другой стороны,
работает медленнее, а выделение памяти в куче осуществляется в программе
явно. Но такая память имеет теоретически неограниченный размер, и доступна
глобально.</p>
<h1>Стек</h1>
<p>Давайте поговорим о следующей программе на Rust:</p>
<pre><code class="language-rust">fn main() {
    let x = 42;
}
</code></pre>
<p>Эта программа имеет одно связанное имя, <code>x</code>. Память для него необходимо
где-то выделить. Rust по умолчанию «выделяет память в стеке», что означает, что
переменные «помещаются в стеке». Что это значит?</p>
<p>Когда функция вызывается, то выделяется некоторый объем памяти для всех её
локальных переменных и некоторой дополнительной информации. Это называется
«стековый кадр» (stack frame). В этом руководстве мы будем игнорировать эту
дополнительную информацию, и будем рассматривать лишь локальные переменные,
которые мы определяем. Таким образом, в этом случае, когда выполняется
<code>main()</code>, мы выделяем одно 32-битное целое число в нашем кадре стека. Как вы
можете видеть, это происходит автоматически — мы не должны писать какой-либо
специальный код на Rust для этого.</p>
<p>Когда функция завершается, её стековый кадр освобождается. Это происходит
автоматически — для этого нам не надо предпринимать никаких действий.</p>
<p>Вот и все, что касается этой простой программы. Главное, что здесь нужно
понять — это что выделение в стеке очень, очень быстро. Поскольку все локальные
переменные известны нам заранее, мы можем выделить память для них всех сразу. И
так как они, как правило, одновременно выходят из области видимости, мы можем
очень быстро освободить выделенную память.</p>
<p>Недостатком является то, что мы не можем хранить необходимые значения дольше,
чем в рамках одной функции.</p>
<p>А ещё мы не говорили о том, что же означает название «стек». Для этого мы должны
привести немного более сложный пример:</p>
<pre><code class="language-rust">fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<p>Эта программа имеет в общей сложности три переменные: две в <code>foo()</code> и одну в
<code>main()</code>. Так же как и раньше, когда вызывается <code>main()</code>, в её стековом кадре
выделяется одно целое число. Но, прежде чем мы сможем показать, что происходит,
когда вызывается <code>foo()</code>, мы должны визуализировать то, что происходит с
памятью. Ваша операционная система представляет отображение памяти для вашей
программы. Это довольно просто: огромный список адресов, от 0 до большого числа,
представляющего количество оперативной памяти у вашего компьютера. Например,
если у вас есть гигабайт оперативной памяти, то ваши адреса будут от <code>0</code> до
<code>1 073 741 823</code>. Это число равно 2<sup>30</sup>, количеству байтов в
гигабайте.</p>
<p>Эта память вроде гигантского массива: адреса начинаются с нуля и продолжаются до
конечного числа. Так вот схема нашего первого кадра стека:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 0     | x   | 42       |</p>
<p>У нас есть переменная <code>x</code>, расположенная по адресу <code>0</code>, имеющая значение <code>42</code>.</p>
<p>Когда вызывается <code>foo()</code>, выделяется новый стековый кадр:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 2     | z   | 100      |
| 1     | y   | 5        |
| 0     | x   | 42       |</p>
<p>Поскольку <code>0</code> было задействовано в первом кадре, для кадра <code>foo()</code> используются
<code>1</code> и <code>2</code>. При дальнейших вызовах функций стек будет расти вверх.</p>
<p>Здесь необходимо принять к сведению некоторые важные замечания. Адреса 0, 1 и 2
приведены исключительно в иллюстративных целях, и не имеют никакого отношения к
фактическим адресам, которые компьютер будет использовать. В частности, набор
адресов в действительности включает выравнивающие разделители, состоящие из
некоторого числа байтов, которые отделяют каждый из адресов. Размер этого
разделителя может даже превышать размер хранящегося значения.</p>
<p>После того, как <code>foo()</code> завершается, её кадр будет освобожден:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 0     | x   | 42       |</p>
<p>А потом, после <code>main()</code>, даже это последнее значение уходит. Легко!</p>
<p>Это называется «стек» (по-русски, стопка), потому что он работает как стопка
тарелок: первая тарелка, которую вы положили, будет последней тарелкой,
которую вы возьмете обратно. По этой причине стек иногда называют очередью
«последним пришел, первым вышел». Последнее значение, которое вы положили в
стек, будет первым, которое вы получите из него.</p>
<p>Давайте попробуем трёх-уровневый пример:</p>
<pre><code class="language-rust">fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<p>Сначала вызывается <code>main()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 0     | x   | 42       |</p>
<p>Затем из <code>main()</code> вызывается <code>foo()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 3     | c   | 1        |
| 2     | b   | 100      |
| 1     | a   | 5        |
| 0     | x   | 42       |</p>
<p>И затем из <code>foo()</code> вызывается <code>bar()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 4     | i   | 6        |
| 3     | c   | 1        |
| 2     | b   | 100      |
| 1     | a   | 5        |
| 0     | x   | 42       |</p>
<p>Вот что мы имели ввиду раньше, говоря, что наш стек растет вверх.</p>
<p>После того, как <code>bar()</code> завершается, её кадр будет освобожден, оставляя только
<code>foo()</code> и <code>main()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 3     | c   | 1        |
| 2     | b   | 100      |
| 1     | a   | 5        |
| 0     | x   | 42       |</p>
<p>А затем завершается <code>foo()</code>, оставляя только <code>main()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 0     | x   | 42       |</p>
<p>И вот мы закончили. Уловили суть? Это как стопка тарелок: вы кладете наверх, и
берёте сверху.</p>
<h1>Куча</h1>
<p>Такой способ выделения памяти работает очень хорошо, но он может быть
использован не всегда. Иногда вам необходимо передать некоторую память между
различными функциями или сохранить её валидность после окончания выполнения
функции. Для этого мы можем использовать кучу.</p>
<p>В Rust, вы можете выделить память в куче с помощью упаковки, т.е.
[типа <code>Box&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/boxed/index.html">box</a>. (Примечание переводчика: мы называем <code>Box&lt;T&gt;</code> упаковкой,
потому что <code>T</code> как бы «упакован» в <code>Box</code>: упаковка знает размер того, что лежит
внутри. Эта информация закодирована в типе <code>T</code>, поэтому во время исполнения, для
размерных типов, это просто указатель.) Вот пример:</p>
<pre><code class="language-rust">fn main() {
    let x = Box::new(5);
    let y = 42;
}
</code></pre>
<p>Вот что происходит с памятью, когда вызывается <code>main()</code>:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 1     | y   | 42       |
| 0     | x   | ??????   |</p>
<p>Мы выделяем место для двух переменных в стеке. <code>y</code> представляет собой <code>42</code>,
тут всё как обычно. Но что насчёт <code>x</code>? Наш <code>x</code> представляет собой <code>Box&lt;i32&gt;</code>,
а упаковка выделяет память в куче. Фактическое значение упаковки — структура,
которая хранит указатель на «кучу». Когда начинает выполняться функция,
осуществляется вызов <code>Box::new()</code>, который выделяет некоторый объем памяти в
куче, и кладет туда <code>5</code>. Теперь память выглядит следующим образом:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 5                      |
| ...                  | ... | ...                    |
| 1                    | y   | 42                     |
| 0                    | x   | → (2<sup>30</sup>) - 1 |</p>
<p>В нашем гипотетическом компьютере c 1Гб оперативной памяти имеется
2<sup>30</sup> адресов. А так как наш стек растет от нуля, то проще всего
выделить память с другого конца. Таким образом, наше первое значение находится
на самом высоком месте в памяти. Поскольку структура <code>x</code> хранит <a href="raw-pointers.html">сырой
указатель (raw pointer)</a> на адрес, который мы выделили в куче, то
значение <code>x</code> равно (2<sup>30</sup>) - 1 — это то самое местоположение в памяти.</p>
<p>Мы не слишком много говорили о том, что на самом деле означает «выделить» и
«освободить память» в этом контексте. Чрезмерное углубление в детали по этому
вопросу выходит за рамки данного руководства, но важно отметить, что куча — это
не просто стек, который растет с противоположного конца. Как мы увидим в
дальнейших примерах в этой книге, память из кучи может быть выделена и
освобождена в любом порядке, что в конечном итоге может привести к «дыркам». Вот
схема размещения памяти программы, проработавшей в течение некоторого времени:</p>
<p>| Адрес                | Имя  | Значение               |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 5                      |
| (2<sup>30</sup>) - 2 |      |                        |
| (2<sup>30</sup>) - 3 |      |                        |
| (2<sup>30</sup>) - 4 |      | 42                     |
| ...                  | ...  | ...                    |
| 3                    | y    | → (2<sup>30</sup>) - 4 |
| 2                    | y    | 42                     |
| 1                    | y    | 42                     |
| 0                    | x    | → (2<sup>30</sup>) - 1 |</p>
<p>В этом примере мы выделили четыре элемента в куче, но освободили лишь два из
них. Отсюда разрыв между (2<sup>30</sup>) - 1 и (2<sup>30</sup>) - 4, который в
настоящее время не используется. Конкретные детали того, как и почему это
происходит, зависят от того, какую стратегию вы используете для управления
кучей. Различные программы могут использовать различные «распределители памяти»,
которые представляют собой библиотеки, которые управляют памятью за вас.
Программы на Rust используют для этого <a href="http://www.canonware.com/jemalloc/">jemalloc</a>.</p>
<p>Ладно, вернемся к нашему примеру. Так как эта память расположена в куче, то она
может оставаться валидной дольше, чем функция, которая выделяет упаковку. В
данном случае, однако, это не так.[^moving] Когда функция завершается, мы должны
освободить кадр стека для <code>main()</code>. Хотя у <code>Box&lt;T&gt;</code> для этого есть свой трюк:
<a href="drop.html">Drop</a>. Реализация <code>Drop</code> для <code>Box</code> освобождает память, которая была
выделена при создании. Отлично! Поэтому, когда <code>x</code> уходит, сначала освобождается
память, выделенная в куче:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 1     | y   | 42       |
| 0     | x   | ??????   |</p>
<p>[moving]: Мы можем продлить время жизни памяти путем передачи права
собственности, что иногда называют «перемещение из упаковки» («moving
out of the box»). Более сложные примеры будут рассмотрены позже.</p>
<p>А потом кадр стека уходит, освобождая всю нашу память.</p>
<h1>Аргументы и заимствование</h1>
<p>У нас есть некоторые простые примеры со стеком и кучей, но что насчёт аргументов
функции и заимствования? Вот небольшая программа на Rust:</p>
<pre><code class="language-rust">fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</code></pre>
<p>Когда мы входим в <code>main()</code>, память выглядит следующим образом:</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 1     | y   | → 0      |
| 0     | x   | 5        |</p>
<p>Значением <code>x</code> является <code>5</code>, а <code>y</code> представляет собой ссылку на <code>x</code>. То есть, ее
значением является адрес памяти, по которому расположен <code>x</code>. В данном случае это
<code>0</code>.</p>
<p>А что насчёт случая, когда мы вызываем <code>foo()</code>, передавая <code>y</code> в качестве
аргумента?</p>
<p>| Адрес | Имя | Значение |
|-------|-----|----------|
| 3     | z   | 42       |
| 2     | i   | → 0      |
| 1     | y   | → 0      |
| 0     | x   | 5        |</p>
<p>Кадры стека используются не только для локальных имён, но также и для
аргументов. Таким образом, в этом случае, наш кадр должен содержать как <code>i</code>, наш
аргумент, так и <code>z</code>, наше локальное имя. <code>i</code> — это копия аргумента <code>y</code>.
Соответственно, значением <code>i</code>, как и значением <code>y</code>, является <code>0</code>.</p>
<p>Это одна из причин, почему заимствование переменной не освобождает какую-либо
память: значением ссылки является просто указатель на область памяти. Если мы
освободим находящуюся по этому указателю память, то это может привести к ошибкам
в дальнейшей работе.</p>
<h1>Сложный пример</h1>
<p>Хорошо, давайте рассмотрим следующую, более сложную программу шаг за шагом:</p>
<pre><code class="language-rust">fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</code></pre>
<p>Сначала мы вызываем <code>main()</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Мы выделяем память для <code>j</code>, <code>i</code>, и <code>h</code>. <code>i</code> выделена в куче и поэтому содержит
указатель на значение в куче.</p>
<p>Далее, в конце вызова <code>main()</code>, вызывается <code>foo()</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Пространство выделяется для <code>x</code>, <code>y</code> и <code>z</code>. Аргумент <code>x</code> имеет такое же
значение, как и <code>j</code>, так как мы передали <code>j</code> в качестве аргумента. Это указатель
на адрес <code>0</code>, так как <code>j</code> указывает на <code>h</code>.</p>
<p>Далее, <code>foo()</code> вызывает <code>baz()</code>, передавая <code>z</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 7                    | g   | 100                    |
| 6                    | f   | → 4                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Мы выделили память для <code>f</code> и <code>g</code>. <code>baz()</code> очень короткая, и когда она
завершается, мы избавляемся от её кадра стека:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Далее <code>foo()</code> вызывает <code>bar()</code> с аргументами <code>x</code> и <code>z</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| (2<sup>30</sup>) - 2 |     | 5                      |
| ...                  | ... | ...                    |
| 10                   | e   | → 9                    |
| 9                    | d   | → (2<sup>30</sup>) - 2 |
| 8                    | c   | 5                      |
| 7                    | b   | → 4                    |
| 6                    | a   | → 0                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Тут мы выделяем другое значение в куче, и поэтому мы вычитаем единицу из
(2<sup>30</sup>) - 1. Это выражение написать легче, чем <code>1 073 741 822</code>.
В любом случае, переменные создаются, как обычно.</p>
<p>В конце <code>bar()</code> вызывает <code>baz()</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| (2<sup>30</sup>) - 2 |     | 5                      |
| ...                  | ... | ...                    |
| 12                   | g   | 100                    |
| 11                   | f   | → 9                    |
| 10                   | e   | → 9                    |
| 9                    | d   | → (2<sup>30</sup>) - 2 |
| 8                    | c   | 5                      |
| 7                    | b   | → 4                    |
| 6                    | a   | → 0                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Сейчас мы на наибольшей глубине! Поздравляем с достижением данной точки.</p>
<p>После завершения <code>baz()</code>, мы избавляемся от <code>f</code> и <code>g</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| (2<sup>30</sup>) - 2 |     | 5                      |
| ...                  | ... | ...                    |
| 10                   | e   | → 9                    |
| 9                    | d   | → (2<sup>30</sup>) - 2 |
| 8                    | c   | 5                      |
| 7                    | b   | → 4                    |
| 6                    | a   | → 0                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>Далее мы выполняем возврат из <code>bar()</code>. В этом случае <code>d</code> представляет собой
<code>Box&lt;T&gt;</code>, поэтому он также освобождает и то, на что он указывает:
(2<sup>30</sup>) - 2.</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 5                    | z   | → 4                    |
| 4                    | y   | 10                     |
| 3                    | x   | → 0                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>И после этого происходит возврат из <code>foo()</code>:</p>
<p>| Адрес                | Имя | Значение               |
|----------------------|-----|------------------------|
| (2<sup>30</sup>) - 1 |     | 20                     |
| ...                  | ... | ...                    |
| 2                    | j   | → 0                    |
| 1                    | i   | → (2<sup>30</sup>) - 1 |
| 0                    | h   | 3                      |</p>
<p>И вот, наконец, <code>main()</code>, которая очищает все остальное. Когда освобождается <code>i</code>
(<code>Drop</code>), будет также очищен и конец кучи.</p>
<h1>А что делают другие языки?</h1>
<p>Большинство языков со сборщиком мусора по умолчанию выделяет память из кучи. Это
означает, что каждое значение будет упаковано. Есть ряд причин, почему делается
именно так, но они выходят за рамки данного руководства. Есть несколько
возможных оптимизаций, которые, правда, не достигают своей цели во всех случаях.
Вместо того чтобы полагаться на стек и <code>Drop</code> в вопросах очистки памяти, сборщик
мусора работает с кучей.</p>
<h1>Что использовать?</h1>
<p>Но, если стек быстрее и проще в управлении, зачем тогда нужна куча? Весомая
причина заключается в том, что память в стеке может выделяться только по
принципу «первым пришёл — последним вышел». Таким образом, место из-под кадра
стека предыдущего вызова функции будет переиспользовано под следующий вызов.
Выделение в куче — более общая техника. Она позволяет выделение и освобождение
памяти в любом порядке. Однако, это достигается ценой увеличения сложности
реализации механизма выделения памяти.</p>
<p>В общем случае, следует предпочитать выделение в стеке, и поэтому, Rust
использует выделение в стеке по умолчанию. LIFO модель стека («последним
пришёл — первым вышел») фундаментально проще. Это значит, что программа быстрее
исполняется, и проще по смыслу.</p>
<h2>Эффективность во время выполнения</h2>
<p>Управление памятью для стека тривиально: машина просто увеличивает или
уменьшает одно значение, так называемый «указатель стека» (stack pointer).
Управление памятью для кучи сложнее: память, выделенная в куче, освобождается в
произвольные моменты, а каждая область выделенной в куче памяти может быть
произвольного размера. Распределителю памяти, как правило, требуется приложить
гораздо больше усилий для определения областей, которые можно использовать
заново.</p>
<p>Если вы хотите изучить эту тему более подробно, то <a href="http://www.cs.northwestern.edu/%7Epdinda/icsclass/doc/dsa.pdf">эта статья</a> будет
отличным введением.</p>
<h2>Простота программы</h2>
<p>Выделение памяти в стеке воздействует как на сам язык Rust, так и на модель
мышления разработчиков. Стековая семантика — ключевое понятие Rust. Мы получаем
автоматическое управление памятью без усложнения среды исполнения. Именно этот
механизм позволяет освободить память в куче, как только её владелец вышел из
области видимости — по сути, как только схлопнулся стек кадра, на котором он
жил. К сожалению, в некоторых ситуациях стека недостаточно. Если нужна большая
гибкость во владении памятью, можно воспользоваться счётчиками ссылок <code>Rc&lt;T&gt;</code> и
<code>Arc&lt;T&gt;</code>.</p>
<p>Желание более удобно пользоваться памятью в куче может доходить до крайности. С
одной стороны, можно реализовать сборщик мусора — но это сильно увеличивает
сложность среды исполнения. С другой стороны, полностью ручное управление
памятью с явным вызовом процедуры освобождения часто приводит к ошибкам,
предотвратить которые компилятор Rust не в силах.</p>
<h1>Тестирование</h1>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<blockquote>
<p>Тестирование программы может быть очень эффективным способом показать наличие
ошибок, но оно безнадёжно неподходяще для доказательства их отсутствия.</p>
<p>Дейкстра, Эдсгер Вибе, «The Humble Programmer» (1972)</p>
</blockquote>
<p>Давайте поговорим о том, как тестировать код на Rust. Мы не будем рассказывать о
том, какой подход к тестированию Rust кода является верным. Есть много подходов,
каждый из которых имеет свое представление о правильном написании тестов. Но все
эти подходы используют одни и те же основные инструменты, и мы покажем вам
синтаксис их использования.</p>
<h1>Тесты с атрибутом <code>test</code></h1>
<p>В самом простом случае, тест в Rust — это функция, аннотированная атрибутом
<code>test</code>. Давайте создадим новый проект Cargo, который будет называться <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>При создании нового проекта, Cargo автоматически сгенерирует простой тест. Ниже
представлено содержимое <code>src/lib.rs</code>:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
}
</code></pre>
<p>Обратите внимание на <code>#[test]</code>. Этот атрибут указывает, что это тестовая
функция. В этом примере она не имеет тела. Но такого вида функции достаточно,
чтобы удачно выполнить тест. Запуск тестов осуществляется командой <code>cargo test</code>.</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Cargo скомпилировал и запустил наши тесты. В результате мы получили выходные
данные, поделенные на два раздела: один содержит информацию о тесте, который мы
написали, а другой — информацию о тестах из документации. Но об этом позже. А
сейчас посмотрим на эту строку:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Обратите внимание на <code>it_works</code>. Это название нашей функции:</p>
<pre><code class="language-rust">fn it_works() {
# }
</code></pre>
<p>Мы также получили итоговую строку:</p>
<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Так почему же наш ничего не делающий тест был выполнен удачно? Любой тест,
который не вызывает <code>panic!</code>, выполняется удачно, а любой тест, который вызывает
<code>panic!</code>, выполняется неудачно. Давайте сделаем тест, который выполнится
неудачно:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
    assert!(false);
}
</code></pre>
<p><code>assert!</code> — это макрос, определенный в Rust, и принимающий один аргумент: если
аргумент имеет значение <code>true</code>, то ничего не происходит; если аргумент является
<code>false</code>, то вызывается <code>panic!</code>. Давайте запустим наши тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust сообщает, что наш тест выполнен неудачно:</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Это же отражается в итоговой строке:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Мы также получаем ненулевой код состояния:</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>Это бывает полезно, если вы хотите интегрировать <code>cargo test</code> в сторонний
инструмент.</p>
<p>Мы можем инвертировать ожидаемый результат теста с помощью атрибута:
<code>should_panic</code>:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
</code></pre>
<p>Теперь этот тест будет выполнен удачно, если вызывается <code>panic!</code>, и неудачно,
если <code>panic!</code> не вызывается. Давайте попробуем:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust предоставляет и другой макрос, <code>assert_eq!</code>, который проверяет равенство
двух аргументов:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>А теперь этот тест будет выполнен удачно или неудачно? Из-за атрибута
<code>should_panic</code> он завершится удачно:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Тесты <code>should_panic</code> могут быть хрупкими, поскольку трудно гарантировать, что
тест не вызовет панику по неожиданной причине. Чтобы помочь в этом аспекте, к
атрибуту <code>should_panic</code> может быть добавлен необязательный параметр <code>expected</code>.
Тогда тест также будет проверять, что сообщение об ошибке содержит ожидаемый
текст. Ниже представлен более безопасный вариант приведенного выше примера:</p>
<pre><code class="language-rust">#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>Вот и все, что касается основ! Давайте напишем один «настоящий» тест:</p>
<pre><code class="language-rust,ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>Это распространенное использование макроса <code>assert_eq!</code>: вызывать некоторую
функцию с известными аргументами и сравнить результат её вызова с ожидаемым
результатом.</p>
<h1>Тесты в модуле <code>test</code></h1>
<p>Есть один нюанс, из-за которого наш пример нельзя назвать идиоматичным:
отсутствует модуль тестирования. Идиоматичный вариант нашего примера будет
выглядеть примерно так:</p>
<pre><code class="language-rust,ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Здесь есть несколько изменений. Первое — это введение <code>mod test</code> с атрибутом
<code>cfg</code>. Модуль позволяет сгруппировать все наши тесты вместе, а также, если
нужно, определить вспомогательные функции, которые будут отделены от остальной
части контейнера. Атрибут <code>cfg</code> указывает на то, что тест будет скомпилирован,
только когда мы попытаемся запустить тесты. Это может сэкономить время
компиляции, а также гарантирует, что наши тесты полностью исключены из обычной
сборки.</p>
<p>Второе изменение заключается в объявлении <code>use</code>. Так как мы находимся во
внутреннем модуле, то мы должны объявить использование тестируемой функции в его
области видимости. Это может раздражать, если у вас большой модуль, и поэтому
обычно используют возможность <code>glob</code>. Давайте изменим <code>src/lib.rs</code>
соответствующим образом:</p>
<pre><code class="language-rust,ignore">
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на различие в строке с <code>use</code>. Теперь запустим наши тесты:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Работает!</p>
<p>Данный подход представляет собой использование модуля <code>test</code>, содержащего
модульные тесты (unit tests). Любой код, задачей которого является только лишь
тестирование небольшого кусочка функциональности, имеет смысл перенести в этот
модуль. Но что если мы хотим написать «интеграционные тесты» (integration
tests)? Для этого следует использовать директорию <code>tests</code>.</p>
<h1>Тесты в директории <code>tests</code></h1>
<p>Чтобы написать интеграционный тест, давайте создадим директорию <code>tests</code>, и
положим в нее файл <code>tests/lib.rs</code> со следующим содержимым:</p>
<pre><code class="language-rust,ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Выглядит примерно так же, как и наши предыдущие тесты, но есть некоторые
отличия. Теперь сверху у нас <code>extern crate adder</code>. Это потому, что тесты в
директории <code>tests</code> — это отдельный контейнер, и, следовательно, мы должны
компоноваться с нашей библиотекой. Это также объясняет, почему директория
<code>tests</code> — наиболее подходящее место для написания интеграционных тестов: они
используют библиотеку, как это делал бы любой другой потребитель.</p>
<p>Давайте запустим их:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас появилось три раздела: запускается старый модульный тест, а также
новый интеграционный тест.</p>
<p>Это все, что касается директории <code>tests</code>. Модуль <code>test</code> здесь не нужен, так как
здесь всё относится к тестам.</p>
<p>Давайте, наконец, перейдем к третьей части: тесты в документации.</p>
<h1>Тесты в документации</h1>
<p>Нет ничего лучше, чем документация с примерами. Нет ничего хуже, чем примеры,
которые на самом деле не работают, потому что код изменился с тех пор, как была
написана документация. Для того, чтобы такой ситуации не возникало, Rust
поддерживает автоматический запуск примеров в документации. Вот дополненный
<code>src/lib.rs</code> с примерами:</p>
<pre><code class="language-rust,ignore">//! Контейнер `adder` предоставляет функции сложения чисел.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// Эта функция прибавляет 2 к своему аргументу.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на документацию уровня модуля, начинающуюся с <code>//!</code> и на
документацию уровня функции, начинающуюся с <code>///</code>. Документация Rust
поддерживает Markdown в комментариях, поэтому блоки кода помечают тройными
символами `. В комментарии документации обычно включают раздел <code># Examples</code>,
содержащий примеры, такие как этот. (Примечание переводчика: заголовок <code># Examples</code> имеет особое значение: его нельзя написать по-другому или написать на
русском языке, иначе Rust не найдёт примеров кода в документации.)</p>
<p>Давайте запустим тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас запускаются все три вида тестов! Обратите внимание на имена тестов
из документации: <code>_0</code> генерируется для модульных тестов, и <code>add_two_0</code> — для
функциональных тестов. Цифры на конце будут увеличиваться автоматически, если вы
добавите еще примеров. Например, при добавлении ещё одного функционального
теста, он получит имя <code>add_two_1</code>.</p>
<h1>Условная компиляция</h1>
<p>В Rust есть специальный атрибут, <code>#[cfg]</code>, который позволяет компилировать код в
зависимости от флагов, переданных компилятору. Он имеет две формы:</p>
<pre><code class="language-rust">#[cfg(foo)]
# fn foo() {}

#[cfg(bar = &quot;baz&quot;)]
# fn bar() {}
</code></pre>
<p>Над атрибутами конфигурации определены логические операции:</p>
<pre><code class="language-rust">#[cfg(any(unix, windows))]
# fn foo() {}

#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
# fn bar() {}

#[cfg(not(foo))]
# fn not_foo() {}
</code></pre>
<p>Они могут быть как угодно вложены:</p>
<pre><code class="language-rust">#[cfg(any(not(unix), all(target_os=&quot;macos&quot;, target_arch = &quot;powerpc&quot;)))]
# fn foo() {}
</code></pre>
<p>Что же касается того, как включить или отключить эти флаги: если вы используете
Cargo, то они устанавливаются в [разделе <code>[features]</code>]<a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section">features</a> вашего
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
# по умолчанию, никаких дополнительных возможностей
default = []

# возможность «secure-password» зависит от пакета bcrypt
secure-password = [&quot;bcrypt&quot;]
</code></pre>
<p>Если вы определите такие возможности, Cargo передаст флаг в <code>rustc</code>:</p>
<pre><code class="language-text">--cfg feature=&quot;${feature_name}&quot;
</code></pre>
<p>Совокупность этих флагов конфигурации (<code>cfg</code>) будет определять, какие из них
будут активны, и, следовательно, какой код будет скомпилирован. Давайте
рассмотрим такой код:</p>
<pre><code class="language-rust">#[cfg(feature = &quot;foo&quot;)]
mod foo {
}
</code></pre>
<p>Если скомпилировать его с помощью <code>cargo build --features &quot;foo&quot;</code>, то в <code>rustc</code>
будет передан флаг <code>--cfg feature=&quot;foo&quot;</code>, и результат будет содержать
модуль <code>mod foo</code>. Если скомпилировать его с помощью обычной команды <code>cargo build</code>, то никаких дополнительных флагов передано не будет, и поэтому, модуль
<code>mod foo</code> будет отсутствовать.</p>
<h1>cfg_attr</h1>
<p>Вы также можете установить другой атрибут в зависимости от переменной <code>cfg</code> с
помощью атрибута <code>cfg_attr</code>:</p>
<pre><code class="language-rust">#[cfg_attr(a, b)]
# fn foo() {}
</code></pre>
<p>Этот код будет равносилен атрибуту <code>#[b]</code>, если в атрибуте <code>cfg</code> установлен флаг
<code>a</code>, или «без атрибута» в противном случае.</p>
<h1>cfg!</h1>
<p><a href="compiler-plugins.html">Расширение синтаксиса</a> <code>cfg!</code> позволяет использовать данные
виды флагов и в другом месте в коде:</p>
<pre><code class="language-rust">if cfg!(target_os = &quot;macos&quot;) || cfg!(target_os = &quot;ios&quot;) {
    println!(&quot;Think Different!&quot;);
}
</code></pre>
<p>Значение флага будет заменено на <code>true</code> или <code>false</code> во время компиляции, в
зависимости от настройки конфигурации.</p>
<h1>Документация</h1>
<p>Документация является важной частью любого программного проекта, и в Rust ей
уделяется не меньше внимания, чем самому коду. Давайте поговорим об инструментах
Rust, предназначенных для создания документации к проекту.</p>
<h2>О <code>rustdoc</code></h2>
<p>Дистрибутив Rust включает в себя инструмент, <code>rustdoc</code>, который генерирует
документацию. <code>rustdoc</code> также используется Cargo через <code>cargo doc</code>.</p>
<p>Документация может быть сгенерирована двумя методами: из исходного кода, и из
отдельных файлов в формате Markdown.</p>
<h2>Документирование исходного кода</h2>
<p>Основной способ документирования проекта на Rust заключается в комментировании
исходного кода. Для этой цели вы можете использовать документирующие
комментарии:</p>
<pre><code class="language-rust,ignore">/// Создаёт новый `Rc&lt;T&gt;`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -&gt; Rc&lt;T&gt; {
    // здесь реализация
}
</code></pre>
<p>Этот код генерирует документацию, которая выглядит <a href="http://doc.rust-lang.org/std/rc/struct.Rc.html#method.new">так</a>. В приведенном
коде реализация метода была заменена на обычный комментарий. Первое, на что
следует обратить внимание в этом примере, это на использование <code>///</code> вместо
<code>//</code>. Символы <code>///</code> указывают, что это документирующий комментарий.</p>
<p>Документирующие комментарии пишутся на Markdown.</p>
<p>Rust отслеживает такие комментарии, и использует их при создании документации.</p>
<p>При документировании таких вещей, как перечисления, нужно учитывать некоторые
особенности работы <code>rustdoc</code>. Такой код работает:</p>
<pre><code class="language-rust">/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang.org/).
enum Option&lt;T&gt; {
    /// Нет значения
    None,
    /// Некоторое значение `T`
    Some(T),
}
</code></pre>
<p>А такой — нет:</p>
<pre><code class="language-rust,ignore">/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang.org/).
enum Option&lt;T&gt; {
    None, /// Нет значения
    Some(T), /// Некоторое значение `T`
}
</code></pre>
<p>Вы получите ошибку:</p>
<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>
<p>Эта досадная <a href="https://github.com/rust-lang/rust/issues/22547">ошибка</a>
заключается в следующем: комментарии документации распространяются на элементы,
расположенные за ними, а в данном примере нет элемента, расположенного после
последнего комментария.</p>
<h3>Написание комментариев документации</h3>
<p>Давайте рассмотрим каждую часть приведенного комментария в деталях:</p>
<pre><code class="language-rust">/// Создаёт новый `Rc&lt;T&gt;`.
# fn foo() {}
</code></pre>
<p>Первая строка документирующего комментария должна представлять из себя краткую
информацию о функциональности. Одно предложение. Только самое основное.
Высокоуровневое.</p>
<pre><code class="language-rust">///
/// Подробности создания `Rc&lt;T&gt;`, возможно, описывающие сложности семантики,
/// дополнительные опции, и всё остальное.
///
# fn foo() {}
</code></pre>
<p>Наш исходный пример включал только строку с краткой информацией, но если бы у
нас было больше информации, о которой следует сказать, мы могли бы добавить эту
информацию в новом параграфе.</p>
<h4>Специальные разделы</h4>
<pre><code class="language-rust">/// # Examples
# fn foo() {}
</code></pre>
<p>Далее идут специальные разделы. Они обознаются заголовком, который начинается с
<code>#</code>. Существуют три вида заголовков, которые обычно используются. Они не
являются каким-либо специальным синтаксисом, на данный момент это просто
соглашение.</p>
<pre><code class="language-rust">/// # Panics
# fn foo() {}
</code></pre>
<p>Раздел <code>Panics</code>. Неустранимые ошибки при неправильном вызове функции (так
называемые ошибки программирования) в Rust, как правило, вызывают панику,
которая, в крайнем случае, убивает весь текущий поток (thread). Если ваша
функция имеет подобное нетривиальное поведение — т.е. обнаруживает/вызывает
панику, то очень важно задокументировать это.</p>
<pre><code class="language-rust">/// # Failures
# fn foo() {}
</code></pre>
<p>Раздел <code>Failures</code>. Если ваша функция или метод возвращает <code>Result&lt;T, E&gt;</code>, то
хорошим тоном является описание условий, при которых она возвращает <code>Err(E)</code>.
Это чуть менее важно, чем описание <code>Panics</code>, потому как неудача кодируется в
системе типов, но это не значит, что стоит пренебрегать данной возможностью.</p>
<pre><code class="language-rust">/// # Safety
# fn foo() {}
</code></pre>
<p>Раздел <code>Safety</code>. Если ваша функция является <code>unsafe</code>, необходимо пояснить, какие
инварианты вызова должны поддерживаться.</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>Раздел <code>Examples</code>. Включите в этот раздел один или несколько примеров
использования функции или метода, и ваши пользователи будут вам благодарны.
Примеры должны размещаться внутри блоков кода, о которых мы сейчас поговорим.
Этот раздел может иметь более одного подраздела:</p>
<pre><code class="language-rust">/// # Examples
///
/// Простые образцы типа `&amp;str`:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;И была у них курочка Ряба&quot;.split(' ').collect();
/// assert_eq!(v, vec![&quot;И&quot;, &quot;была&quot;, &quot;у&quot;, &quot;них&quot;, &quot;курочка&quot;, &quot;Ряба&quot;]);
/// ```
///
/// Более сложные образцы с замыканиями:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;абв1где2жзи&quot;.split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec![&quot;абв&quot;, &quot;где&quot;, &quot;жзи&quot;]);
/// ```
# fn foo() {}
</code></pre>
<p>Давайте подробно обсудим блоки кода.</p>
<h4>Блок кода</h4>
<p>Чтобы написать код на Rust в комментарии, используйте символы ```:</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Привет, мир&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Если вы хотите написать код на любом другом языке (не на Rust), вы можете
добавить аннотацию:</p>
<pre><code class="language-rust">/// ```c
/// printf(&quot;Hello, world\n&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Это позволит использовать подсветку синтаксиса, соответствующую тому языку,
который был указан в аннотации. Если же это простой текст, то в аннотации
указывается <code>text</code>.</p>
<p>Важно выбрать правильную аннотацию, потому что <code>rustdoc</code> использует ее
интересным способом: Rust может выполнять проверку работоспособности примеров на
момент создания документации. Это позволяет избежать устаревания примеров.
Предположим, у вас есть код на C. Если вы опустите аннотацию, указывающую, что
это код на C, то <code>rustdoc</code> будет думать, что это код на Rust, поэтому он
пожалуется при попытке создания документации.</p>
<h2>Тесты в документации</h2>
<p>Давайте обсудим наш пример документации:</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Привет, мир&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Заметьте, что здесь нет нужды в <code>fn main()</code> или чём-нибудь подобном. <code>rustdoc</code>
автоматически добавит оборачивающий <code>main()</code> вокруг вашего кода в нужном месте.
Например:</p>
<pre><code class="language-rust">/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>В конечном итоге это будет тест:</p>
<pre><code class="language-rust">fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
</code></pre>
<p>Вот полный алгоритм, который <code>rustdoc</code> использует для обработки примеров:</p>
<ol>
<li>Любые ведущие (leading) атрибуты <code>#![foo]</code> остаются без изменений в качестве
атрибутов контейнера.</li>
<li>Будут вставлены некоторые общие атрибуты <code>allow</code>, в том числе:
<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>,
<code>dead_code</code>. Небольшие примеры часто приводят к срабатыванию этих анализов.</li>
<li>Если пример не содержит <code>extern crate</code>, то будет вставлено <code>extern crate &lt;mycrate&gt;;</code>.</li>
<li>Наконец, если пример не содержит <code>fn main</code>, то оставшаяся часть текста будет
обернута в <code>fn main() { your_code }</code></li>
</ol>
<p>Хотя иногда этого не достаточно. Например, что насчёт всех этих примеров кода с
<code>///</code>, о которых мы говорили? Простой текст, обработанный <code>rustdoc</code>, выглядит
так:</p>
<pre><code class="language-text">/// Некоторая документация.
# fn foo() {}
</code></pre>
<p>А исходный текст на Rust после обработки выглядит так:</p>
<pre><code class="language-rust">/// Некоторая документация.
# fn foo() {}
</code></pre>
<p>Да, именно так: вы можете добавлять строки, которые начинаются с <code>#</code>, и они
будут скрыты в выводе, но при этом будут использоваться во время компиляции
кода. Вы можете использовать это в своих интересах. Если в документирующем
комментарии необходимо обратиться к какой-то функции, то ниже нужно будет
добавить определение этой функции. В то же время, это делается только для того,
чтобы удовлетворить компилятор, поэтому сокрытие ненужных строк в выводе делает
пример более ясным. Вы можете использовать эту технику, чтобы детально объяснять
длинные примеры, сохраняя при этом тестируемость документации. Например, вот
код:</p>
<pre><code class="language-rust">let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Ниже приведено отрисованное объяснение этого кода.</p>
<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
<pre><code class="language-rust">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Затем мы устанавливаем <code>y</code> равным шести:</p>
<pre><code class="language-rust"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
<pre><code class="language-rust"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
<p>А вот то же самое объяснение, но в виде простого текста:</p>
<blockquote>
<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
<pre><code class="language-text">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Затем мы устанавливаем <code>y</code> равным шести:</p>
<pre><code class="language-text"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
<pre><code class="language-text"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>
<p>Повторяя все части примера, вы можете быть уверены, что ваш пример
компилируется, а не просто отображает кусочки кода, которые как-то относятся к
той или иной части вашего объяснения.</p>
<h3>Документирование макросов</h3>
<p>Вот пример документирования макроса:</p>
<pre><code class="language-rust">/// Паниковать с данным сообщением, если только выражение не является истиной.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, &quot;Математика сломалась.&quot;);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, &quot;Я сломан.&quot;);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre>
<p>В нем вы можете заметить три вещи. Во-первых, мы должны собственноручно добавить
строку с <code>extern crate</code> для того, чтобы мы могли указать атрибут <code>#[macro_use]</code>.
Во-вторых, мы также собственноручно должны добавить <code>main()</code>. И наконец, разумно
будет использовать <code>#</code>, чтобы закомментировать все, что мы добавили в первых
двух пунктах, что бы оно не отображалось в генерируемом выводе.</p>
<h3>Запуск тестов в документации</h3>
<p>Для запуска тестов можно использовать одну из двух комманд</p>
<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
# или
$ cargo test
</code></pre>
<p>Все верно, <code>cargo test</code> также выполняет тесты, встроенные в документацию. Тем не
менее, <code>cargo test</code> не будет тестировать исполняемые контейнеры, только
библиотечные. Это связано с тем, как работает <code>rustdoc</code>: он компонуется с
библиотекой, которую надо протестировать, но в случае с исполняемым файлом
компоноваться не с чем.</p>
<p>Есть еще несколько полезных аннотаций, которые помогают <code>rustdoc</code> работать
правильно при тестировании кода:</p>
<pre><code class="language-rust">/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
</code></pre>
<p>Аннотация <code>ignore</code> указывает Rust, что код должен быть проигнорирован. Почти во
всех случаях это не то, что вам нужно, так как эта директива носит очень общий
характер. Вместо неё лучше использовать аннотацию <code>text</code>, если это не код, или
<code>#</code>, чтобы получить рабочий пример, отображающий только ту часть, которая вам
нужна.</p>
<pre><code class="language-rust">/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
</code></pre>
<p>Аннотация <code>should_panic</code> указывает <code>rustdoc</code>, что код должен компилироваться, но
выполнение теста должно завершиться ошибкой.</p>
<pre><code class="language-rust">/// ```no_run
/// loop {
///     println!(&quot;Привет, мир&quot;);
/// }
/// ```
# fn foo() {}
</code></pre>
<p>Аннотация <code>no_run</code> указывает, что код должен компилироваться, но запускать его
на выполнение не требуется. Это важно для таких примеров, которые должны успешно
компилироваться, но выполнение которых оказывается бесконечным циклом! Например:
«Вот как запустить сетевой сервис».</p>
<h3>Документирование модулей</h3>
<p>Rust предоставляет ещё один вид документирующих комментариев, <code>//!</code>. Этот
комментарий относится не к следующему за ним элементу, а к элементу, который его
включает. Другими словами:</p>
<pre><code class="language-rust">mod foo {
    //! Это документация для модуля `foo`.
    //!
    //! # Examples

    // ...
}
</code></pre>
<p>Приведённый пример демонстрирует наиболее распространённое использование <code>//!</code>:
документирование модуля. Если же модуль расположен в файле <code>foo.rs</code>, то вы,
открывая его код, часто будете видеть следующее:</p>
<pre><code class="language-rust">//! Модуль использования разных `foo`.
//!
//! Модуль `foo` содержит много полезной функциональности ла-ла-ла
</code></pre>
<h3>Стиль документирующих комментариев</h3>
<p>Изучите <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> для получения полных сведений о соглашениях по стилю и
формату документации.</p>
<h2>Другая документация</h2>
<p>Все эти правила поведения также применимы и в отношении исходных файлов не на
Rust. Так как комментарии пишутся на Markdown, то часто эти файлы имеют
расширение <code>.md</code>.</p>
<p>Когда вы пишете документацию в файлах Markdown, вам не нужно добавлять префикс
документирующего комментария, <code>///</code>. Например:</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>преобразуется в</p>
<pre><code class="language-markdown"># Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>
<p>когда он находится в файле Markdown. Однако есть один недостаток: файлы Markdown
должны иметь заголовок наподобие этого:</p>
<pre><code class="language-markdown">% Заголовок

Это пример документации.
</code></pre>
<p>Строка, начинающаяся с <code>%</code>, должна быть самой первой строкой файла.</p>
<h2>Атрибуты <code>doc</code></h2>
<p>На более глубоком уровне, комментарии документации — это синтаксический сахар
для атрибутов документации:</p>
<pre><code class="language-rust">/// this
# fn foo() {}

#[doc=&quot;this&quot;]
# fn bar() {}
</code></pre>
<p>Т.е. представленные выше комментарии идентичны, также как и ниже:</p>
<pre><code class="language-rust">//! this

#![doc=&quot;/// this&quot;]
</code></pre>
<p>Вы не часто будете видеть этот атрибут, используемый для написания документации,
но он может быть полезен для изменения некоторых настроек, или при написании
макроса.</p>
<h3>Ре-экспорт</h3>
<p><code>rustdoc</code> будет показывать документацию для общедоступного (public) ре-экспорта
в двух местах:</p>
<pre><code class="language-ignore">extern crate foo;

pub use foo::bar;
</code></pre>
<p>Это создаст документацию для <code>bar</code> как в документации для контейнера <code>foo</code>, так
и в документации к вашему контейнеру. То есть в обоих местах будет использована
одна и та же документация.</p>
<p>Такое поведение может быть подавлено с помощью <code>no_inline</code>:</p>
<pre><code class="language-ignore">extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
</code></pre>
<h3>Управление HTML</h3>
<p>Вы можете управлять некоторыми аспектами HTML, который генерирует <code>rustdoc</code>,
через атрибут <code>#![doc]</code>:</p>
<pre><code class="language-rust">#![doc(html_logo_url = &quot;http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
       html_favicon_url = &quot;http://www.rust-lang.org/favicon.ico&quot;,
       html_root_url = &quot;http://doc.rust-lang.org/&quot;)];
</code></pre>
<p>В этом примере устанавливается несколько различных опций: логотип, иконка и
корневой URL.</p>
<h2>Опции генерации</h2>
<p><code>rustdoc</code> также содержит несколько опций командной строки для дальнейшей
настройки:</p>
<ul>
<li><code>--html-in-header FILE</code>: включить содержимое FILE в конец раздела
<code>&lt;head&gt;...&lt;/head&gt;</code>.</li>
<li><code>--html-before-content FILE</code>: включить содержимое FILE сразу после <code>&lt;body&gt;</code>,
перед отображаемым содержимым (в том числе строки поиска).</li>
<li><code>--html-after-content FILE</code>: включить содержимое FILE после всего
отображаемого содержимого.</li>
</ul>
<h2>Замечание по безопасности</h2>
<p>Комментарии в документации в формате Markdown помещаются в конечную веб-страницу
без обработки. Будьте осторожны с HTML-литералами:</p>
<pre><code class="language-rust">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
# fn foo() {}
</code></pre>
<h1>Итераторы</h1>
<p>Давайте поговорим о циклах.</p>
<p>Помните цикл <code>for</code> в Rust? Вот пример:</p>
<pre><code class="language-rust">for x in 0..10 {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Теперь, когда вы знаете о Rust немного больше, мы можем детально обсудить, как
же это работает. Диапазоны (<code>0..10</code>) являются «итераторами». Итератор — это
сущность, для которой мы можем неоднократно вызвать метод <code>.next()</code>, в
результате чего мы получим последовательность элементов.</p>
<p>Как представлено ниже:</p>
<pre><code class="language-rust">let mut range = 0..10;

loop {
    match range.next() {
        Some(x) =&gt; {
            println!(&quot;{}&quot;, x);
        },
        None =&gt; { break }
    }
}
</code></pre>
<p>Мы связываем с диапазоном изменяемое имя, которая и является нашим итератором.
Затем мы используем цикл <code>loop</code> с внутренней конструкцией <code>match</code>. Здесь <code>match</code>
применяется к результату <code>range.next()</code>, который выдает нам ссылку на следующее
значение итератора. В данном случае <code>next</code> возвращает <code>Option&lt;i32&gt;</code>, который
представляет собой <code>Some(i32)</code> когда у нас есть значение и <code>None</code> когда перебор
элементов закончен. Если мы получаем <code>Some(i32)</code>, то печатаем его, а если
<code>None</code>, то прекращаем выполнение цикла оператором <code>break</code>.</p>
<p>Этот пример, по большому счету, делает то же самое, что и пример с циклом <code>for</code>.
Цикл <code>for</code> — просто удобный способ записи конструкции <code>loop</code>/<code>match</code>/<code>break</code>.</p>
<p>Однако, цикл <code>for</code> не является единственной конструкцией, которая использует
итераторы. Написание своего собственного итератора заключается в реализации
типажа <code>Iterator</code>. Хотя эта тема и выходит за рамки данного руководства, Rust
предоставляет ряд полезных итераторов для выполнения различных задач. Прежде чем
мы поговорим о них, мы должны рассказать о плохой практике в Rust, связанной с
использованием диапазонов. Она продемонстрирована в примере ниже.</p>
<p>Вот, только что мы говорили о том, какие диапазоны крутые. Но диапазоны также и
очень примитивны. Например, если вам нужно перебрать содержимое вектора, у вас
может возникнуть желание написать так:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!(&quot;{}&quot;, nums[i]);
}
</code></pre>
<p>Это намного хуже, чем если бы мы использовали итератор непосредственно. Вы
можете пройти по элементам векторов напрямую, как показано ниже:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, num);
}
</code></pre>
<p>Есть две причины предпочесть прямое использование итератора. Во-первых, это
яснее выражает наше намерение. Мы обходим элементы вектора, а не индексы с
последующей индексацией вектора. Во-вторых, эта версия является более
эффективной: первая версия будет выполнять дополнительные проверки границ,
потому что используется индексация, <code>nums[i]</code>. Во втором примере нет никаких
проверок границ, поскольку мы получаем ссылки на каждый элемент вектора, одну за
одной, по мере итерирования. Это очень распространенный прием работы с
итераторами: мы можем игнорировать ненужные проверки границ, но все еще быть
уверенными, что мы в безопасности.</p>
<p>Остается неясной еще одна деталь работы <code>println!</code>. На самом деле <code>num</code> имеет
тип <code>&amp;i32</code>. То есть, это ссылка на <code>i32</code>, а не сам <code>i32</code>. <code>println!</code> выполняет
разыменование переменной за нас, поэтому мы не видим его в исходном коде. Этот
код также прекрасно работает:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, *num);
}
</code></pre>
<p>Здесь мы явно разыменовываем <code>num</code>. Почему <code>&amp;nums</code> выдает нам ссылки? Во-первых,
потому что мы явно попросили его об этом с помощью <code>&amp;</code>. Во-вторых, если он будет
выдавать нам сами данные, то мы должны быть их владельцем, что подразумевает
создание копии данных и выдачу этой копии нам. Со ссылками же мы просто
заимствуем ссылку на данные, и поэтому будет выдана просто ссылка, без
необходимости перемещать данные.</p>
<p>Теперь, когда мы установили, что зачастую диапазоны — это не то, что нужно,
давайте поговорим о том, что же можно использовать вместо диапазонов.</p>
<p>Есть три основных класса объектов, которые имеют отношение к данному вопросу:
<em>итераторы</em>, <em>адаптеры итераторов</em> и <em>потребители</em>. Вот некоторые определения:</p>
<ul>
<li><em>итераторы</em> выдают последовательность значений;</li>
<li><em>адаптеры итераторов</em> применяются к итератору и выдают новый итератор с другой
выходной последовательностью;</li>
<li><em>потребители</em> применяются к итератору, выдающему некоторый конечный набор
значений.</li>
</ul>
<p>Давайте сначала поговорим о потребителях, так как итераторы вы уже видели — это
диапазоны.</p>
<h2>Потребители</h2>
<p><em>Потребитель</em> применяется к итератору, возвращая какое-то значение или значения.
Наиболее распространенным потребителем является <code>collect()</code>. Этот код не
компилируется, но он показывает идею:</p>
<pre><code class="language-rust,ignore">let one_to_one_hundred = (1..101).collect();
</code></pre>
<p>Как вы можете видеть, мы вызываем <code>collect()</code> для нашего итератора. <code>collect()</code>
принимает столько значений, сколько выдаст итератор, и возвращает коллекцию
результатов. Так почему же этот код не компилируется? Rust не может определить,
в какую коллекцию (например, вектор, список, и т.д.) вы хотите собрать элементы,
и поэтому тип необходимо указать явно. Вот версия, которая компилируется:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Если помните, синтаксис <code>::&lt;&gt;</code> позволяет задать подсказку типа. Поэтому в
приведенном примере мы указали, что хотим вектор целых чисел. Хотя не всегда
бывает нужно задавать весь тип целиком. Использование символа <code>_</code> позволит вам
задать частичную подсказку типа:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>Эта запись говорит компилятору Rust: «Пожалуйста, собери элементы в <code>Vec&lt;T&gt;</code>, а
вывод типа <code>T</code> сделай самостоятельно». По этой причине символ <code>_</code> иногда
называют «заполнителем типа».</p>
<p><code>collect()</code> является наиболее распространенным из потребителей, но есть и
другие. Например <code>find()</code>:</p>
<pre><code class="language-rust">let greater_than_forty_two = (0..100)
                             .find(|x| *x &gt; 42);

match greater_than_forty_two {
    Some(_) =&gt; println!(&quot;У нас есть несколько чисел!&quot;),
    None =&gt; println!(&quot;Числа не найдены :(&quot;),
}
</code></pre>
<p><code>find</code> принимает замыкание, которое обрабатывает ссылку на каждый элемент
итератора. Замыкание возвращает <code>true</code>, если элемент является искомым элементом,
и <code>false</code> в противном случае. Так как нам не всегда удается найти
соответствующий элемент, <code>find</code> возвращает <code>Option</code>, а не сам элемент.</p>
<p>Еще один важный потребитель — <code>fold</code>. Вот как он выглядит:</p>
<pre><code class="language-rust">let sum = (1..4).fold(0, |sum, x| sum + x);
</code></pre>
<p><code>fold()</code> — это потребитель, который схематично можно представить в виде:
<code>fold(base, |accumulator, element| ...)</code>. Он принимает два аргумента: первый -
это элемент, называемый <em>базой</em>; второй — это замыкание, которое, в свою очередь,
само принимает два аргумента: первый называется <em>аккумулятор</em>, а второй -
<em>элемент</em>. На каждой итерации вызывается замыкание, результат выполнения
которого становится значением аккумулятора на следующей итерации. На первой
итерации значение аккумулятора равно базе.</p>
<p>Это немного запутанно. Давайте рассмотрим значения всех элементов итератора:</p>
<p>| база | аккумулятор | элемент | результат замыкания |
|------|-------------|---------|---------------------|
| 0    | 0           | 1       | 1                   |
| 0    | 1           | 2       | 3                   |
| 0    | 3           | 3       | 6                   |</p>
<p>Мы вызвали <code>fold()</code> с этими аргументами:</p>
<pre><code class="language-rust"># (1..4)
.fold(0, |sum, x| sum + x);
</code></pre>
<p>Таким образом, <code>0</code> — это база, <code>sum</code> — это аккумулятор, а <code>x</code> — это элемент. На
первой итерации мы устанавливаем <code>sum</code> равной <code>0</code>, а <code>x</code> становится первым
элементом <code>nums</code>, <code>1</code>. Затем мы прибавляем <code>x</code> к <code>sum</code>, что дает нам <code>0 + 1 = 1</code>. На второй итерации это значение становится значением аккумулятора, <code>sum</code>, а
элемент становится вторым элементом массива, <code>2</code>. <code>1 + 2 = 3</code>, результат этого
выражения становится значением аккумулятора на последней итерации. На этой
итерации, <code>x</code> становится последним элементом, <code>3</code>, а значение выражения <code>3 + 3 = 6</code> является конечным значением нашей суммы. <code>1 + 2 + 3 = 6</code> — это результат,
который мы получили.</p>
<p>Вот так. <code>fold</code> может показаться немного странным, если вы используете его
впервые, но когда вы освоите его, то будете использовать его повсеместно. <code>fold</code>
подходит для случаев, когда у вас есть список элементов, а вам нужно получить
один единственный результат.</p>
<p>Потребители имеют очень большое значение в связи с одним свойством итераторов, о
котором мы еще не говорили: ленивость. Давайте ещё немного поговорим об
итераторах, и вы поймете, почему потребители так важны.</p>
<h2>Итераторы</h2>
<p>Как мы уже говорили ранее, итератор являются сущностью, для которой мы можем
неоднократно вызвать метод <code>.next()</code>, в результате чего мы получим
последовательность элементов. Для получения каждого следующего элемента нужно
вызвать метод, а это означает, что итераторы <em>ленивы</em> — они не обязаны
создавать все значения заранее. Например, этот код на самом деле не генерирует
номера <code>1-99</code>, а просто создает значение, представляющее эту последовательность:</p>
<pre><code class="language-rust">let nums = 1..100;
</code></pre>
<p>В этом примере мы никак не использовали диапазон, поэтому он и не создавал
последовательность. Давайте добавим потребителя:</p>
<pre><code class="language-rust">let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Теперь <code>collect()</code> потребует, чтобы диапазон выдавал ему какие-нибудь числа,
поэтому он сгенерирует последовательность.</p>
<p>Диапазоны — это один из двух основных типов итераторов. Другой часто
используемый итератор — <code>iter()</code>. <code>iter()</code> может преобразовать вектор в простой
итератор, который выдает вам каждый элемент по очереди:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!(&quot;{}&quot;, num);
}
</code></pre>
<p>Эти два основных итератора хорошо послужат вам. Есть и более продвинутые
итераторы, в том числе и те, которые генерируют бесконечную последовательность.</p>
<p>Вот и все, что касается итераторов. Последнее понятие в этой теме, о котором мы
хотели бы рассказать — адаптеры итераторов. Давайте перейдем к нему!</p>
<h2>Адаптеры итераторов</h2>
<p><em>Адаптеры итераторов</em> получают итератор и изменяют его каким-то образом, выдавая
новый итератор. Простейший из них называется <code>map</code>:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| x + 1);
</code></pre>
<p><code>map</code> вызывается для итератора, и создает новый итератор, каждый элемент
которого получается в результате вызова замыкания, в качестве аргумента которому
передается ссылка на исходный элемент. Так что этот код выдаст нам числа
<code>2-100</code>. Ну, почти! Если вы скомпилируете пример, этот код выдаст
предупреждение:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Причина этого — ленивость итераторов! То замыкание никогда не будет выполнено.
Пример ниже не напечатает ни одного значения:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Если вы пытаетесь выполнить замыкание ради побочных эффектов (вроде печати), то
вместо этого просто используйте <code>for</code>.</p>
<p>Есть масса интересных адаптеров итераторов. <code>take(n)</code> вернет итератор,
представляющий следующие <code>n</code> элементов исходного итератора. Обратите внимание,
что это не оказывает никакого влияния на оригинальный итератор. Давайте
попробуем применить его для бесконечных итераторов, которые мы упоминали раньше:</p>
<pre><code class="language-rust"># #![feature(step_by)]
for i in (1..).step_by(5).take(5) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>Этот код напечатает</p>
<pre><code class="language-text">1
6
11
16
21
</code></pre>
<p><code>filter()</code> представляет собой адаптер, который принимает замыкание в качестве
аргумента. Это замыкание возвращает <code>true</code> или <code>false</code>. Новый итератор,
полученный применением <code>filter()</code>, будет выдавать только те элементы, для
которых замыкание возвращает <code>true</code>:</p>
<pre><code class="language-rust">for i in (1..100).filter(|&amp;x| x % 2 == 0) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>Этот пример будет печатать все четные числа от одного до ста. (Обратите
внимание, что мы используем образец <code>&amp;x</code>, чтобы извлечь само целое число. Это
необходимо, поскольку <code>filter</code> не потребляет элементы, которые выдаются во время
итерации, а лишь выдаёт ссылку.)</p>
<p>Вы можете соединить все три понятия вместе: начать с итератора, адаптировать его
несколько раз, а затем потребить результат. Например:</p>
<pre><code class="language-rust">(1..)
    .filter(|&amp;x| x % 2 == 0)
    .filter(|&amp;x| x % 3 == 0)
    .take(5)
    .collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Этот код выдаст вектор, содержащий <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, <code>30</code>.</p>
<p>Это просто небольшой обзор того, как итераторы, адаптеры итераторов и
потребители могут помочь вам. Уже написано множество действительно полезных
итераторов, и вы также можете написать свой собственный итератор. Итераторы
обеспечивают безопасный и эффективный способ работы со всеми видами списков.
Сперва работать с ними немного непривычно, но чем больше вы с ними
сталкиваетесь, тем больше они вас цепляют. Для получения полного списка
различных итераторов, адаптеров и потребителей смотрите
<a href="http://doc.rust-lang.org/std/iter/index.html">документацию модуля iter</a>.</p>
<h1>Многозадачность</h1>
<p>Многозадачность и параллелизм являются невероятно важными проблемами в
информатике. Это актуальная тема для современной индустрии. У компьютеров все
больше и больше ядер, но многие программисты не готовы в полной мере
использовать их.</p>
<p>Средства Rust для безопасной работы с памятью в полной мере применимы и при
работе в многозадачной среде. Даже многозадачные программы на Rust должны
безопасно работать с памятью, и не создавать состояний гонок по данным. Система
типов Rust достаточно мощна, чтобы справиться с этими задачами на этапе
компиляции.</p>
<p>Прежде чем мы поговорим об особенностях многозадачности в Rust, важно понять вот
что: Rust — достаточно низкоуровневый язык, поэтому вся поддержка
многозадачности реализована в стандартной библиотеке, а не в самом языке. Это
означает, что если вам не нравится какой-то аспект реализации многозадачности в
Rust, вы всегда можете создать альтернативную библиотеку.
<a href="https://github.com/carllerche/mio">mio</a> — реально существующий пример такого
подхода.</p>
<h2>Справочная информация: <code>Send</code> и <code>Sync</code></h2>
<p>Рассуждать о многозадачности довольно трудно. Rust строго статически
типизирован, и это помогает нам делать выводы о коде. В связи с этим Rust
предоставляет два типажа, помогающих нам разбираться в любом коде, который
вообще может быть многозадачным.</p>
<h3><code>Send</code></h3>
<p>Первый типаж, о котором мы будем говорить, называется
[<code>Send</code>](http://doc.rust-lang.org/std/marker/trait.Send.html). Когда тип <code>T</code>
реализует <code>Send</code>, это указывает компилятору, что владение переменными этого типа
можно безопасно перемещать между потоками.</p>
<p>Это важно для соблюдения некоторых ограничений. Например, это имеет значение,
когда у нас есть канал, соединяющий два потока, и мы хотим отправлять некоторые
данные по каналу из одного потока в другой. Следовательно, мы должны
гарантировать, что для отправляемого типа данных реализован типаж <code>Send</code>.</p>
<p>И наоборот, если мы оборачиваем библиотеку чужого кода (FFI), и она не является
потокобезопасной, то нам не следует реализовывать типаж <code>Send</code>, и компилятор
поможет нам убедиться в невозможности покинуть текущий поток.</p>
<h3><code>Sync</code></h3>
<p>Второй из этих типажей называется
[<code>Sync</code>](http://doc.rust-lang.org/std/marker/trait.Sync.html). Когда тип <code>T</code>
реализует <code>Sync</code>, это указывает компилятору, что использование переменных этого
типа не приводит к небезопасной работе с памятью в многопоточной среде.</p>
<p>Например, совместное использование неизменяемых данных с помощью атомарного
счетчика ссылок является потокобезопасным. Rust обеспечивает такой тип,
<code>Arc&lt;T&gt;</code>, и он реализует <code>Sync</code>, так что при помощи этого типа можно безопасно
обмениваться данными между потоками.</p>
<p>Эти два типажа позволяют использовать систему типов, чтобы получить надежные
гарантии о свойствах вашего кода в условиях многозадачности. Прежде чем мы
покажем, как этого достигнуть, сначала мы должны узнать, как вообще написать
многозадачную программу в Rust!</p>
<h2>Потоки</h2>
<p>Стандартная библиотека Rust предоставляет библиотеку многопоточности, которая
позволяет запускать код на Rust параллельно. Вот простой пример использования
<code>std::thread</code>:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello from a thread!&quot;);
    });
}
</code></pre>
<p>Метод <code>thread::spawn()</code> в качестве единственного аргумента принимает замыкание,
которое выполняется в новом потоке. Он возвращает дескриптор потока, который
используется для ожидания завершения этого потока и извлечения его результата:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        &quot;Hello from a thread!&quot;
    });

    println!(&quot;{}&quot;, handle.join().unwrap());
}
</code></pre>
<p>Многие языки имеют возможность выполнять потоки, но это дико опасно. Есть целые
книги о том, как избежать ошибок, которые происходят от совместного
использования изменяемого состояния. В Rust снова помогает система типов,
которая предотвращает гонки данных на этапе компиляции. Давайте поговорим о том,
как же на самом деле обеспечивается совместное использование чего-либо в
условиях нескольких потоков.</p>
<h2>Безопасное совместное использование изменяемого состояния</h2>
<p>Вчитайтесь: «безопасное совместное использование изменяемого состояния». Похоже
на ложь, не так ли? Многие программисты считают, что организовать многопоточную
работу с изменяемым состоянием очень сложно и почти невозможно. Но благодаря
системе типов Rust, это всё же правда — безопасно работать с изменяемыми данными
можно.</p>
<p>Кто-то однажды сказал это:</p>
<blockquote>
<p>Совместно используемое изменяемое состояние является корнем всех зол.
Большинство языков пытаются решить эту проблему через часть, отвечающую за
«изменяемое», но Rust решает ее через часть, отвечающую за «совместно
используемое».</p>
</blockquote>
<p>Та же самая <a href="ownership.html">система владения</a>, которая помогает предотвратить
неправильное использование указателей, также помогает исключить гонки по данным,
один из худших видов ошибок многозадачности.</p>
<p>В качестве примера приведем программу на Rust, которая входила бы в состояние
гонки по данным на многих языках. На Rust она не скомпилируется:</p>
<pre><code class="language-ignore">use std::thread;

fn main() {
    let mut data = vec![1u32, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Она выдает ошибку:</p>
<pre><code class="language-text">8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>
<p>В данном случае мы знаем, что наш код <em>должен</em> быть безопасным, но Rust в этом
не уверен. И, на самом деле, он не является безопасным: мы работаем с <code>data</code> в
каждом потоке. При этом, поток становится владельцем того, что он получает как
часть окружения замыкания. А это значит, что у нас есть три владельца! Это
плохо. Мы можем исправить это с помощью типа <code>Arc&lt;T&gt;</code>, который является
атомарным указателем со счетчиком ссылок. «Атомарный» означает, что им безопасно
обмениваться между потоками.</p>
<p>Чтобы гарантировать, что его можно безопасно использовать из нескольких потоков,
<code>Arc&lt;T&gt;</code> предполагает наличие еще одного свойства у вложенного типа. Он
предполагает, что <code>T</code> реализует типаж <code>Sync</code>. В нашем случае мы также хотим,
чтобы была возможность изменять вложенное значение. Нам нужен тип, который может
обеспечить изменение своего содержимого лишь одним пользователем одновременно.
Для этого мы можем использовать тип <code>Mutex&lt;T&gt;</code>. Вот вторая версия нашего кода.
Она по-прежнему не работает, но по другой причине:</p>
<pre><code class="language-ignore">use std::thread;
use std::sync::Mutex;

fn main() {
    let mut data = Mutex::new(vec![1u32, 2, 3]);

    for i in 0..3 {
        let data = data.lock().unwrap();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">&lt;anon&gt;:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` [E0277]
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
&lt;anon&gt;:9:9: 9:22 note: `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` cannot be sent between threads safely
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
</code></pre>
<p>Вы можете видеть, что [<code>Mutex</code>](http://doc.rust-lang.org/std/sync/struct.Mutex.html) содержит метод
[<code>lock</code>](http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock), который имеет следующую
сигнатуру:</p>
<pre><code class="language-ignore">fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
</code></pre>
<p>Так как типаж <code>Send</code> не был реализован для <code>MutexGuard&lt;T&gt;</code>, мы не можем
перемещать охранное значение мьютекса через границы потоков, что и сказано в
сообщении об ошибке.</p>
<p>Мы можем использовать <code>Arc&lt;T&gt;</code>, чтобы исправить это. Вот рабочая версия:</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Теперь мы вызываем <code>clone()</code> для нашего <code>Arc</code>, что увеличивает внутренний
счетчик. Затем полученная ссылка перемещается в новый поток. Давайте более
подробно рассмотрим тело потока:</p>
<pre><code class="language-rust"># use std::sync::{Arc, Mutex};
# use std::thread;
# fn main() {
#     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));
#     for i in 0..3 {
#         let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
#     }
#     thread::sleep_ms(50);
# }
</code></pre>
<p>Во-первых, мы вызываем метод <code>lock()</code>, который захватывает блокировку мьютекса.
Так как вызов данного метода может потерпеть неудачу, он возвращает <code>Result&lt;T, E&gt;</code>, но, поскольку это просто пример, мы используем <code>unwrap()</code>, чтобы получить
ссылку на данные. Реальный код должен иметь более надежную обработку ошибок в
такой ситуации. После этого мы свободно изменяем данные, так как у нас есть
блокировка.</p>
<p>Под конец мы ждём какое-то время, пока потоки отработают. Это не идеальный
способ дождаться окончания их работы: возможно, мы выбрали разумное время
ожидания но, скорее всего, мы будем ждать либо больше чем нужно, либо меньше чем
нужно, в зависимости от того, сколько на самом деле времени потребуется
потокам, чтобы закончить вычисления.</p>
<p>Есть более точные способы синхронизации потоков, и несколько из них реализовано
в стандартной библиотеке Rust. Давайте поговорим об одном из них: каналах.</p>
<h2>Каналы</h2>
<p>Вот версия нашего кода, которая использует для синхронизации каналы, вместо
того, чтобы ждать в течение определенного времени:</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0u32));

    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(());
        });
    }

    for _ in 0..10 {
        rx.recv();
    }
}
</code></pre>
<p>Мы используем метод <code>mpsc::channel()</code>, чтобы создать новый канал. В этом примере
мы в каждом из десяти потоков вызываем метод <code>send</code>, который передает по каналу
пустой кортеж <code>()</code>, а затем в главном потоке ждем, пока не будут приняты все
десять значений.</p>
<p>Хотя по этому каналу посылается просто сигнал (пустой кортеж <code>()</code> не несёт
никаких данных), в общем случае мы можем отправить по каналу любое значение,
которое реализует типаж <code>Send</code>!</p>
<pre><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = 42u32;

            tx.send(answer);
        });
    }

   rx.recv().ok().expect(&quot;Could not receive answer&quot;);
}
</code></pre>
<p><code>u32</code> реализует <code>Send</code>, потому что мы можем сделать копию. Итак, создаётся
поток, в котором вычисляется ответ, а затем этот ответ с помощью метода <code>send()</code>
передаётся обратно по каналу.</p>
<h2>Паника</h2>
<p><code>panic!</code> аварийно завершает выполняемый в данный момент поток. Вы можете
использовать потоки Rust как простой механизм изоляции:</p>
<pre><code class="language-rust">use std::thread;

let result = thread::spawn(move || {
    panic!(&quot;oops!&quot;);
}).join();

assert!(result.is_err());
</code></pre>
<p>Используемый в коде выше метод <code>join()</code> структуры <code>Thread</code> возвращает <code>Result</code>,
что позволяет нам проверить, паниковал ли поток, или он завершился нормально.</p>
<h1>Обработка ошибок</h1>
<p>Как и многие языки программирования, Rust призывает разработчика определенным
способом обрабатывать ошибки. Вообще, существует два общих подхода
обработки ошибок: с помощью исключений и через возвращаемые значения. И Rust
предпочитает возвращаемые значения.</p>
<p>В этой главе мы намерены подробно изложить работу с ошибками в Rust. Более того,
мы попробуем раз за разом погружаться в обработку ошибок с различных сторон, так
что под конец у вас будет уверенное практическое представление о том, как все
это сходится воедино.</p>
<p>В наивной реализации обработка ошибок в Rust может выглядеть многословной и
раздражающей. Мы рассмотрим основные камни преткновения, а также
продемонстрируем, как сделать обработку ошибок лаконичной и удобной, пользуясь
стандартной библиотекой.</p>
<h1>Содержание</h1>
<p>Эта глава очень длинная, в основном потому, что мы начнем с самого начала
— рассмотрения типов-сумм (sum type) и комбинаторов, и далее попытаемся
последовательно объяснить подход Rust к обработке ошибок. Так что разработчики,
которые имеют опыт работы с другими выразительными системами типов, могут
свободно перескакивать от раздела к разделу.</p>
<ul>
<li><a href="#the-basics">Основы</a>
<ul>
<li>[Объяснение <code>unwrap</code>](#unwrapping-explained)</li>
<li>[Тип <code>Option</code>](#the-option-type)
<ul>
<li>[Совмещение значений <code>Option&lt;T&gt;</code>](#composing-optiont-values)</li>
</ul>
</li>
<li>[Тип <code>Result</code>](#the-result-type)
<ul>
<li><a href="#parsing-integers">Преобразование строки в число</a></li>
<li>[Создание псевдонима типа <code>Result</code>](#the-result-type-alias-idiom)</li>
</ul>
</li>
<li><a href="#a-brief-interlude-unwrapping-isnt-evil">Короткое отступление: <code>unwrap</code> — не обязательно зло</a></li>
</ul>
</li>
<li><a href="#working-with-multiple-error-types">Работа с несколькими типами ошибок</a>
<ul>
<li>[Совмещение <code>Option</code> и <code>Result</code>](#composing-option-and-result)</li>
<li><a href="#the-limits-of-combinators">Ограничения комбинаторов</a></li>
<li>[Преждевременный <code>return</code>](#early-returns)</li>
<li>[Макрос <code>try!</code>](#the-try-macro)</li>
<li><a href="#defining-your-own-error-type">Объявление собственного типа ошибки</a></li>
</ul>
</li>
<li><a href="#standard-library-traits-used-for-error-handling">Типажи из стандартной библиотеки, используемые для обработки ошибок</a>
<ul>
<li>[Типаж <code>Error</code>](#the-error-trait)</li>
<li>[Типаж <code>From</code>](#the-from-trait)</li>
<li>[Настоящий макрос <code>try!</code>](#the-real-try-macro)</li>
<li><a href="#composing-custom-error-types">Совмещение собственных типов ошибок</a></li>
<li><a href="#advice-for-library-writers">Рекомендации для авторов библиотек</a></li>
</ul>
</li>
<li>Практический пример: Программа для чтения демографических данных</li>
<li><a href="#the-short-story">Заключение</a></li>
</ul>
<p><a name="the-basics"></a></p>
<h1>Основы</h1>
<p>Обработку ошибок можно рассматривать как <em>вариативный анализ</em> того, было ли
некоторое вычисление выполнено успешно или нет. Как будет показано далее,
ключом к удобству обработки ошибок является сокращение количества явного
вариативного анализа, который должен выполнять разработчик, сохраняя при этом
код легко сочетаемым с другим кодом (composability).</p>
<p><em>(Примечание переводчика: Вариативный анализ – это один из наиболее
общеприменимых методов аналитического  мышления, который заключается в
рассмотрении проблемы, вопроса или некоторой ситуации с точки зрения каждого
возможного конкретного случая. При этом рассмотрение по отдельности каждого
такого случая является достаточным для того, чтобы решить первоначальный
вопрос.</em></p>
<p><em>Важным аспектом такого подхода к решению проблем является то, что такой анализ
должен быть исчерпывающим (exhaustive). Другими словами, при использовании
вариативного анализа должны быть рассмотрены все возможные случаи.</em></p>
<p><em>В Rust вариативный анализ реализуется с помощью синтаксической конструкции
[<code>match</code>](match.html). При этом компилятор гарантирует, что такой анализ будет
исчерпывающим: если разработчик не рассмотрит все возможные варианты заданного
значения, программа не будет скомпилирована.)</em></p>
<p>Сохранять сочетаемость кода важно, потому что без этого требования
мы могли бы просто получать [<code>panic</code>](http://doc.rust-lang.org/std/macro.panic!.html) всякий раз,
когда мы сталкивались бы с чем-то неожиданным. (<code>panic</code> вызывает прерывание
текущего потока и, в большинстве случаев, приводит к завершению всей программы.)
Вот пример:</p>
<pre><code class="language-rust,should_panic">// Попробуйте угадать число от 1 до 10.
// Если заданное число соответствует тому, что мы загадали, возвращается true.
// В противном случае возвращается false.
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Неверное число: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</code></pre>
<p>Если попробовать запустить этот код, то программа аварийно завершится с
сообщением вроде этого:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'Неверное число: 11', src/bin/panic-simple.rs:6
</code></pre>
<p>Вот другой, менее надуманный пример. Программа, которая принимает число в
качестве аргумента, удваивает его значение и печатает на экране.</p>
<p><a name="code-unwrap-double"></a></p>
<pre><code class="language-rust,should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // ошибка 1
    let n: i32 = arg.parse().unwrap();      // ошибка 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre>
<p>Если вы запустите эту программу без параметров (ошибка 1) или если первый
параметр будет не целым числом (ошибка 2), программа завершится паникой, так же,
как и в первом примере.</p>
<p>Обработка ошибок в подобном стиле подобна слону в посудной лавке. Слон будет
нестись в направлении, в котором ему вздумается, и крушить все на своем пути.</p>
<p><a name="unwrapping-explained"></a></p>
<h2>Объяснение <code>unwrap</code></h2>
<p>В предыдущем примере мы утверждали, что программа будет просто паниковать,
если будет выполнено одно из двух условий для возникновения ошибки, хотя,
в отличии от первого примера, в коде программы нет явного вызова <code>panic</code>.
Тем не менее, вызов <code>panic</code> встроен в вызов <code>unwrap</code>.</p>
<p>Вызывать <code>unwrap</code> в Rust подобно тому, что сказать: &quot;Верни мне результат
вычислений, а если произошла ошибка, просто паникуй и останавливай программу&quot;.
Мы могли бы просто показать исходный код функции <code>unwrap</code>, ведь это довольно
просто, но перед этим мы должны разобратся с типами <code>Option</code> и <code>Result</code>. Оба
этих типа имеют определенный для них метод <code>unwrap</code>.</p>
<p><a name="the-option-type"></a></p>
<h3>Тип <code>Option</code></h3>
<p>Тип <code>Option</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">объявлен в стандартной библиотеке</a>:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>Тип <code>Option</code> — это способ выразить <em>возможность отсутствия</em> чего бы то ни было,
используя систему типов Rust. Выражение <em>возможности отсутствия</em> через систему
типов является важной концепцией, поскольку такой подход позволяет компилятору
требовать от разработчика обрабатывать такое отсутствие. Давайте взглянем на
пример, который пытается найти символ в строке:</p>
<p><a name="code-option-ex-string-find"></a></p>
<pre><code class="language-rust">// Поиск Unicode-символа `needle` в `haystack`. Когда первый символ найден,
// возвращается побайтовое смещение для этого символа. Иначе возвращается `None`.
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
</code></pre>
<p>Обратите внимание, что когда эта функция находит соответствующий символ, она
возвращает не просто <code>offset</code>. Вместо этого она возвращает <code>Some(offset)</code>.
<code>Some</code> — это вариант или <em>конструктор значения</em> для типа <code>Option</code>.
Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>.
Соответственно, <code>None</code> — это также конструктор значения, только у него нет
параметров. Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
<p>Может показаться, что мы подняли много шума из ничего, но это только половина
истории. Вторая половина — это <em>использование</em> функции <code>find</code>, которую мы
написали. Давайте попробуем использовать ее, чтобы найти расширение
в имени файла.</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, '.') {
        None =&gt; println!(&quot;Расширение файла не найдено.&quot;),
        Some(i) =&gt; println!(&quot;Расширение файла: {}&quot;, &amp;file_name[i+1..]),
    }
}
</code></pre>
<p>Этот код использует <a href="patterns.html">сопоставление с образцом</a> чтобы выполнить <em>вариативный
анализ</em> для возвращаемого функцией <code>find</code> значения <code>Option&lt;usize&gt;</code>. На самом
деле, вариативный анализ является единственным способом добраться до значения,
сохраненного внутри <code>Option&lt;T&gt;</code>. Это означает, что вы, как разработчик, обязаны
обработать случай, когда значение <code>Option&lt;T&gt;</code> равно <code>None</code>, а не <code>Some(t)</code>.</p>
<p>Но подождите, как насчет <code>unwrap</code>, который мы [<code>до этого</code>](#code-unwrap-double)
использовали? Там не было никакого вариативного анализа! Вместо этого,
вариативный анализ был перемещен внутрь метода <code>unwrap</code>. Вы можете сделать это
самостоятельно, если захотите:</p>
<p><a name="code-option-def-unwrap"></a></p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>Метод <code>unwrap</code> <em>абстрагирует вариативный анализ</em>. Это именно то, что делает
<code>unwrap</code> удобным в использовании. К сожалению, <code>panic!</code> означает, что <code>unwrap</code>
неудобно сочетать с другим кодом: это слон в посудной лавке.</p>
<p><a name="composing-optiont-values"></a></p>
<h3>Совмещение значений <code>Option&lt;T&gt;</code></h3>
<p>В <a href="#code-option-ex-string-find">предыдущем примере</a> мы рассмотрели, как
можно воспользоватся <code>find</code> для того, чтобы получить расширение имени файла.
Конечно, не во всех именах файлов можно найти <code>.</code>, так что существует
вероятность, что имя некоторого файла не имеет расширения. Эта <em>возможность
отсутствия</em> интерпретируется на уровне типов через использование <code>Option&lt;T&gt;</code>.
Другими словами, компилятор заставит нас рассмотреть возможность того, что
расширение не существует. В нашем случае мы просто печатаем сообщение об этом.</p>
<p>Получение расширения имени файла — довольно распространенная операция,
так что имеет смысл вынести код в отдельную функцию:</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Возвращает расширение заданного имени файла, а именно все символы,
// идущие за первым вхождением `.` в имя файла.
// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.
fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, '.') {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}
</code></pre>
<p>(Подсказка: не используйте этот код. Вместо этого используйте метод
[<code>extension</code>](http://doc.rust-lang.org/std/path/struct.Path.html#method.extension) из стандартной
библиотеки.)</p>
<p>Код выглядит простым, но его важный аспект заключается в том, что функция <code>find</code>
заставляет нас рассмотреть вероятность отсутствия значения. Это хорошо,
поскольку это означает, что компилятор не позволит нам случайно забыть о том
варианте, когда в имени файла отсутствует расширение. С другой стороны, каждый
раз выполнять явный вариативный анализ, подобно тому, как мы делали это в
<code>extension_explicit</code>, может стать немного утомительным.</p>
<p>На самом деле, вариативный анализ в <code>extension_explicit</code> является очень
распространенным паттерном: если <code>Option&lt;T&gt;</code> владеет определенным значением <code>T</code>,
то выполнить его преобразование с помощью функции, а если нет — то просто
вернуть <code>None</code>.</p>
<p>Rust поддерживает параметрический полиморфизм, так что можно очень легко
объявить комбинатор, который абстрагирует это поведение:</p>
<p><a name="code-option-map"></a></p>
<pre><code class="language-rust">fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
</code></pre>
<p>В действительности, <code>map</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">определен в стандартной библиотеке</a> как метод <code>Option&lt;T&gt;</code>.</p>
<p>Вооружившись нашим новым комбинатором, мы можем переписать наш метод
<code>extension_explicit</code> так, чтобы избавиться от вариативного анализа:</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Возвращает расширение заданного имени файла, а именно все символы,
// идущие за первым вхождением `.` в имя файла.
// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, '.').map(|i| &amp;file_name[i+1..])
}
</code></pre>
<p>Есть еще одно поведение, которое можно часто встретить — это использование
значения по-умолчанию в случае, когда значение <code>Option</code> равно <code>None</code>.
К примеру, ваша программа может считать, что расширение файла равно <code>rs</code>
в случае, если на самом деле оно отсутствует.</p>
<p>Легко представить, что этот случай вариативного анализа не специфичен
только для расширений файлов — такой подход может работать с любым <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-rust">fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
</code></pre>
<p>Хитрость только в том, что значение по-умолчанию должно иметь тот же тип, что и
значение, которое может находится внутри  <code>Option&lt;T&gt;</code>. Использование этого
метода элементарно:</p>
<pre><code class="language-rust"># fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
#     for (offset, c) in haystack.char_indices() {
#         if c == needle {
#             return Some(offset);
#         }
#     }
#     None
# }
#
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
#     find(file_name, '.').map(|i| &amp;file_name[i+1..])
# }
fn main() {
    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);
    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</code></pre>
<p>(Обратите внимание, что <code>unwrap_or</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">объявлен как метод</a> <code>Option&lt;T&gt;</code> в
стандартной библиотеке, так что мы воспользовались им вместо функции, которую
мы объявили ранее. Не забудьте также изучить более общий метод
[<code>unwrap_or_else</code>]<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">4</a>).</p>
<p>Существует еще один комбинатор, на который, как мы думаем, стоит обратить
особое внимание: <code>and_then</code>. Он позволяет легко сочетать различные вычисления,
которые допускают <em>возможность отсутствия</em>. Пример — большая часть кода в
этом разделе, который связан с определением расширения заданного имени файла.
Чтобы делать это, нам для начала необходимо узнать имя файла, которое как правило
извлекается из <em>файлового пути</em>. Хотя большинство файловых путей содержат имя
файла, подобное нельзя сказать обо <em>всех</em> файловых путях. Примером могут
послужить пути <code>.</code>, <code>..</code> или <code>/</code>.</p>
<p>Таким образом, мы определили задачу нахождения расширения заданного <em>файлового
пути</em>. Начнем с явного вариативного анализа:</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match file_name(file_path) {
        None =&gt; None,
        Some(name) =&gt; match extension(name) {
            None =&gt; None,
            Some(ext) =&gt; Some(ext),
        }
    }
}

fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
  unimplemented!() // опустим реализацию
}
</code></pre>
<p>Можно подумать, мы могли бы просто использовать комбинатор <code>map</code>, чтобы
уменьшить вариативный анализ, но его тип не совсем подходит. Дело в том, что
<code>map</code> принимает функцию, которая делает что-то только с внутренним значением.
Результат такой функции <em>всегда</em> [оборачивается в <code>Some</code>](#code-option-map).
Вместо этого, нам нужен метод, похожий <code>map</code>, но который позволяет вызывающему
передать еще один <code>Option</code>. Его общая реализация даже проще, чем <code>map</code>:</p>
<pre><code class="language-rust">fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
</code></pre>
<p>Теперь мы можем переписать нашу функцию <code>file_path_ext</code> без явного вариативного
анализа:</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
</code></pre>
<p>Тип <code>Option</code> имеет много других комбинаторов <a href="http://doc.rust-lang.org/std/option/enum.Option.html">определенных в стандартной
библиотеке</a>. Очень полезно просмотреть этот список и ознакомиться с
доступными методами — они не раз помогут вам сократить количество вариативного
анализа. Ознакомление с этими комбинаторами окупится еще и потому, что многие
из них определены с аналогичной семантикой и для типа <code>Result</code>, о котором мы
поговорим далее.</p>
<p>Комбинаторы упрощают использование типов вроде <code>Option</code>, ведь
они сокращают явный вариативный анализ. Они также соответствуют требованиям
сочетаемости, поскольку они позволяют вызывающему обрабатывать возможность
отсутствия результата собственным способом. Такие методы, как <code>unwrap</code>,
лишают этой возможности, ведь они будут паниковать в случае, когда <code>Option&lt;T&gt;</code>
равен <code>None</code>.</p>
<p><a name="the-result-type"></a></p>
<h2>Тип <code>Result</code></h2>
<p>Тип <code>Result</code> также <a href="http://doc.rust-lang.org/std/result/">определен в стандартной библиотеке</a>:</p>
<p><a name="code-result-def"></a></p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>Тип <code>Result</code> — это продвинутая версия <code>Option</code>. Вместо того, чтобы выражать
возможность <em>отсутствия</em>, как это делает <code>Option</code>, <code>Result</code> выражает возможность
<em>ошибки</em>. Как правило, <em>ошибки</em> необходимы для объяснения того, почему
результат определенного вычисления не был получен. Строго говоря, это более
общая форма <code>Option</code>. Рассмотрим следующий псевдоним типа, который во всех
смыслах семантически эквивалентен реальному <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-rust">type Option&lt;T&gt; = Result&lt;T, ()&gt;;
</code></pre>
<p>Здесь второй параметр типа <code>Result</code> фиксируется и определяется через <code>()</code>
(произносится как &quot;unit&quot; или &quot;пустой кортеж&quot;). Тип <code>()</code> имеет ровно одно
значение — <code>()</code>. (Да, это тип и значение этого типа, которые выглядят
одинаково!)</p>
<p>Тип <code>Result</code> — это способ выразить один из двух возможных исходов вычисления.
По соглашению, один исход означает ожидаемый результат или &quot;<code>Ok</code>&quot;, в то время
как другой исход означает исключительную ситуацию или &quot;<code>Err</code>&quot;.</p>
<p>Подобно <code>Option</code>, тип <code>Result</code> имеет метод <code>unwrap</code>,
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap">определенный в стандартной библиотеке</a>. Давайте объявим его самостоятельно:</p>
<pre><code class="language-rust"># enum Result&lt;T, E&gt; { Ok(T), Err(E) }
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
        }
    }
}
</code></pre>
<p>Это фактически то же самое, что и
[определение <code>Option::unwrap</code>](#code-option-def-unwrap), за исключением
того, что мы добавили значение ошибки в сообщение <code>panic!</code>. Это упрощает
отладку, но это также вынуждает нас требовать от типа-параметра <code>E</code>
(который представляет наш тип ошибки) реализации [<code>Debug</code>]<a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html">8</a>. Поскольку
подавляющее большинство типов должны реализовывать <code>Debug</code>, обычно на практике
такое ограничение не мешает. (Реализация <code>Debug</code> для некоторого типа
просто означает, что существует разумный способ печати удобочитаемого описания
значения этого типа.)</p>
<p>Окей, давайте перейдем к примеру.</p>
<p><a name="parsing-integers"></a></p>
<h3>Преобразование строки в число</h3>
<p>Стандартная библиотека Rust позволяет элементарно преобразовывать строки
в целые числа. На самом деле это настолько просто, что возникает соблазн написать
что-то вроде:</p>
<pre><code class="language-rust">fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</code></pre>
<p>Здесь вы должны быть скептически настроены по-поводу вызова <code>unwrap</code>.
Если строку нельзя преобразовать в число, вы получите панику:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>
<p>Это довольно неприятно, и если бы подобное произошло в используемой вами
библиотеке, вы могли бы небезосновательно разгневаться. Так что нам стоит
попытаться обработать ошибку в нашей функции, и пусть вызывающий сам решит что
с этим делать. Это означает необходимость изменения типа, который возвращается
<code>double_number</code>. Но на какой? Чтобы понять это, необходимо посмотреть на
сигнатуру [<code>метода parse</code>]<a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse">9</a> из стандартной библиотеки:</p>
<pre><code class="language-rust,ignore">impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}
</code></pre>
<p>Хмм. По крайней мере мы знаем, что должны использовать <code>Result</code>. Вполне
возможно, что метод мог возвращать <code>Option</code>. В конце концов, строка
либо парсится как число, либо нет, не так ли? Это, конечно, разумный путь, но
внутренняя реализация знает <em>почему</em> строка не может быть преобразована в целое число.
(Это может быть пустая строка, или неправильные цифры, слишком большая или
слишком маленькая длина и т.д.) Таким образом, использование <code>Result</code> имеет
смысл, ведь мы хотим предоставить больше информации, чем просто &quot;отсутствие&quot;.
Мы хотим сказать, <em>почему</em> преобразование не удалось. Вам стоит рассуждать похожим
образом, когда вы сталкиваетесь с выбором между <code>Option</code> и <code>Result</code>.
Если вы можете предоставить подробную информацию об ошибке, то вам, вероятно,
следует это сделать. (Позже мы поговорим об этом подробнее.)</p>
<p>Хорошо, но как мы запишем наш тип возвращаемого значения? Метод <code>parse</code>
является обобщенным (generic) для всех различных типов чисел из
стандартной библиотеки. Мы могли бы (и, вероятно, должны) также сделать
нашу функцию обобщенной, но давайте пока остановимся на конкретной
реализации. Нас интересует только тип <code>i32</code>, так что нам стоит [найти его
реализацию <code>FromStr</code>](http://doc.rust-lang.org/std/primitive.i32.html) (выполните поиск в вашем
браузере по строке &quot;FromStr&quot;) и посмотреть на его <a href="associated-types.html">ассоциированный тип</a>
<code>Err</code>. Мы делаем это, чтобы определить конкретный тип ошибки. В данном
случае, это [<code>std::num::ParseIntError</code>](http://doc.rust-lang.org/std/num/struct.ParseIntError.html).
Наконец, мы можем переписать нашу функцию:</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre>
<p>Неплохо, но нам пришлось написать гораздо больше кода! И нас опять раздражает
вариативный анализ.</p>
<p>Комбинаторы спешат на помощь! Подобно <code>Option</code>, <code>Result</code> имеет много
комбинаторов, определенных в качестве методов. Существует большой
список комбинаторов, общих между <code>Result</code> и <code>Option</code>. И <code>map</code> входит в этот
список:</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre>
<p>Все ожидаемые методы реализованы для <code>Result</code>, включая
[<code>unwrap_or</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or) и
[<code>and_then</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then). Кроме того,
поскольку <code>Result</code> имеет второй параметр типа, существуют комбинаторы,
которые влияют только на значение ошибки, такие как
[<code>map_err</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err) (аналог <code>map</code>) и
[<code>or_else</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else) (аналог <code>and_then</code>).</p>
<p><a name="the-result-type-alias-idiom"></a></p>
<h3>Создание псевдонима типа <code>Result</code></h3>
<p>В стандартной библиотеке можно часто увидеть типы вроде <code>Result&lt;i32&gt;</code>.
Но постойте, ведь [мы определили <code>Result</code>](#code-result-def) с двумя
параметрами типа. Как мы можем обойти это, указывая только один из них? Ответ
заключается в определении псевдонима типа <code>Result</code>, который <em>фиксирует</em> один из
параметров конкретным типом. Обычно фиксируется тип ошибки. Например, наш
предыдущий пример с преобразованием строк в числа можно переписать так:</p>
<pre><code class="language-rust">use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
</code></pre>
<p>Зачем мы это делаем? Что ж, если у нас есть много функций, которые могут вернуть
<code>ParseIntError</code>, то гораздо удобнее определить псевдоним, который всегда
использует <code>ParseIntError</code>, так что мы не будем повторяться все время.</p>
<p>Самый заметный случай использования такого подхода в стандартной библиотеке —
псевдоним [<code>io::Result</code>](http://doc.rust-lang.org/std/io/type.Result.html). Как правило, достаточно
писать <code>io::Result&lt;T&gt;</code>, чтобы было понятно, что вы используете псевдоним типа
из модуля <code>io</code>, а не обычное определение из <code>std::result</code>. (Этот подход также
используется для [<code>fmt::Result</code>](http://doc.rust-lang.org/std/fmt/type.Result.html))</p>
<p><a name="a-brief-interlude-unwrapping-isnt-evil"></a></p>
<h2>Короткое отступление: <code>unwrap</code> — не обязательно зло</h2>
<p>Если вы были внимательны, то возможно заметили, что я занял довольно жесткую
позицию по отношению к методам вроде <code>unwrap</code>, которые могут вызвать <code>panic</code> и
прервать исполнение вашей программы. <em>В основном</em>, это хороший совет.</p>
<p>Тем не менее, <code>unwrap</code> все-таки можно использовать разумно. Факторы, которые
оправдывают использование <code>unwrap</code>, являются несколько туманными, и разумные люди
могут со мной не согласиться. Я кратко изложу свое <em>мнение</em> по этому вопросу:</p>
<ul>
<li><strong>Примеры и &quot;грязный&quot; код.</strong> Когда вы пишете просто пример или быстрый
скрипт, обработка ошибок просто не требуется. Для подобных случаев трудно
найти что-либо удобнее чем <code>unwrap</code>, так что здесь его использование очень
привлекательно.</li>
<li><strong>Паника указывает на ошибку в программе.</strong> Если логика вашего кода
должна предотвращать определенное поведение (скажем, получение элемента из
пустого стека), то использование <code>panic</code> также допустимо. Дело в том, что в
этом случае паника будет сообщать о баге в вашей программе. Это может
происходить явно, например от неудачного вызова <code>assert!</code>, или происходить
потому, что индекс по массиву находится за пределами выделенной памяти.</li>
</ul>
<p>Вероятно, это не исчерпывающий список. Кроме того, при использовании
<code>Option</code> зачастую лучше использовать метод
[<code>expect</code>](http://doc.rust-lang.org/std/option/enum.Option.html#method.expect). Этот метод делает
ровно то же, что и <code>unwrap</code>, за исключением того, что в случае паники
напечатает ваше сообщение. Это позволит лучше понять причину ошибки, ведь
будет показано конкретное сообщение, а не просто &quot;called unwrap on a <code>None</code>
value&quot;.</p>
<p>Мой совет сводится к следующему: используйте здравый смысл. Есть причины, по
которым слова вроде &quot;никогда не делать X&quot; или &quot;Y считается вредным&quot; не появятся
в этой статье. У любых решений существуют компромиссы, и это ваша задача,
как разработчика, определить, что именно является приемлемым для вашего случая.
Моя цель состоит только в том, чтобы помочь вам оценить компромиссы как можно
точнее.</p>
<p>Теперь, когда мы рассмотрели основы обработки ошибок в Rust и разобрались с
<code>unwrap</code>, давайте подробнее изучим стандартную библиотеку.</p>
<p><a name="working-with-multiple-error-types"></a></p>
<h1>Работа с несколькими типами ошибок</h1>
<p>До этого момента мы расматривали обработку ошибок только для случаев, когда все
сводилось либо только к <code>Option&lt;T&gt;</code>, либо только к <code>Result&lt;T, SomeError&gt;</code>.
Но что делать, когда у вас есть и <code>Option</code>, и <code>Result</code>? Или если у вас есть
<code>Result&lt;T, Error1&gt;</code> и <code>Result&lt;T, Error2&gt;</code>? Наша следующуя задача — обработка
<em>композиции различных типов ошибок</em>, и это будет главной темой на протяжении
всей этой главы.</p>
<p><a name="composing-option-and-result"></a></p>
<h2>Совмещение <code>Option</code> и <code>Result</code></h2>
<p>Пока что мы говорили о комбинаторах, определенных для <code>Option</code>, и комбинаторах,
определенных для <code>Result</code>. Эти комбинаторы можно использовать для того, чтобы
сочетать результаты различных вычислений, не делая подробного вариативного
анализа.</p>
<p>Конечно, в реальном коде все происходит не так гладко. Иногда у вас
есть сочетания типов <code>Option</code> и <code>Result</code>. Должны ли мы прибегать к явному
вариативному анализу, или можно продолжить использовать комбинаторы?</p>
<p>Давайте на время вернемся к одному из первых примеров в этой главе:</p>
<pre><code class="language-rust,should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // ошибка 1
    let n: i32 = arg.parse().unwrap(); // ошибка 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre>
<p>Учитывая наши знания о типах <code>Option</code> и <code>Result</code>, а также их различных
комбинаторах, мы можем попытаться переписать этот код так, чтобы ошибки
обрабатывались должным образом, и программа не паниковала в случае ошибки.</p>
<p>Ньюанс заключается в том, что <code>argv.nth(1)</code> возвращает <code>Option</code>, в
то время как <code>arg.parse()</code> возвращает <code>Result</code>. Они не могут быть скомпонованы
непосредственно. Когда вы сталкиваетесь одновременно с <code>Option</code> и<code>Result</code>,
<em>обычно</em> наилучшее решение — преобразовать <code>Option</code> в <code>Result</code>. В нашем случае,
отсутствие параметра командной строки (из <code>env::args()</code>) означает, что
пользователь не правильно вызвал программу. Мы могли бы просто использовать
<code>String</code> для описания ошибки. Давайте попробуем:</p>
<p><a name="code-error-double-string"></a></p>
<pre><code class="language-rust">use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre>
<p>Раcсмотрим пару новых моментов на этом примере. Во-первых, использование
комбинатора [<code>Option::ok_or</code>](http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or).
Это один из способов преобразования <code>Option</code> в <code>Result</code>. Такое преобразование
требует явного определения ошибки, которую необходимо вернуть в случае, когда
значение <code>Option</code> равно <code>None</code>. Как и для всех комбинаторов, которые мы
рассматривали, его объявление очень простое:</p>
<pre><code class="language-rust">fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
</code></pre>
<p>Второй новый комбинатор, который мы использовали —
[<code>Result::map_err</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err). Это то же
самое, что и <code>Result::map</code>, за исключением того, функция применяется к
<em>ошибке</em> внутри <code>Result</code>. Если значение <code>Result</code> равно <code>Оk(...)</code>, то оно
возвращается без изменений.</p>
<p>Мы используем <code>map_err</code>, потому что нам необходимо привести все ошибки к
одинаковому типу (из-за нашего использования <code>and_then</code>). Поскольку мы решили
преобразовывать <code>Option&lt;String&gt;</code> (из <code>argv.nth(1)</code>) в <code>Result&lt;String, String&gt;</code>,
мы также обязаны преобразовывать <code>ParseIntError</code> из <code>arg.parse()</code> в <code>String</code>.</p>
<p><a name="the-limits-of-combinators"></a></p>
<h2>Ограничения комбинаторов</h2>
<p>Работа с IO и анализ входных данных — очень типичные задачи, и это то, чем
лично я много занимаюсь с Rust. Так что мы будем использовать IO и различные
процедуры анализа как примеры обработки ошибок.</p>
<p>Давайте начнем с простого. Поставим задачу открыть файл, прочесть все его
содержимое и преобразовать это содержимое в число. После этого нужно будет
умножить значение на <code>2</code> и распечатать результат.</p>
<p>Хоть я и пытался убедить вас не использовать <code>unwrap</code>, иногда бывает
полезным для начала написать код с <code>unwrap</code>. Это позволяет сосредоточиться
на проблеме, а не на обработке ошибок, и это выявляет места, где надлежащая
обработка ошибок необходима. Давайте начнем с того, что напишем просто
работающий код, а затем отрефакторим его для лучшей обработки ошибок.</p>
<pre><code class="language-rust,should_panic">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // ошибка 1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();   // ошибка 2
    let n: i32 = contents.trim().parse().unwrap(); // ошибка 3
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
</code></pre>
<p>(Замечание: Мы используем <code>AsRef</code> по [тем же причинам, почему он используется в
<code>std::fs::File::open</code>](http://doc.rust-lang.org/std/fs/struct.File.html#method.open). Это позволяет
удобно использовать любой тип строки в качестве пути к файлу.)</p>
<p>У нас есть три потенциальные ошибки, которые могут возникнуть:</p>
<ol>
<li>Проблема при открытии файла.</li>
<li>Проблема при чтении данных из файла.</li>
<li>Проблема при преобразовании данных в число.</li>
</ol>
<p>Первые две проблемы определяются типом
[<code>std::io::Error</code>](http://doc.rust-lang.org/std/io/struct.Error.html). Мы знаем это из типа
возвращаемого значения методов
[<code>std::fs::File::open</code>](http://doc.rust-lang.org/std/fs/struct.File.html#method.open) и
[<code>std::io::Read::read_to_string</code>](http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string).
(Обратите внимание, что они оба используют
[концепцию с псевдонимом типа <code>Result</code>](#the-result-type-alias-idiom),
описанную ранее. Если вы кликните на тип <code>Result</code>, вы
<a href="http://doc.rust-lang.org/std/io/type.Result.html">увидите псевдоним типа</a>, и следовательно, лежащий
в основе тип <code>io::Error</code>.) Третья проблема определяется типом
[<code>std::num::ParseIntError</code>](http://doc.rust-lang.org/std/num/struct.ParseIntError.html). Кстати, тип
<code>io::Error</code> <em>часто</em> используется по всей стандартной библиотеке. Вы будете
видеть его снова и снова.</p>
<p>Давайте начнем рефакторинг функции <code>file_double</code>. Для того, чтобы эту функцию
можно было сочетать с остальным кодом, она <em>не должна</em> паниковать, если какие-либо
из перечисленных выше ошибок действительно произойдут. Фактически, это
означает, что функция должна <em>возвращать ошибку</em>, если любая из возможных
операций завершилась неудачей. Проблема состоит в том, что тип возвращаемого
значения сейчас <code>i32</code>, который не дает нам никакого разумного способа сообщить
об ошибке. Таким образом, мы должны начать с изменения типа возвращаемого
значения с <code>i32</code> на что-то другое.</p>
<p>Первое, что мы должны решить: какой из типов использовать: <code>Option</code> или
<code>Result</code>? Мы, конечно, могли бы с легкостью использовать <code>Option</code>. Если
какая-либо из трех ошибок происходит, мы могли бы просто вернуть <code>None</code>. Это
будет работать, и <em>это лучше, чем просто паниковать</em>, но мы можем сделать
гораздо лучше. Вместо этого, мы будем сообщать некоторые детали о возникшей
проблеме. Поскольку мы хотим выразить <em>возможность ошибки</em>, мы должны
использовать <code>Result&lt;i32, E&gt;</code>. Но каким должен быть тип <code>E</code>? Поскольку может
возникнуть два <em>разных</em> типа ошибок, мы должны преобразовать их к общему типу.
Одним из таких типов является <code>String</code>. Давайте посмотрим, как это отразится на
нашем коде:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre>
<p>Выглядит немного запутанно. Может потребоваться довольно много практики,
прежде вы сможете писать такое. Написание кода в таком стиле называется
<em>следованием за типом</em>. Когда мы изменили тип возвращаемого значения
<code>file_double</code> на <code>Result&lt;i32, String&gt;</code>, нам пришлось начать подбирать
правильные комбинатороы. В данном случае мы использовали только три различных
комбинатора: <code>and_then</code>, <code>map</code> и <code>map_err</code>.</p>
<p>Комбинатор <code>and_then</code> используется для объединения по цепочке нескольких
вычислений, где каждое вычисление может вернуть ошибку. После открытия файла
есть еще два вычисления, которые могут завершиться неудачей: чтение из файла и
преобразование содержимого в число. Соответственно, имеем два вызова <code>and_then</code>.</p>
<p>Комбинатор <code>map</code> используется, чтобы применить функцию к значению <code>Ok(...)</code>
типа <code>Result</code>. Например, в самом последнем вызове, <code>map</code> умножает значение
<code>Ok(...)</code> (типа <code>i32</code>) на <code>2</code>. Если ошибка произошла до этого
момента, эта операция была бы пропущена. Это следует из определения <code>map</code>.</p>
<p>Комбинатор <code>map_err</code> — это уловка, которая позволяют всему этому заработать.
Этот комбинатор, такой же, как и <code>map</code>, за исключением того, что применяет
функцию к <code>Err(...)</code> значению <code>Result</code>. В данном случае мы хотим привести
все наши ошибки к одному типу — <code>String</code>. Поскольку как <code>io::Error</code>, так и
<code>num::ParseIntError</code> реализуют <code>ToString</code>, мы можем вызвать метод <code>to_string</code>,
чтобы выполнить преобразование.</p>
<p>Не смотря на все сказанное, код по-прежнему выглядит запутанным. Мастерство
использования комбинаторов является важным, но у них есть свои недостатки.
Давайте попробуем другой подход: преждевременный возврат.</p>
<p><a name="early-returns"></a></p>
<h2>Преждевременный <code>return</code></h2>
<p>Давайте возьмем код из предыдущего раздела и перепишем его с применением
<em>раннего возврата</em>. Ранний <code>return</code> позволяет выйти из функции досрочно. Мы не
можем выполнить <code>return</code> для <code>file_double</code> внутри замыкания, поэтому нам
необходимо вернуться к явному вариативному анализу.</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre>
<p>Кто-то может обосновано не согласиться с тем, что этот код лучше,
чем тот, который использует комбинаторы, но если вы не знакомы с комбинаторами,
на мой взгляд, этот код будет выглядеть проще. Он выполняет явный вариативный
анализ с помощью <code>match</code> и <code>if let</code>. Если происходит ошибка, мы просто
прекращаем выполнение функции и возвращаем ошибку (после преобразования
в строку).</p>
<p>Разве это не шаг назад? Ранее мы говорили, что ключ к удобной обработке ошибок
— сокращение явного вариативного анализа, но здесь мы вернулись к тому, с чего
начинали. Оказывается, существует <em>несколько</em> способов его уменьшения.
И комбинаторы — не единственный путь.</p>
<p><a name="the-try-macro"></a></p>
<h2>Макрос <code>try!</code></h2>
<p>Краеугольный камень обработки ошибок в Rust — это макрос <code>try!</code>. Этот макрос
абстрагирует анализ вариантов так же, как и комбинаторы, но в отличие от них,
он также абстрагирует <em>поток выполнения</em>. А именно, он умеет абстрагировать
идею <em>досрочного возврата</em>, которую мы только что реализовали.</p>
<p>Вот упрощенное определение макроса `try!:</p>
<p><a name="code-try-def-simple"></a></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>(<a href="http://doc.rust-lang.org/std/macro.try!.html">Реальное определение</a> выглядит немного сложнее. Мы
обсудим это далее).</p>
<p>Использование макроса <code>try!</code> может очень легко упростить наш последний
пример. Поскольку он выполняет анализ вариантов и досрочной возврат из функции,
мы получаем более плотный код, который легче читать:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre>
<p>Вызов <code>map_err</code> по-прежнему необходим, учитывая
[наше определение <code>try!</code>](#code-try-def-simple), поскольку ошибки все еще
должны быть преобразованы в <code>String</code>. Хорошей новостью является то, что в
ближайшее время мы узнаем, как убрать все эти вызовы <code>map_err</code>! Плохая новость
состоит в том, что для этого нам придется кое-что узнать о паре важных типажей
из стандартной библиотеки.</p>
<p><a name="defining-your-own-error-type"></a></p>
<h2>Объявление собственного типа ошибки</h2>
<p>Прежде чем мы погрузимся в аспекты некоторых типажей из стандартной библиотеки,
связанных с ошибками, я бы хотел завершить этот раздел отказом от использования
<code>String</code> как типа ошибки в наших примерах.</p>
<p>Использование <code>String</code> в том стиле, в котором мы использовали его в предыдущих
примерах удобно потому, что достаточно легко конвертировать любые ошибки в
строки, или даже создавать свои собственные ошибки на ходу. Тем не менее,
использование типа <code>String</code> для ошибок имеет некоторые недостатки.</p>
<p>Первый недостаток в том, что сообщения об ошибках, как правило, загромождают
код. Можно определять сообщения об ошибках в другом месте, но это поможет
только если вы необыкновенно дисциплинированны, поскольку очень заманчиво
вставлять сообщения об ошибках прямо в код. На самом деле, мы именно этим и
занимались в <a href="#code-error-double-string">предыдущем примере</a>.</p>
<p>Второй и более важный недостаток заключается в том, что использование <code>String</code>
чревато <em>потерей информации</em>. Другими словами, если все ошибки будут
преобразованы в строки, то когда мы будем возвращать их вызывающей стороне, они
не будут иметь никакого смысла. Единственное разумное, что вызывающая сторона
может сделать с ошибкой типа <code>String</code> — это показать ее пользователю.
Безусловно, можно проверить строку по значению, чтобы определить тип ошибки, но
такой подход не может похвастаться надежностью. (Правда, в гораздо большей
степени это недостаток для библиотек, чем для конечных приложений).</p>
<p>Например, тип <code>io::Error</code> включает в себя тип
[<code>io::ErrorKind</code>](http://doc.rust-lang.org/std/io/enum.ErrorKind.html), который является
<em>структурированными данными</em>, представляющими то, что пошло не так во время
выполнения операции ввода-вывода. Это важно, поскольку может возникнуть
необходимость по-разному реагировать на различные причины ошибки. (Например,
ошибка <code>BrokenPipe</code> может изящно завершать программу, в то время как ошибка
<code>NotFound</code> будет завершать программу с кодом ошибки и показывать соответствующее
сообщение пользователю.) Благодаря <code>io::ErrorKind</code>, вызывающая сторона может
исследовать тип ошибки с помощью вариативного анализа, и это значительно лучше
попытки вычленить детали об ошибке из <code>String</code>.</p>
<p>Вместо того, чтобы использовать <code>String</code> как тип ошибки в нашем предыдущем
примере про чтение числа из файла, мы можем определить свой собственный тип,
который представляет ошибку в виде <em>структурированных данных</em>. Мы постараемся
не потерять никакую информацию от изначальных ошибок на тот случай, если
вызывающая сторона захочет исследовать детали.</p>
<p>Идеальным способом представления <em>одного варианта из многих</em> является
определение нашего собственного типа-суммы с помощью <code>enum</code>. В нашем случае,
ошибка представляет собой либо <code>io::Error</code>, либо <code>num::ParseIntError</code>, из чего
естественным образом вытекает определение:</p>
<pre><code class="language-rust">use std::io;
use std::num;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>Осталось только немного подогнать наш код из примера. Вместо преобразования
ошибок в строки, мы будем просто конвертировать их в наш тип <code>CliError</code>,
используя соответствующий конструктор значения:</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {:?}&quot;, err),
    }
}
</code></pre>
<p>Единственное изменение здесь — замена вызова <code>map_err(|e| e.to_string())</code>
(который преобразовывал ошибки в строки) на <code>map_err(CliError::Io)</code> или
<code>map_err(CliError::Parse)</code>. Теперь <em>вызывающая сторона</em> определяет уровень
детализации сообщения об ошибке для конечного пользователя. В действительности,
использование <code>String</code> как типа ошибки лишает вызывающего возможности
выбора, в то время использование собственного типа <code>enum</code>, на подобие
<code>CliError</code>, дает вызывающему тот же уровень удобства, который был ранее, и
кроме этого <em>структурированные данные</em>, описывающие ошибку.</p>
<p>Практическое правило заключается в том, что необходимо определять свой
собственный тип ошибки, а тип <code>String</code> для ошибок использовать в крайнем случае,
в основном когда вы пишете конечное приложение. Если вы пишете библиотеку,
определение своего собственного типа ошибки наиболее предпочтительно. Таким
образом, вы не лишите пользователя вашей библиотеки возможности выбирать
наиболее предпочтительное для его конкретного случая поведение.</p>
<p><a name="standard-library-traits-used-for-error-handling"></a></p>
<h1>Типажи из стандартной библиотеки, используемые для обработки ошибок</h1>
<p>Стандартная библиотека определяет два встроенных типажа, полезных для
обработки ошибок [<code>std::error::Error</code>](http://doc.rust-lang.org/std/error/trait.Error.html) и
[<code>std::convert::From</code>](http://doc.rust-lang.org/std/convert/trait.From.html). И если <code>Error</code>
разработан специально для создания общего описания ошибки, то типаж <code>From</code>
играет широкую роль в преобразовании значений между различными типами.</p>
<p><a name="the-error-trait"></a></p>
<h2>Типаж <code>Error</code></h2>
<p>Типаж <code>Error</code>
<a href="http://doc.rust-lang.org/std/error/trait.Error.html">объявлен в стандартной библиотеке</a>:</p>
<pre><code class="language-rust">use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&amp;self) -&gt; &amp;str;

  /// The lower level cause of this error, if any.
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
}
</code></pre>
<p>Этот типаж очень обобщенный, поскольку предполагается, что он должен быть
реализован для <em>всех</em> типов, которые представляют собой ошибки. Как мы увидим
дальше, он нам очень пригодится для написания сочетаемого кода. Этот типаж,
как минимум, позволяет выполнять следующие вещи:</p>
<ul>
<li>Получать строковое представление ошибки для разработчика (<code>Debug</code>).</li>
<li>Получать понятное для пользователя представление ошибки (<code>Display</code>).</li>
<li>Получать краткое описание ошибки (метод <code>description</code>).</li>
<li>Изучать по цепочке первопричину ошибки, если она существует (метод <code>cause</code>).</li>
</ul>
<p>Первые две возможности возникают в результате того, что типаж <code>Error</code> требует
в свою очередь реализации типажей <code>Debug</code> и <code>Display</code>. Последние два факта
исходят из двух методов, определенных в самом <code>Error</code>. Мощь <code>Еrror</code> заключается
в том, что все существующие типы ошибок его реализуют, что в свою очередь
означает что любые ошибки могут быть сохранены как
<a href="trait-objects.html">типажи-объекты</a> (trait
object). Обычно это выглядит как <code>Box&lt;Error&gt;</code>, либо <code>&amp;Error</code>. Например, метод
<code>cause</code> возвращает <code>&amp;Error</code>, который как раз является типажом-объектом. Позже мы
вернемся к применению <code>Error</code> как типажа-объекта.</p>
<p>В настоящее время достаточно показать пример, реализующий типаж <code>Error</code>.
Давайте воспользуемся для этого типом ошибки, который мы определили в
<a href="#defining-your-own-error-type">предыдущем разделе</a>:</p>
<pre><code class="language-rust">use std::io;
use std::num;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>Данный тип ошибки отражает возможность возникновения двух других типов ошибок:
ошибка работы с IО или ошибка преобразования строки в число. Определение ошибки может
отражать столько других видов ошибок, сколько необходимо, за счет добавления
новых вариантов в объявлении <code>enum</code>.</p>
<p>Реализация <code>Error</code> довольно прямолинейна и главным образом состоит из явного
анализа вариантов:</p>
<pre><code class="language-rust,ignore">use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            // Оба изначальных типа ошибок уже реализуют `Display`,
            // так что мы можем использовать их реализации
            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
        }
    }
}

impl error::Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        // Оба изначальных типа ошибок уже реализуют `Error`,
        // так что мы можем использовать их реализацией
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Parse(ref err) =&gt; err.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            // В обоих случаях просходит неявное преобразование значения `err`
            // из конкретного типа (`&amp;io::Error` или `&amp;num::ParseIntError`)
            // в типаж-обьект `&amp;Error`. Это работает потому что оба типа реализуют `Error`.
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
        }
    }
}
</code></pre>
<p>Хочется отметить, что это очень типичная реализация <code>Error</code>: реализация
методов <code>description</code> и <code>cause</code> в соответствии с каждым возможным видом ошибки.</p>
<p><a name="the-from-trait"></a></p>
<h2>Типаж <code>From</code></h2>
<p>Типаж <code>std::convert::From</code> объявлен в
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">стандартной библиотеке</a>:</p>
<p><a name="code-from-def"></a></p>
<pre><code class="language-rust">trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
</code></pre>
<p>Очень просто, не правда ли? Типаж <code>From</code> чрезвычайно полезен, поскольку
создает общий подход для преобразования <em>из</em> определенного типа <code>Т</code> в какой-то
другой тип (в данном случае, &quot;другим типом&quot; является тип, реализующий данный
типаж, или <code>Self</code>). Самое важное в типаже <code>From</code> — <a href="http://doc.rust-lang.org/std/convert/trait.From.html">множество его реализаций,
предоставляемых стандартной библиотекой</a>.</p>
<p>Вот несколько простых примеров, демонстрирующих работу <code>From</code>:</p>
<pre><code class="language-rust">let string: String = From::from(&quot;foo&quot;);
let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);
let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);
</code></pre>
<p>Итак, <code>From</code> полезен для выполнения преобразований между строками. Но как
насчет ошибок? Оказывается, существует одна важная реализация:</p>
<pre><code class="language-rust,ignore">impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;
</code></pre>
<p>Эта реализация говорит, что <em>любой</em> тип, который реализует <code>Error</code>, можно
конвертировать в типаж-объект <code>Box&lt;Error&gt;</code>. Выглядит не слишком впечатляюще, но
это очень полезно в общем контексте.</p>
<p>Помните те две ошибки, с которыми мы имели дело ранее, а именно, <code>io::Error</code>
and <code>num::ParseIntError</code>? Поскольку обе они реализуют <code>Error</code>, они также
работают с <code>From</code>:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs;
use std::io;
use std::num;

// Получаем значения ошибок
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();

// Собственно, конвертация
let err1: Box&lt;Error&gt; = From::from(io_err);
let err2: Box&lt;Error&gt; = From::from(parse_err);
</code></pre>
<p>Здесь нужно разобрать очень важный паттерн. Переменные <code>err1</code> и <code>err2</code> имеют
<em>одинаковый тип</em> — типаж-объект. Это означает, что их реальные типы
скрыты от компилятора, так что по факту он рассматривает <code>err1</code> и <code>err2</code> как
одинаковые сущности. Кроме того, мы создали <code>err1</code> и <code>err2</code>, используя один и
тот же вызов функции — <code>From::from</code>. Мы можем так делать, поскольку функция
<code>From::from</code> перегружена по ее аргументу и возвращаемому типу.</p>
<p>Эта возможность очень важна для нас, поскольку она решает нашу предыдущую
проблему, позволяя эффективно конвертировать разные ошибки в один и тот же тип,
пользуясь только одной функцией.</p>
<p>Настало время вернуться к нашему старому другу — макросу <code>try!</code>.</p>
<p><a name="the-real-try-macro"></a></p>
<h2>Настоящий макрос <code>try!</code></h2>
<p>До этого мы привели такое определение <code>try!</code>:</p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>Но это не настоящее определение. Реальное определение можно найти
в <a href="http://doc.rust-lang.org/std/macro.try!.html">стандартной библиотеке</a>:</p>
<p><a name="code-try-def"></a></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}
</code></pre>
<p>Здесь есть одно маленькое, но очень важное изменение: значение ошибки
пропускается через вызов <code>From::from</code>. Это делает макрос <code>try!</code> очень мощным
инструментом, поскольку он дает нам возможность бесплатно выполнять
автоматическое преобразование типов.</p>
<p>Вооружившись более мощным макросом <code>try!</code>, давайте взглянем на код, написанный
нами ранее, который читает файл и конвертирует его содержимое в число:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}
</code></pre>
<p>Ранее мы говорили, что мы можем избавиться от вызовов <code>map_err</code>. На самом деле,
все что мы должны для этого сделать — это найти тип, который работает с
<code>From</code>. Как мы увидели в предыдущем разделе, <code>From</code> имеет реализацию, которая
позволяет преобразовать любой тип ошибки в <code>Box&lt;Error&gt;</code>:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}
</code></pre>
<p>Мы уже очень близки к идеальной обработке ошибок. Наш код имеет очень мало
накладных расходов из-за обработки ошибок, ведь макрос <code>try!</code> инкапсулирует
сразу три вещи:</p>
<ol>
<li>Вариативный анализ.</li>
<li>Поток выполнения.</li>
<li>Преобразование типов ошибок.</li>
</ol>
<p>Когда все эти три вещи объединены вместе, мы получаем код, который не
обременен комбинаторами, вызовами <code>unwrap</code> или постоянным анализом вариантов.</p>
<p>Но осталась одна маленькая деталь: тип <code>Box&lt;Error&gt;</code> <em>не несет никакой
информации</em>. Если мы возвращаем <code>Box&lt;Error&gt;</code> вызывающей стороне, нет никакой
возможности (легко) узнать базовый тип ошибки. Ситуация, конечно, лучше, чем
со <code>String</code>, посольку появилась возможность вызывать методы, вроде
[<code>description</code>](http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description) или
[<code>cause</code>](http://doc.rust-lang.org/std/error/trait.Error.html#method.cause), но ограничение
остается: <code>Box&lt;Error&gt;</code> не предоставляет никакой информации о сути ошибки. (Замечание:
Это не совсем верно, поскольку в Rust есть инструменты рефлексии во время
выполнения, которые полезны при некоторых сценариях, но их рассмотрение
<a href="https://crates.io/crates/error">выходит за рамки этой главы</a>).</p>
<p>Настало время вернуться к нашему собственному типу <code>CliError</code> и связать все
в одно целое.</p>
<p><a name="composing-custom-error-types"></a></p>
<h2>Совмещение собственных типов ошибок</h2>
<p>В последнем разделе мы рассмотрели реальный макрос <code>try!</code> и то, как он
выполняет автоматическое преобразование значений ошибок с помощью вызова
<code>From::from</code>. В нашем случае мы конвертировали ошибки в <code>Box&lt;Error&gt;</code>, который
работает, но его значение скрыто для вызывающей стороны.</p>
<p>Чтобы исправить это, мы используем средство, с которым мы уже знакомы:
создание собственного типа ошибки. Давайте вспомним код, который считывает
содержимое файла и преобразует его в целое число:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
</code></pre>
<p>Обратите внимание, что здесь у нас еще остались вызовы <code>map_err</code>. Почему?
Вспомните определения [<code>try!</code>](#code-try-def) и [<code>From</code>](#code-from-def).
Проблема в том, что не существует такой реализации <code>From</code>, которая позволяет
конвертировать типы ошибок <code>io::Error</code> и <code>num::ParseIntError</code> в наш собственный
тип <code>CliError</code>. Но мы можем легко это исправить! Поскольку мы определили тип
<code>CliError</code>, мы можем также реализовать для него типаж <code>From</code>:</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(io::Error), Parse(num::ParseIntError) }
use std::io;
use std::num;

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
</code></pre>
<p>Все эти реализации позволяют <code>From</code> создавать значения <code>CliError</code> из других
типов ошибок. В нашем случае такое создание состоит из простого вызова
конструктора значения. <em>Как правило</em>, это все что нужно.</p>
<p>Наконец, мы можем переписать <code>file_double</code>:</p>
<pre><code class="language-rust"># use std::io;
# use std::num;
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
# impl From&lt;io::Error&gt; for CliError {
#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
# }
# impl From&lt;num::ParseIntError&gt; for CliError {
#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
# }

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
</code></pre>
<p>Единственное, что мы сделали — это удалили вызовы <code>map_err</code>. Они нам больше не
нужны, поскольку макрос <code>try!</code> выполняет <code>From::from</code> над значениями ошибок. И
это работает, поскольку мы предоставили реализации <code>From</code> для всех типов
ошибок, которые могут возникнуть.</p>
<p>Если бы мы изменили нашу функцию <code>file_double</code> таким образом, чтобы она начала
выполнять какие-то другие операции, например, преобразовать строку в число
с плавающей точкой, то мы должны были бы добавить новый вариант к нашему типу
ошибок:</p>
<pre><code class="language-rust">use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
</code></pre>
<p>И добавить новую реализацию для <code>From</code>:</p>
<pre><code class="language-rust"># enum CliError {
#     Io(::std::io::Error),
#     ParseInt(num::ParseIntError),
#     ParseFloat(num::ParseFloatError),
# }

use std::num;

impl From&lt;num::ParseFloatError&gt; for CliError {
    fn from(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
</code></pre>
<p>Вот и все!</p>
<p><a name="advice-for-library-writers"></a></p>
<h2>Рекомендации для авторов библиотек</h2>
<p>Если в вашей библиотеке могут возникать специфические ошибки, то вы наверняка
должны определить для них свой собственный тип. На ваше усмотрение вы можете
сделать его внутреннее представление публичным (как
[<code>ErrorKind</code>](http://doc.rust-lang.org/std/io/enum.ErrorKind.html)), или оставить его скрытым
(подобно [<code>ParseIntError</code>](http://doc.rust-lang.org/std/num/struct.ParseIntError.html)). Независимо
от того, что вы предпримете, считается хорошим тоном обеспечить по крайней
мере некоторую информацию об ошибке помимо ее строкового представления. Но,
конечно, все зависит от конкретных случаев использования.</p>
<p>Как минимум, вы скорее всего должны реализовать типаж
[<code>Error</code>](http://doc.rust-lang.org/std/error/trait.Error.html). Это даст пользователям вашей
библиотеки некоторую минимальную гибкость при
<a href="#the-real-try-macro">совмещении ошибок</a>. Реализация типажа <code>Error</code> также
означает, что пользователям гарантируется возможность получения строкового
представления ошибки (это следует из необходимости реализации <code>fmt::Debug</code> и
<code>fmt::Display</code>).</p>
<p>Кроме того, может быть полезным реализовать <code>From</code> для ваших типов ошибок. Это
позволит вам (как автору библиотеки) и вашим пользователям
<a href="#composing-custom-error-types">совмещать более детальные ошибки</a>. Например,
[<code>csv::Error</code>](http://burntsushi.net/rustdoc/csv/enum.Error.html) реализует
<code>From</code> для <code>io::Error</code> и <code>byteorder::Error</code>.</p>
<p>Наконец, на свое усмотрение, вы также можете определить
[псевдоним типа <code>Result</code>](#the-result-type-alias-idiom), особенно, если в вашей
библиотеке определен только один тип ошибки. Такой подход используется в
стандартной библиотеке для [<code>io::Result</code>](http://doc.rust-lang.org/std/io/type.Result.html) и
[<code>fmt::Result</code>](http://doc.rust-lang.org/std/fmt/type.Result.html).</p>
<p><a name="the-short-story"></a></p>
<h1>Заключение</h1>
<p>Поскольку это довольно длинная глава, не будет лишним составить короткий
конспект по обработке ошибок в Rust. Ниже будут приведены некоторые практические
рекомендации. Это совсем <em>не</em> заповеди. Наверняка существуют веские
причины для того, чтобы нарушить любое из этих правил.</p>
<ul>
<li>Если вы пишете короткий пример кода, который может быть перегружен обработкой
ошибок, это, вероятно, отличная возможность использовать <code>unwrap</code> (будь-то
[<code>Result::unwrap</code>](http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap),
[<code>Option::unwrap</code>](http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap) или
[<code>Option::expect</code>](http://doc.rust-lang.org/std/option/enum.Option.html#method.expect)).
Те, для кого предназначен пример, должны осознавать, что необходимо
реализовать надлежащую обработку ошибок. (Если нет, отправляйте их сюда!)</li>
<li>Если вы пишете одноразовую программу, также не зазорно использовать <code>unwrap</code>.
Но будьте внимательны: если ваш код попадет в чужие руки, не удивляйтесь, если
кто-то будет расстроен из-за скудных сообщений об ошибках!</li>
<li>Если вы пишете одноразовый код, но вам все-равно стыдно из-за использования
<code>unwrap</code>, воспользуйтесь либо <code>String</code> в качестве типа ошибки, либо
<code>Box&lt;Error + Send + Sync&gt;</code> (из-за
[доступных реализаций <code>From</code>](http://doc.rust-lang.org/std/convert/trait.From.html).)</li>
<li>В остальных случаях, определяйте свои собственные типы ошибок с
соответствующими реализациями [<code>From</code>](http://doc.rust-lang.org/std/convert/trait.From.html) и
[<code>Error</code>](http://doc.rust-lang.org/std/error/trait.Error.html), делая использование
[<code>try!</code>](http://doc.rust-lang.org/std/macro.try!.html) более удобным.</li>
<li>Если вы пишете библиотеку и ваш код может выдавать ошибки, определите ваш
собственный тип ошибки и реализуйте типаж
[<code>std::error::Error</code>](http://doc.rust-lang.org/std/error/trait.Error.html). Там, где это уместно,
реализуйте [<code>From</code>](http://doc.rust-lang.org/std/convert/trait.From.html), чтобы вам и вашим
пользователям было легче с ними работать. (Из-за правил когерентности в Rust,
пользователи вашей библиотеки не смогут реализовать <code>From</code> для ваших ошибок,
поэтому это должна сделать ваша библиотека.)</li>
<li>Изучите комбинаторы, определенные для
[<code>Option</code>](http://doc.rust-lang.org/std/option/enum.Option.html) и
[<code>Result</code>](http://doc.rust-lang.org/std/result/enum.Result.html). Писать код, пользуясь только ними
может быть немного утомительно, но я лично нашел для себя хороший баланс
между использованием <code>try!</code> и комбинаторами (<code>and_then</code>, <code>map</code> и <code>unwrap_or</code>
— мои любимые).</li>
</ul>
<h1>Выбор гарантий</h1>
<p>Одна из важных черт языка Rust — это то, что он позволяет нам управлять
накладными расходами и гарантиями программы.</p>
<p>В стандартной библиотеке Rust есть различные «обёрточные типы», которые
реализуют множество компромиссов между накладными расходами, эргономикой, и
гарантиями. Многие позволяют выбирать между проверками во время компиляции и
проверками во время исполнения. Эта глава подробно объяснит несколько избранных
абстракций.</p>
<p>Перед тем, как продолжить, крайне рекомендуем познакомиться с
<a href="ownership.html">владением</a> и <a href="references-and-borrowing.html">заимствованием</a> в Rust.</p>
<h1>Основные типы указателей</h1>
<h2><code>Box&lt;T&gt;</code></h2>
<p>[<code>Box&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html">box</a> — «владеющий» указатель, или, по-другому, «упаковка». Хотя он и
может выдавать ссылки на содержащиеся в нём данные, он — единственный владелец
этих данных. В частности, когда происходит что-то вроде этого:</p>
<pre><code class="language-rust">let x = Box::new(1);
let y = x;
// x больше не доступен
</code></pre>
<p>Здесь упаковка была <em>перемещена</em> в <code>y</code>. Поскольку <code>x</code> больше не владеет ею, с
этого момента компилятор не позволит использовать <code>x</code>. Упаковка также может быть
перемещена <em>из</em> функции — для этого функция возвращает её как свой результат.</p>
<p>Когда упаковка, которая не была перемещена, выходит из области видимости,
выполняются деструкторы. Эти деструкторы освобождают содержащиеся данные.</p>
<p>Мы абстрагируемся от динамического выделения памяти, и это абстракция без
накладных расходов. Это идеальный способ выделить память в куче и безопасно
передавать указатель на эту память. Заметьте, что вы можете создавать ссылки на
упаковку по обычным правилам заимствования, которые проверяются во время
компиляции.</p>
<h2><code>&amp;T</code> и <code>&amp;mut T</code></h2>
<p>Это неизменяемые и изменяемые ссылки, соответственно. Они реализуют шаблон
«read-write lock», т.е. вы можете создать или одну изменяемую ссылку на данные,
или любое число неизменяемых, но не оба вида ссылок одновременно. Эта гарантия
проверяется во время компиляции, и ничего не стоит во время исполнения. В
большинстве случаев эти два типа указателей покрывают все нужды по передаче
дешёвых ссылок между частями кода.</p>
<p>При копировании эти указатели сохраняют связанное с ними время жизни — они всё
равно не могут прожить дольше, чем исходное значение, на которое они ссылаются.</p>
<h2><code>*const T</code> и <code>*mut T</code></h2>
<p>Это сырые указатели в стиле C, не имеющие связанной информации о времени жизни и
владельце. Они просто указывают на какое-то место в памяти, без дополнительных
ограничений. Они гарантируют только то, что они могут быть разыменованы только в
коде, помеченном как «небезопасный».</p>
<p>Они полезны при создании безопасных низкоуровневых абстракций вроде <code>Vec&lt;T&gt;</code>, но
их следует избегать в безопасном коде.</p>
<h2><code>Rc&lt;T&gt;</code></h2>
<p>Это первая рассматриваемая обёртка, использование которой влечёт за собой
накладные расходы во время исполнения.</p>
<p>[<code>Rc&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html">rc</a> — это указатель со счётчиком ссылок. Другими словами, он позволяет
создавать несколько «владеющих» указателей на одни и те же данные, и эти данные
будут уничтожены, когда все указатели выйдут из области видимости.</p>
<p>Собственно, внутри у него счётчик ссылок (reference count, или сокращённо
refcount), который увеличивается каждый раз, когда происходит клонирование <code>Rc</code>,
и уменьшается когда <code>Rc</code> выходит из области видимости. Основная ответственность
<code>Rc&lt;T&gt;</code> — удостовериться в том, что для разделяемых данных вызываются
деструкторы.</p>
<p>Хранимые данные при этом неизменяемы, и если создаётся цикл ссылок, данные
утекут. Если нам нужно отсутствие утечек в присутствие циклов, нужно
использовать сборщик мусора.</p>
<h4>Гарантии</h4>
<p>Здесь главная гарантия в том, что данные не будут уничтожены, пока все ссылки на
них не исчезнут.</p>
<p>Счётчик ссылок нужно использовать, когда мы хотим динамически выделить какие-то
данные и предоставить ссылки на эти данные только для чтения, и при этом неясно,
какая часть программы последней закончит использование ссылки. Это подходящая
альтернатива <code>&amp;T</code>, когда невозможно статически доказать правильность <code>&amp;T</code>, или
когда это создаёт слишком большие неудобства в написании кода, на который
разработчик не хочет тратить своё время.</p>
<p>Этот указатель <em>не</em> является потокобезопасным, и Rust не позволяет передавать
его или делиться им с другими потоками. Это позволяет избежать накладных
расходов от использования атомарных операций там, где они не нужны.</p>
<p>Есть похожий умный указатель, <code>Weak&lt;T&gt;</code>. Это невладеющий, но и не заимствуемый,
умный указатель. Он тоже похож на <code>&amp;T</code>, но не ограничен временем жизни —
<code>Weak&lt;T&gt;</code> можно не отпускать. Однако, возможна ситуация, когда попытка доступа к
хранимым в нём данным провалится и вернёт <code>None</code>, поскольку <code>Weak&lt;T&gt;</code> может
пережить владеющие <code>Rc</code>. Его удобно использовать в случае циклических структур
данных и некоторых других.</p>
<h4>Накладные расходы</h4>
<p>Что касается памяти, <code>Rc&lt;T&gt;</code> — это одно выделение, однако оно будет включать
два лишних слова (т.е. два значения типа <code>usize</code>) по сравнению с обычным
<code>Box&lt;T&gt;</code>. Это верно и для «сильных», и для «слабых» счётчиков ссылок.</p>
<p>Расходы на <code>Rc&lt;T&gt;</code> заключаются в увеличении и уменьшении счётчика ссылок каждый
раз, когда <code>Rc&lt;T&gt;</code> клонируется или выходит из области видимости, соответственно.
Отметим, что клонирование не выполняет глубокое копирование, а просто
увеличивает счётчик и возвращает копию <code>Rc&lt;T&gt;</code>.</p>
<h1>Типы-ячейки (cell types)</h1>
<p>Типы <code>Cell</code> предоставляют «внутреннюю» изменяемость. Другими словами, они
содержат данные, которые можно изменять даже если тип не может быть получен в
изменяемом виде (например, когда он за указателем <code>&amp;</code> или за <code>Rc&lt;T&gt;</code>).</p>
<p><a href="https://doc.rust-lang.org/stable/std/cell/">Документация модуля <code>cell</code> довольно хорошо объясняет эти вещи</a>.</p>
<p>Эти типы <em>обычно</em> используют в полях структур, но они не ограничены таким
использованием.</p>
<h2><code>Cell&lt;T&gt;</code></h2>
<p>[<code>Cell&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html">cell</a> — это тип, который обеспечивает внутреннюю изменяемость без
накладных расходов, но только для типов, реализующих типаж <code>Copy</code>. Поскольку
компилятор знает, что все данные, вложенные в <code>Cell&lt;T&gt;</code>, находятся на стеке, их
можно просто заменять без страха утечки ресурсов.</p>
<p>Нарушить инварианты с помощью этой обёртки всё равно можно, поэтому будьте
осторожны при её использовании. Если поле обёрнуто в <code>Cell</code>, это индикатор того,
что эти данные изменяемы и поле может не сохранить своё значение с момента
чтения до момента его использования.</p>
<pre><code class="language-rust">use std::cell::Cell;

let x = Cell::new(1);
let y = &amp;x;
let z = &amp;x;
x.set(2);
y.set(3);
z.set(4);
println!(&quot;{}&quot;, x.get());
</code></pre>
<p>Заметьте, что здесь мы смогли изменить значение через различные ссылки без права
изменения.</p>
<p>В плане затрат во время исполнения, такой код аналогичен нижеследующему:</p>
<pre><code class="language-rust,ignore">let mut x = 1;
let y = &amp;mut x;
let z = &amp;mut x;
x = 2;
*y = 3;
*z = 4;
println!(&quot;{}&quot;, x);
</code></pre>
<p>но имеет преимущество в том, что он действительно компилируется.</p>
<h4>Гарантии</h4>
<p>Этот тип ослабляет правило отсутствия совпадающих указателей с правом записи
там, где оно не нужно. Однако, он также ослабляет гарантии, которые
предоставляет такое ограничение; поэтому если ваши инварианты зависят от данных,
хранимых в <code>Cell</code>, будьте осторожны.</p>
<p>Это применяется при изменении примитивов и других типов, реализующих <code>Copy</code>,
когда нет лёгкого способа сделать это в соответствии с статическими правилами
<code>&amp;</code> и <code>&amp;mut</code>.</p>
<p><code>Cell</code> не позволяет получать внутрение ссылки на данные, что позволяет безопасно
менять его содержимое.</p>
<h4>Накладные расходы</h4>
<p>Накладные расходы при использовании <code>Cell&lt;T&gt;</code> отсутствуют, однако если вы
оборачиваете в него большие структуры, есть смысл вместо этого обернуть
отдельные поля, поскольку иначе каждая запись будет производить полное
копирование структуры.</p>
<h2><code>RefCell&lt;T&gt;</code></h2>
<p>[<code>RefCell&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html">refcell</a> также предоставляет внутреннюю изменяемость, но не
ограничен только типами, реализующими <code>Copy</code>.</p>
<p>Однако, у этого решения есть накладные расходы. <code>RefCell&lt;T&gt;</code> реализует шаблон
«read-write lock» во время исполнения, а не во время компиляции, как <code>&amp;T</code>/
<code>&amp;mut T</code>. Он похож на однопоточный мьютекс. У него есть функции <code>borrow()</code> и
<code>borrow_mut()</code>, которые изменяют внутрений счётчик ссылок и возвращают умный
указатель, который может быть разыменован без права изменения или с ним,
соответственно. Счётчик ссылок восстанавливается, когда умные указатели выходят
из области видимости. С этой системой мы можем динамически гарантировать, что во
время заимствования с правом изменения никаких других ссылок на значение больше
нет. Если программист пытается позаимствовать значение в этот момент, поток
запаникует.</p>
<pre><code class="language-rust">use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!(&quot;{:?}&quot;, *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
</code></pre>
<p>Как и <code>Cell</code>, это в основном применяется в ситуациях, когда сложно или
невозможно удовлетворить статическую проверку заимствования. В целом мы знаем,
что такие изменения не будут происходить вложенным образом, но это стоит
дополнительно проверить.</p>
<p>Для больших, сложных программ, есть смысл положить некоторые вещи в <code>RefCell</code>,
чтобы упростить работу с ними. Например, многие словари в структуре <code>ctxt</code><a href="../rustc/middle/ty/struct.ctxt.html">ctxt</a>
в компиляторе Rust обёрнуты в этот тип. Они изменяются только однажды — во
время создания, но не во время инициализации, или несколько раз в явно отдельных
местах. Однако, поскольку эта структура повсеместно используется везде,
жонглирование изменяемыми и неизменяемыми указателями было бы очень сложным (или
невозможным), и наверняка создало бы мешанину указателей <code>&amp;</code>, которую сложно
было бы расширять. С другой стороны, <code>RefCell</code> предоставляет дешёвый (но не
бесплатный) способ обращаться к таким данным. В будущем, если кто-то добавит
код, который пытается изменить ячейку, пока она заимствована, это вызывет
панику, источник которой можно отследить. И такая паника обычно происходит
детерминированно.</p>
<p>Похожим образом, в DOM Servo много изменения данных, большая часть которого
происходит внутри типа DOM, но часть выходит за его границы и изменяет
произвольные вещи. Использование <code>RefCell</code> и <code>Cell</code> для ограждения этих
изменений позволяет нам избежать необходимости беспокоиться об изменяемости
везде, и одновременно обозначает места, где изменение <em>действительно</em>
происходит.</p>
<p>Заметьте, что стоит избегать использования <code>RefCell</code>, если возможно достаточно
простое решение с помощью указателей <code>&amp;</code>.</p>
<h4>Гарантии</h4>
<p><code>RefCell</code> ослабляет <em>статические</em> ограничения, предотвращающие совпадение
изменяемых указателей, и заменяет их на <em>динамические</em> ограничения. Сами
гарантии при этом не изменяются.</p>
<h4>Накладные расходы</h4>
<p><code>RefCell</code> не выделяет память, но содержит дополнительный индикатор «состояния
заимствования» (размером в одно слово) вместе с данными.</p>
<p>Во время исполнения каждое заимствование вызывает изменение и проверку счётчика
ссылок.</p>
<h1>Синхронизированные типы</h1>
<p>Многие из вышеперечисленных типов не могут быть использованы потокобезопасным
образом. В частности, <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>, оба из которых используют
не-атомарные счётчики ссылок, не могут быть использованы так. (<em>Атомарные</em>
счётчики ссылок — это такие, которые могут быть увеличены из нескольких
потоков, не вызывая при этом гонку данных.) Благодаря этому они привносят меньше
накладных расходов, но нам также потребуются и потокобезопасные варианты этих
типов. Они существуют — это <code>Arc&lt;T&gt;</code> и <code>Mutex&lt;T&gt;</code>/<code>RWLock&lt;T&gt;</code>.</p>
<p>Заметьте, что не-потокобезопасные типы <em>не могут</em> быть переданы между потоками,
и это проверяется во время компиляции.</p>
<p>В модуле <a href="https://doc.rust-lang.org/stable/std/sync/index.html">sync</a> много полезных обёрточных типов для многопоточного
программирования, но мы затронем только главные из них.</p>
<h2><code>Arc&lt;T&gt;</code></h2>
<p>[<code>Arc&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html">arc</a> — это вариант <code>Rc&lt;T&gt;</code>, который использует атомарный счётчик
ссылок (поэтому «Arc»). Его можно свободно передавать между потоками.</p>
<p><code>shared_ptr</code> из C++ похож на <code>Arc</code>, но в случае C++ вложенные данные всегда
изменяемы. Чтобы получить семантику, похожую на семантику C++, нужно
использовать <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, или <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code>[^4].
(<code>UnsafeCell&lt;T&gt;</code> — это тип-ячейка, который может содержать любые данные и не
имеет накладных расходов, но доступ к его содержимому производится только внутри
небезопасных блоков.) Последний стоит использовать только тогда, когда мы
уверены в том, что наша работа не вызывет нарушения безопасности памяти.
Учитывайте, что запись в структуру не атомарна, а многие функции вроде
<code>vec.push()</code> могут выделять память заново в процессе работы, и тем самым
вызывать небезопасное поведение.</p>
<p>[^4]: На самом деле, <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> не скомпилируется, поскольку
<code>UnsafeCell&lt;T&gt;</code> не реализует <code>Send</code> или <code>Sync</code>, но мы можем обернуть его в
тип и реализовать для него <code>Send</code>/<code>Sync</code> вручную, чтобы получить
<code>Arc&lt;Wrapper&lt;T&gt;&gt;</code>, где <code>Wrapper</code> — это <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.</p>
<h4>Гарантии</h4>
<p>Как и <code>Rc</code>, этот тип гарантирует, что деструктор хранимых в нём данных будет
вызван, когда последний <code>Arc</code> выходит из области видимости (за исключением
случаев с циклами). В отличие от <code>Rc</code>, <code>Arc</code> предоставляет эту гарантию и в
многопоточном окружении.</p>
<h4>Накладные расходы</h4>
<p>Накладные расходы увеличиваются по сравнению с <code>Rc</code>, т.к. теперь для изменения
счётчика ссылок используются атомарные операции (которые происходят каждый раз
при клонировании или выходе из области видимости). Когда вы хотите поделиться
данными в пределах одного потока, предпочтительнее использовать простые ссылки
<code>&amp;</code>.</p>
<h2><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></h2>
<p>[<code>Mutex&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html">mutex</a> и [<code>RwLock&lt;T&gt;</code>]<a href="https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html">rwlock</a> предоставляют механизм
взаимоисключения с помощью охранных значений RAII. Охранные значения — это
объекты, имеющие некоторое состояние, как замок, пока не выполнится их
деструктор. В обоих случаях, мьютекс непрозрачен, пока на нём не вызовут
<code>lock()</code>, после чего поток остановится до момента, когда мьютекс может быть
закрыт, после чего возвращается охранное значение. Оно может быть использовано
для доступа к вложенным данным с правом изменения, а мьютекс будет снова открыт,
когда охранное значение выйдет из области видимости.</p>
<pre><code class="language-rust,ignore">{
    let guard = mutex.lock();
    // охранное значение разыменовывается в изменяемое значение
    // вложенного в мьютекс типа
    *guard += 1;
} // мьютекс открывается когда выполняется деструктор
</code></pre>
<p><code>RwLock</code> имеет преимущество — он эффективно работает в случае множественных
чтений. Ведь читать из общих данных всегда безопасно, пока в эти данные никто не
хочет писать; и <code>RwLock</code> позволяет читающим получить «право чтения». Право
чтения может быть получено многими потоками одновременно, и за читающими следит
счётчик ссылок. Тот же, кто хочет записать данные, должен получить «право
записи», а оно может быть получено только когда все читающие вышли из области
видимости.</p>
<h4>Гарантии</h4>
<p>Оба этих типа предоставляют безопасное изменение данных из разных потоков, но не
защищают от взаимной блокировки (deadlock). Некоторая дополнительная
безопасность протокола работы с данными может быть получена с помощью системы
типов.</p>
<h4>Накладные расходы</h4>
<p>Для поддержания состояния прав чтения и записи эти типы используют в своей
реализации конструкции, похожие на атомарные типы, и они довольно дороги. Они
могут блокировать все межпроцессорные чтения из памяти, пока не закончат работу.
Ожидание возможности закрытия этих примитивов синхронизации тоже может быть
медленным, когда производится много одновременных попыток доступа к данным.</p>
<h1>Сочетание</h1>
<p>Распространённая жалоба на код на Rust — это сложность чтения типов вроде
<code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (или ещё более сложных сочетаний похожих типов). Не всегда
понятно, что делает такая комбинация, или почему автор решил использовать именно
такой тип. Не ясно и то, в каких случаях сам программист должен использовать
похожие сочетания типов.</p>
<p>Обычно, вам понадобятся такие типы, когда вы хотите сочетать гарантии разных
типов, но не хотите переплачивать за то, что вам не нужно.</p>
<p>Например, одно из таких сочетаний — это <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>. Сам по себе <code>Rc&lt;T&gt;</code>
не может быть разыменован с правом изменения; поскольку <code>Rc&lt;T&gt;</code> позволяет
делиться данными и одновременная попытка изменения данных может привести к
небезопасному поведению, мы кладём внутрь <code>RefCell&lt;T&gt;</code>, чтобы получить
динамическую проверку одновременных попыток изменения. Теперь у нас есть
разделяемые изменяемые данные, но одновременный доступ к ним предоставляется
только на чтение, а запись всегда исключительна.</p>
<p>Далее мы можем развить эту мысль и получить <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> или
<code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. Это — изменяемые, разделяемые между потоками вектора,
но они не одинаковы.</p>
<p>В первом типе <code>RefCell&lt;T&gt;</code> оборачивает <code>Vec&lt;T&gt;</code>, поэтому изменяем весь <code>Vec&lt;T&gt;</code>
целиком. В то же время, это значит, что в каждый момент времени может быть
только одна ссылка на <code>Vec&lt;T&gt;</code> с правом изменения. Поэтому код не может
одновременно работать с разными элементами вектора, обращаясь к ним через разные
<code>Rc</code>. Однако, мы сможем добавлять и удалять элементы вектора в произвольные
моменты времени. Этот тип похож на <code>&amp;mut Vec&lt;T&gt;</code>, с тем различием, что проверка
заимствования делается во время исполнения.</p>
<p>Во втором типе заимствуются отдельные элементы, а вектор в целом неизменяем.
Поэтому мы можем получить ссылки на отдельные элементы, но не можем добавлять
или удалять элементы. Это похоже на <code>&amp;mut [T]</code>[^3], но, опять-таки, проверка
заимствования производится во время исполнения.</p>
<p>В многопоточных программах возникает похожая ситуация с <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, который
обеспечивает разделяемое владение и одновременное изменение.</p>
<p>Когда вы читаете такой код, рассматривайте гарантии и накладные расходы каждого
вложенного типа шаг за шагом.</p>
<p>Когда вы выбираете сложный тип, поступайте наоборот: решите, какие гарантии вам
нужны, и в каком «слое» сочетания они понадобятся. Например, если у вас стоит
выбор между <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> и <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, найдите компромисс путём
рассуждений, как мы делали выше по тексту, и выберите нужный вам тип.</p>
<p>[^3]: <code>&amp;[T]</code> и <code>&amp;mut [T]</code> — это <em>срезы</em>; они состоят из указателя и длины, и
могут ссылаться на часть вектора или массива. <code>&amp;mut [T]</code> также позволяет
изменять свои элементы, но его длину изменить нельзя.</p>
<h1>Интерфейс внешних функций (foreign function interface)</h1>
<h1>Введение</h1>
<p>В данном руководстве в качестве примера мы будем использовать
<a href="https://github.com/google/snappy">snappy</a>, библиотеку для сжатия/распаковки
данных. Мы реализуем Rust-интерфейс к этой библиотеке через вызов внешних
функций. Rust в настоящее время не в состоянии делать вызовы напрямую в
библиотеки C++, но snappy включает в себя интерфейс C (документирован в
[<code>snappy-c.h</code>](https://github.com/google/snappy/blob/master/snappy-c.h)).</p>
<p>Ниже приведен минимальный пример вызова внешней функции, который будет
скомпилирован при условии, что библиотека snappy установлена:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!(&quot;максимальный размер сжатого буфера длиной 100 байт: {}&quot;, x);
}
</code></pre>
<p>Блок <code>extern</code> содержит список сигнатур функций из внешней библиотеки, в данном
случае для C ABI (application binary interface; двоичный интерфейс приложений)
данной платформы. Чтобы указать, что программу нужно компоновать с библиотекой
snappy, используется атрибут <code>#[link(...)]</code>. Благодаря этому, символы будут
успешно разрешены.</p>
<p>Предполагается, что внешние функции могут быть небезопасными, поэтому их вызовы
должны быть обёрнуты в блок <code>unsafe {}</code> как обещание компилятору, что все внутри
этого блока в действительности безопасно. Библиотеки C часто предоставляют
интерфейсы, которые не являются потоко-безопасными. И почти любая функция,
которая принимает в качестве аргумента указатель, не может принимать любое
входное значений, поскольку указатель может быть висячим; сырые указатели
выходят за пределы безопасной модели памяти в Rust.</p>
<p>При объявлении типов аргументов для внешней функции, компилятор Rust не может
проверить, является ли данное объявление корректным. Поэтому важно правильно
указать тип привязываемой функции — иначе ошибка обнаружится только во время
исполнения.</p>
<p>Блок <code>extern</code> может быть распространён на весь API snappy:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::{c_int, size_t};

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
# fn main() {}
</code></pre>
<h1>Создание безопасного интерфейса</h1>
<p>Сырой C API (application programming interface; интерфейс программирования
приложений) необходимо обернуть, чтобы обеспечить безопасность памяти. Тогда мы
сможем использовать концепции более высокого уровня, такие как векторы.
Библиотека может выборочно открывать только безопасный, высокоуровневый
интерфейс и скрывать небезопасные внутренние детали.</p>
<p>Оборачивание функций, которые принимают в качестве входных параметров буферы,
включает в себя использование модуля <code>slice::raw</code> для управления векторами Rust
как указателями на память. Векторы Rust представляют собой гарантированно
непрерывный блок памяти. Длина — это количество элементов, которое в настоящее
время содержится в векторе, а ёмкость — общее количество выделенной памяти в
элементах. Длина меньше или равна ёмкости.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{c_int, size_t};
# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}
</code></pre>
<p>Обёртка <code>validate_compressed_buffer</code> использует блок <code>unsafe</code>, но это
гарантирует, что её вызов будет безопасен для всех входных данных, поскольку
модификатор <code>unsafe</code> отсутствует в сигнатуре функции. Т.е. небезопасность скрыта
внутри функции и не видна вызывающему.</p>
<p>Функции <code>snappy_compress</code> и <code>snappy_uncompress</code> являются более сложными, так как
должен быть выделен буфер для хранения выходных данных.</p>
<p>Функция <code>snappy_max_compressed_length</code> может быть использована для выделения
вектора максимальной ёмкости, требуемой для хранения сжатых выходных данных.
Затем этот вектор может быть передан в функцию <code>snappy_compress</code> в качестве
выходного параметра. Ещё один параметр передается, чтобы получить настоящую
длину после сжатия и установить соответствующую длину вектора.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
#                           d: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
# fn main() {}
pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}
</code></pre>
<p>Распаковка аналогична, потому что snappy хранит размер несжатых данных как часть
формата сжатия, и <code>snappy_uncompressed_length</code> будет возвращать точный размер
необходимого буфера.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_uncompress(compressed: *const u8,
#                             compressed_length: size_t,
#                             uncompressed: *mut u8,
#                             uncompressed_length: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_uncompressed_length(compressed: *const u8,
#                                      compressed_length: size_t,
#                                      result: *mut size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}
</code></pre>
<p>Для справки, примеры, используемые здесь, также доступны в библиотеке на
<a href="https://github.com/thestinger/rust-snappy">GitHub</a>.</p>
<h1>Деструкторы</h1>
<p>Внешние библиотеки часто передают владение ресурсами в вызывающий код. Когда это
происходит, мы должны использовать деструкторы Rust, чтобы обеспечить
безопасность и гарантировать освобождение этих ресурсов (особенно в случае
паники).</p>
<p>Чтобы получить более подробную информацию о деструкторах, смотрите
<a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">типаж Drop</a>.</p>
<h1>Обратные вызовы функций Rust кодом на C (Callbacks from C code to Rust</h1>
<h1>functions)</h1>
<p>Некоторые внешние библиотеки требуют использование обратных вызовов для передачи
вызывающей стороне отчета о своем текущем состоянии или промежуточных данных. Во
внешнюю библиотеку можно передавать функции, которые были определены в Rust. При
создании функции обратного вызова, которую можно вызывать из C кода, необходимо
указать для нее спецификатор <code>extern</code>, за котороым следует подходящее соглашение
о вызове.</p>
<p>Затем функция обратного вызова может быть передана в библиотеку C через
регистрационный вызов, и уже затем может быть вызвана оттуда.</p>
<p>Простой пример:</p>
<p>Код на Rust:</p>
<pre><code class="language-no_run">extern fn callback(a: i32) {
    println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Активация функции обратного вызова
    }
}
</code></pre>
<p>Код на C:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Вызовет callback(7) в Rust
}
</code></pre>
<p>В этом примере функция <code>main()</code> в Rust вызовет функцию <code>trigger_callback()</code> в C,
которая, в свою очередь, выполнит обратный вызов функции <code>callback()</code> в Rust.</p>
<h2>Обратные вызовы, адресованные объектам Rust (Targeting callbacks to Rust</h2>
<h2>objects)</h2>
<p>Предыдущий пример показал, как глобальная функция может быть вызвана из C кода.
Однако зачастую желательно, чтобы обратный вызов был адресован конкретному
объекту в Rust. Это может быть объект, который представляет собой обертку для
соответствующего объекта C.</p>
<p>Такое поведение может быть достигнуто путем передачи небезопасного указателя на
объект в библиотеку C. После чего библиотека C сможет передавать указатель на
объект Rust при обратном вызове. Это позволит получить небезопасный доступ к
объекту Rust, на которой сослались в обратном вызове.</p>
<p>Код на Rust:</p>
<pre><code class="language-no_run">#[repr(C)]
struct RustObject {
    a: i32,
    // другие поля
}

extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
    println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
    unsafe {
        // Меняем значение в RustObject на значение, полученное через функцию обратного вызова
        (*target).a = a;
    }
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // Создаём объект, на который будем ссылаться в функции обратного вызова
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}
</code></pre>
<p>Код на C:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Вызовет callback(&amp;rustObject, 7) в Rust
}
</code></pre>
<h2>Асинхронные обратные вызовы</h2>
<p>В приведённых примерах обратные вызовы выполняются как непосредственная реакция
на вызов функции внешней библиотеки на C. Для выполнения обратного вызова поток
исполнения переключался из Rust в C, а затем снова в Rust, но, в конце концов,
обратный вызов выполнялся в том же потоке, из которого была вызвана функция,
инициировавшая обратный вызов.</p>
<p>Более сложная ситуация — это когда внешняя библиотека порождает свои собственные
потоки и осуществляет обратные вызовы из них. В этих случаях доступ к структурам
данных Rust из обратных вызовов особенно опасен, и поэтому нужно использовать
соответствующие механизмы синхронизации. Помимо классических механизмов
синхронизации, таких как мьютексы, в Rust есть еще одна возможность:
использовать каналы (<code>std::sync::mpsc::channel</code>), чтобы направить данные из
потока C, который выполнял обратный вызов, в поток Rust.</p>
<p>Если асинхронный обратный вызов адресован конкретному объекту в адресном
пространстве Rust, то необходимо, чтобы обратные вызовы не выполнялись
библиотекой C после уничтожения этого объекта Rust. Для этого следует,
во-первых, проектировать библиотеку таким образом, чтобы отмена регистрации
обратного вызова гарантировала, что он больше не будет выполняться. Во-вторых,
нужно отменить регистрацию обратного вызова в деструкторе объекта Rust, которому
адресован обратный вызов.</p>
<h1>Компоновка</h1>
<p>Атрибут <code>link</code> для блоков <code>extern</code> предоставляет <code>rustc</code> основные инструкции
относительно того, как он должен компоновать нативные библиотеки. На данный
момент есть две общепринятых формы записи атрибута <code>link</code>:</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>В обоих этих случаях <code>foo</code> — это имя нативной библиотеки, с которой мы
компонуемся. Во втором случае <code>bar</code> — это тип нативной библиотеки, с которой
происходит компоновка. В настоящее время <code>rustc</code> известны три типа нативных
библиотек:</p>
<ul>
<li>Динамические — <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>Статические — <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>Фреймворки — <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>Обратите внимание, что фреймворки доступны только для OSX.</p>
<p>Различные значения <code>kind</code> нужны, чтобы определить, как компоновать нативную
библиотеку. С точки зрения компоновки, компилятор Rust создает две разновидности
артефактов: промежуточный (rlib/статическая библиотека) и конечный (динамическая
библиотека/исполняемый файл). (Прим. переводчика: rlib — это формат статической
библиотеки с метаданными в формате Rust) Зависимости от нативных динамических
библиотек и фреймворков распространяются дальше, пока не дойдут до конечного
артефакта, а от статических библиотек — нет.</p>
<p>Вот несколько примеров того, как эта модель может быть использована:</p>
<ul>
<li>
<p>Нативная зависимость при сборке. Иногда написанный на Rust код необходимо
состыковать с некоторым кодом на C/C++, но распространение C/C++ кода в формате
библиотеки вызывает дополнительные трудности. В этом случае, код будут
упакован в <code>libfoo.a</code>, а затем контейнер Rust должен будет объявить
зависимость с помощью <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</p>
<p>Независимо от типа результата (промежуточный или конечный) контейнера,
нативная статическая библиотека будет включена в него на выходе, поэтому нет
необходимости в распространении этой нативной статической библиотеки отдельно.</p>
</li>
<li>
<p>Обычная динамическая зависимость. Общие системные библиотеки (такие, как
<code>readline</code>) доступны на большом количестве систем, и статическую копию этих
библиотек часто сложно найти. Когда такая зависимость включена в контейнер
Rust, промежуточные артефакты (например, rlib'ы) не будут компоноваться с
библиотекой, но когда rlib включается в состав конечного артефакта (например,
исполняемый файл), нативная библиотека будет прикомпонована.</p>
</li>
</ul>
<p>На OSX, фреймворки ведут себя так же, как и динамические библиотеки.</p>
<h1>Небезопасные блоки</h1>
<p>Некоторые операции, такие как разыменование небезопасных указателей или вызов
функций, которые были отмечены как небезопасные, разрешено использовать только
внутри небезопасных блоков. Небезопасные блоки изолируют опасные ситуации и дают
гарантии компилятору, что опасности не вытекут за пределы блока.</p>
<p>Небезопасные функции же, наоборот, показывают свою опасность всем. Небезопасная
функция записывается в виде:</p>
<pre><code class="language-rust">unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
</code></pre>
<p>Эта функция может быть вызвана только из блока <code>unsafe</code> или из другой <code>unsafe</code>
функции.</p>
<h1>Доступ к внешним глобальным переменным</h1>
<p>Внешние API довольно часто экспортируют глобальные переменные, которые могут
быть использованы, например, для отслеживания глобального состояния. Для того,
чтобы получить доступ к этим переменным, нужно объявить их в блоке <code>extern</code>,
используя ключевое слово <code>static</code>:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

#[link(name = &quot;readline&quot;)]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!(&quot;You have readline version {} installed.&quot;,
             rl_readline_version as i32);
}
</code></pre>
<p>Кроме того, возможно, вам потребуется изменить глобальное состояние,
предоставленное внешним интерфейсом. Для этого при объявлении статических
переменных может быть добавлен модификатор <code>mut</code>, чтобы была возможность
изменять их.</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!(&quot;{:?}&quot;, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</code></pre>
<p>Обратите внимание, что любое взаимодействие с <code>static mut</code> небезопасно — как
чтение, так и запись. Работа с изменяемым глобальным состоянием требует
значительно большей осторожности.</p>
<p><a name="foreign-calling-conventions"></a></p>
<h1>Соглашение о вызове внешних функций</h1>
<p>Большинство внешнего кода предоставляет C ABI. И Rust при вызове внешних функций
по умолчанию использует соглашение о вызове C для данной платформы. Но некоторые
внешние функции, в первую очередь Windows API, используют другое соглашение о
вызове. Rust обеспечивает способ указать компилятору, какое именно соглашение
использовать:</p>
<pre><code class="language-rust"># #![feature(libc)]
extern crate libc;

#[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]
#[link(name = &quot;kernel32&quot;)]
#[allow(non_snake_case)]
extern &quot;stdcall&quot; {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
# fn main() { }
</code></pre>
<p>Это указание относится ко всему блоку <code>extern</code>. Вот список поддерживаемых
ограничений для ABI:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
</ul>
<p>Большинство ABI в этом списке не требуют пояснений, но ABI <code>system</code> может
показаться немного странным. Он выбирает такое ABI, которое подходит для
взаимодействия с нативными библиотеками данной платформы. Например, на платформе
win32 с архитектурой x86, это означает, что будет использован ABI <code>stdcall</code>.
Однако, на windows x86_64 используется соглашение о вызове <code>C</code>, поэтому в этом
случае будет использован <code>C</code> ABI. Это означает, что в нашем предыдущем примере
мы могли бы использовать <code>extern &quot;system&quot; { ... }</code>, чтобы определить блок для
всех windows систем, а не только для x86.</p>
<h1>Взаимодействие с внешним кодом</h1>
<p>Rust гарантирует, что размещение полей <code>struct</code> совместимо с представлением в C
только в том случае, если к ней применяется атрибут <code>#[repr(C)]</code>. Атрибут
<code>#[repr(C, packed)]</code> может быть использован для размещения полей структуры без
выравнивания. Атрибут <code>#[repr(C)]</code> также может быть применен и к перечислениям.</p>
<p>Владеющие упаковки в Rust (<code>Box&lt;T&gt;</code>) используют указатели, не допускающие
нулевое значение (non-nullable), как дескрипторы содержащихся в них объектов.
Тем не менее, эти дескрипторы не должны создаваться вручную, так как они
управляются внутренними средствами выделения памяти. Ссылки можно без риска
считать ненулевыми указателями непосредствено на тип. Однако нарушение правил
проверки заимствования или изменяемости может быть небезопасным. Но компилятор
не может сделать так много предположений о сырых указателях. Например, он не
полагается на настоящую неизменяемость данных под неизменяемым сырым указателем.
Поэтому используйте сырые указатели (<code>*</code>), если вам необходимо намеренно
нарушить правила (но так, что при этом всё работает). Это нужно, чтобы
компилятор «случайно» не предположил относительно ссылок чего-то, что мы
собираемся нарушать (возможно, нам нужны несколько указателей с правом
изменения, что не допускается обычными ссылками).</p>
<p>Векторы и строки совместно используют одну и ту же базовую cхему размещения
памяти и утилиты, доступные в модулях <code>vec</code> и <code>str</code>, для работы с C API. Однако,
строки не завершаются нулевым байтом, <code>\0</code>. Если вам нужна строка, завершающаяся
нулевым байтом, для совместимости с C, вы должны использовать тип <code>CString</code> из
модуля <code>std::ffi</code>.</p>
<p>Стандартная библиотека включает в себя псевдонимы типов и определения функций
для стандартной библиотеки C в модуле <code>libc</code>, и Rust компонует <code>libc</code> и <code>libm</code>
по умолчанию.</p>
<h1>Оптимизация указателей, допускающих нулевое значение</h1>
<h1>(The nullable pointer optimization)</h1>
<p>Некоторые типы по определению не могут быть <code>null</code>. Это ссылки (<code>&amp;T</code>, <code>&amp;mut T</code>),
упаковки (<code>Box&lt;T&gt;</code>), указатели на функции (<code>extern &quot;abi&quot; fn()</code>). При
взаимодействии же с С часто используются указатели, которые могут быть <code>null</code>.
Как особый случай — обобщенный <code>enum</code>, который содержит ровно два варианта, один
из которых не содержит данных, а другой содержит одно поле. Такое использование
перечисления имеет право на «оптимизацию указателя, допускающего нулевое
значение». Когда создан экземпляр такого перечисления с одним из не-обнуляемых
типов, то он представляет собой ненулевой указатель для варианта, содержащего
данные, и нулевой — для варианта без данных. Таким образом, <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> — это представление указателя на функцию, допускающего
нулевое значение, и совместимого с C ABI.</p>
<h1>Вызов кода на Rust из кода на C</h1>
<p>Вы можете скомпилировать код на Rust таким образом, чтобы он мог быть вызван из
кода на C. Это довольно легко, но требует нескольких вещей:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &quot;Hello, world!\0&quot;.as_ptr()
}
# fn main() {}
</code></pre>
<p><code>extern</code> указывает, что эта функцию придерживается соглашения о вызове C, как
описано выше в разделе
«<a href="ffi.html#foreign-calling-conventions">Соглашение о вызове внешних функций</a>».
Атрибут <code>no_mangle</code> выключает изменение имён, применяемое в Rust, чтобы было
легче компоноваться с этим кодом.</p>
<h1>Типажи <code>Borrow</code> и <code>AsRef</code></h1>
<p>Типажи [<code>Borrow</code>]<a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html">borrow</a> и [<code>AsRef</code>]<a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html">asref</a> очень похожи, но в то же время
отличаются. Ниже приводится небольшая памятка об этих двух типажах.</p>
<h1>Типаж Borrow</h1>
<p>Типаж <code>Borrow</code> используется, когда вы пишете структуру данных и хотите
использовать владение и заимствование типа как синонимы.</p>
<p>Например, [<code>HashMap</code>]<a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html">hashmap</a> имеет метод [<code>get</code>]<a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get">get</a>, который использует
<code>Borrow</code>:</p>
<pre><code class="language-rust,ignore">fn get&lt;Q: ?Sized&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where K: Borrow&lt;Q&gt;,
          Q: Hash + Eq
</code></pre>
<p>Эта сигнатура является довольно сложной. Параметр <code>K</code> — это то, что нас здесь
интересует. Он ссылается на параметр самого <code>HashMap</code>:</p>
<pre><code class="language-rust,ignore">struct HashMap&lt;K, V, S = RandomState&gt; {
</code></pre>
<p>Параметр <code>K</code> представляет собой тип <em>ключа</em>, который использует <code>HashMap</code>.
Взглянем на сигнатуру <code>get()</code> еще раз. Использовать <code>get()</code> возможно, когда ключ
реализует <code>Borrow&lt;Q&gt;</code>. Таким образом, мы можем сделать <code>HashMap</code>, который
использует ключи <code>String</code>, но использовать <code>&amp;str</code>, когда мы выполняем поиск:</p>
<pre><code class="language-rust">use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;Foo&quot;.to_string(), 42);

assert_eq!(map.get(&quot;Foo&quot;), Some(&amp;42));
</code></pre>
<p>Это возможно, так как стандартная библиотека содержит <code>impl Borrow&lt;str&gt; for String</code>.</p>
<p>Для большинства типов, когда вы хотите получить право собственности или
позаимствовать значений, достаточно использовать просто <code>&amp;T</code>. <code>Borrow</code> же
становится полезен, когда есть более одного вида занимаемого значения. Это
особенно верно для ссылок и срезов: у вас может быть как <code>&amp;T</code>, так и <code>&amp;mut T</code>.
Если мы хотим принимать оба этих типа, <code>Borrow</code> как раз для этого подходит:</p>
<pre><code class="language-rust">use std::borrow::Borrow;
use std::fmt::Display;

fn foo&lt;T: Borrow&lt;i32&gt; + Display&gt;(a: T) {
    println!(&quot;a заимствовано: {}&quot;, a);
}

let mut i = 5;

foo(&amp;i);
foo(&amp;mut i);
</code></pre>
<p>Это выведет <code>a заимствовано: 5</code> дважды.</p>
<h1>Типаж AsRef</h1>
<p>Типаж <code>AsRef</code> является преобразующим типажом. Он используется в обобщённом коде
для преобразования некоторого значения в ссылку. Например:</p>
<pre><code class="language-rust">let s = &quot;Hello&quot;.to_string();

fn foo&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    let slice = s.as_ref();
}
</code></pre>
<h1>Что в каком случае следует использовать?</h1>
<p>Мы видим, что они вроде одинаковы: имеют дело с владением и заимствованием
значения некоторого типа. Тем не менее, эти типажи немного отличаются.</p>
<p>Используйте <code>Borrow</code>, когда вы хотите абстрагироваться от различных видов
заимствований, или когда вы строите структуру данных, которая использует
владеющие и заимствованные значения как эквивалентные. Например, это может
пригодиться в хэшировании и сравнении.</p>
<p>Используйте <code>AsRef</code>, когда вы пишете обобщённый код и хотите непосредственно
преобразовать что-либо в ссылку.</p>
<h1>Каналы сборок</h1>
<p>Проект Rust использует концепцию под названием «каналы сборок» для управления
сборками. Важно понять этот процесс, чтобы выбрать, какую версию Rust
использовать в вашем проекте.</p>
<h1>Обзор</h1>
<p>Есть три канала сборок Rust:</p>
<ul>
<li>Ночной (Nightly)</li>
<li>Бета (Beta)</li>
<li>Стабильный (Stable)</li>
</ul>
<p>Новые ночные сборки создаются раз в день. Каждые шесть недель последняя ночная
сборка переводится в канал «бета». С этого момента она будет получать только
исправления серьёзных ошибок. Шесть недель спустя бета сборка переводится в
канал «стабильный» и становится очередной стабильной сборкой <code>1.x</code>.</p>
<p>Этот процесс происходит параллельно. Так, каждые шесть недель, в один и тот же
день, ночная сборка превращается в бета сборку, а бета сборка превращается в
стабильную сборку. Это произойдёт одновременно: стабильная сборка получит версию
<code>1.x</code>, бета сборка получит версию <code>1.(x + 1)-beta</code>, а ночная сборка станет
первой версией <code>1.(x + 2)-nightly</code>.</p>
<h1>Выбор версии</h1>
<p>Вообще говоря, если у вас нет особых причин, вы должны использовать канал
стабильных сборок. Эти сборки предназначены для широкой аудитории.</p>
<p>Однако, в зависимости от ваших интересов к Rust, вы можете вместо этого выбрать
ночную сборку. Основной компромисс заключается в следующем: при выборе канала
ночных сборок, вы можете использовать неустойчивые, новые возможности Rust. Тем
не менее, нестабильные возможности могут быть изменены, и поэтому любая новая
ночная сборка может сломать ваш код. Если же вы выберете стабильную сборку, то
не сможете использовать экспериментальные возможности, но следующий релиз Rust
не вызовет существенных проблем с критическими изменениями.</p>
<h1>Помощь экосистеме с помощью непрерывной интеграции</h1>
<p>А что насчёт бета канала? Мы призываем всех пользователей Rust, которые
используют канал стабильных сборок, также протестировать работу с использованием
бета канала в их системах непрерывной интеграции. Это поможет предупредить
команду в случае возникновения неожиданных регрессий.</p>
<p>Кроме того, тестирование работы с использованием ночного канала может выявить
регрессии даже раньше, а поэтому, если вас не затруднит создание трех сборок, мы
будем признательны тестированию работы с использованием всех трех каналов.</p>
<h1>Синтаксис и семантика</h1>
<p>Эта часть разбита на небольшие главы, каждая из которых описывает определённое
понятие Rust.</p>
<p>Если вы хотите изучить Rust «от и до», продолжайте чтение данной части по
порядку - вы на верном пути!</p>
<p>Эти главы также являются справочником понятий, так что если при чтении другого
материала вам будет что-то непонятно, вы всегда сможете найти объяснение здесь.</p>
<h1>Связывание имён</h1>
<p>Любая реальная программа на Rust посложнее, чем «Hello World», использует
<em>связывание имён</em>. Это выглядит так:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre>
<p>Все операции, производимые ниже, будут происходить в функции <code>main()</code>, так как
каждый раз вставлять в примеры <code>fn main() {</code> немного утомляет. Убедитесь, что
примеры, приведённые в этом разделе, вы вводите в функцию <code>main()</code>, иначе можете
получить ошибку при компиляции.</p>
<p>Во многих языках программирования это называется <em>переменной</em>. Но у связывания
переменных в Rust есть пара трюков в рукаве. В левой части выражения <code>let</code>
располагается не просто имя переменной, а &quot;<a href="patterns.html">шаблон</a>&quot;. Это значит, что
мы можем делать вещи вроде этой:</p>
<pre><code class="language-rust">let (x, y) = (1, 2);
</code></pre>
<p>После завершения этого выражения <code>x</code> будет единицей, a <code>y</code> — двойкой. Шаблоны
очень мощны, и о них написана отдельная <a href="patterns.html">глава</a>. Но на данный момент
нам не нужны эти возможности, так что мы просто будем помнить о них и пойдём
дальше.</p>
<p>Rust — статически типизированный язык программирования, и значит мы должны
указывать типы, и они будут проверяться во время компиляции. Так почему же наш
первый пример скомпилировался? В Rust есть нечто, называемое <em>выводом типов</em>.
Если Rust самостоятельно может понять, какой тип у переменной, то он не требует
указывать его.</p>
<p>Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (<code>:</code>):</p>
<pre><code class="language-rust">let x: i32 = 5;
</code></pre>
<p>Если бы мы попросили вас прочитать это вслух, вы бы сказали «<code>x</code> - это
связывание типа <code>int</code> со значением <code>пять</code>».</p>
<p>В этом случае мы указали, что <code>x</code> у нас будет 32-битным целым числом со знаком.
В Rust есть и другие целочисленные типы. Их имена начинаются с <code>i</code> для целых
чисел со знаком и с <code>u</code> для целых чисел без знака. Целые числа могут иметь
размер 8, 16, 32 и 64 бита.</p>
<p>В дальнейших примерах мы будем указывать тип в комментариях. Это будет выглядеть
вот так:</p>
<pre><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre>
<p>Обратите внимание на сходство между этим комментарием и синтаксисом, который вы
используете с <code>let</code>. Включение такого типа комментариев не является
идиоматичным для Rust, но иногда мы будем включать их для того, чтобы помочь
вам понять, какие типы будут выведены Rust.</p>
<p>По умолчанию, связывание <em>неизменяемо</em>. Этот код не скомпилируется:</p>
<pre><code class="language-rust,ignore">let x = 5;
x = 10;
</code></pre>
<p>И вы получите ошибку:</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>Если вы хотите, чтобы связывание было изменяемым, вы можете использовать
модификатор <code>mut</code>:</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
x = 10;
</code></pre>
<p>Может показаться, что незачем делать связывание неизменяемым по умолчанию. Но
вспомните, на чём в первую очередь фокусируется Rust: на безопасности. Если вы
случайно забыли указать <code>mut</code> и изменили связывание, компилятор заметит это, и
сообщит вам, что вы попытались изменить не то, что собирались. Если бы по
умолчанию связывание было изменяемым, то в приведённой выше ситуации компилятор
не сможет вам помочь. Если вы намерены изменить значение переменной, то просто
добавьте <code>mut</code>.</p>
<p>Есть и другие весомые аргументы в пользу того, чтобы по возможности избегать
изменяемого состояния, но это выходит за рамки данной книги. В общем, зачастую
вы можете избежать явных изменений, и это предпочтительнее в Rust. Тем не менее,
иногда без изменения значения просто не обойтись, так что это не запрещено.</p>
<p>Вернёмся к связыванию. Связывание переменных в Rust имеет ещё одно отличие от
других языков: оно требует инициализации перед использованием.</p>
<p>Давайте приступим к рассмотрению вышесказанного. Измените ваш файл <code>src/main.rs</code>
так, что бы он выглядел следующим образом:</p>
<pre><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hello world!&quot;);
}
</code></pre>
<p>Используйте команду <code>cargo build</code> в командной строке, чтобы собрать проект. Вы
должны получить предупреждение, но программа будет работать и будет выводить
строку «Привет, мир!»:</p>
<pre><code class="language-text">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust предупредит нас о том, что мы не используем связанную переменную, но от
того, что мы её не используем, не будет никакого вреда, поэтому это не ошибка.
Однако, всё изменится, если мы попробуем использовать <code>x</code>. Сделаем это. Измените
вашу программу так, что бы она выглядела следующим образом:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x: i32;

    println!(&quot;x имеет значение {}&quot;, x);
}
</code></pre>
<p>И попробуйте собрать проект. Вы получите ошибку:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;x имеет значение {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>
<p>Rust не позволит использовать неинициализированную переменную. Далее, поговорим
о <code>{}</code>, которые мы добавили в <code>println!</code>.</p>
<p>Если вы добавите две фигурные скобки (<code>{}</code>, иногда называемые «усами»...) в вашу
печатаемую строку, Rust истолкует это как просьбу вставки некоторого значения.
<em>Строковая интерполяция</em> — это термин в информатике, который обозначает
«вставить посреди строки». Мы добавили запятую, и затем <code>x</code>, чтобы указать, что
мы хотим вставить <code>x</code> в строку. Запятая используется для разделения параметров,
если в функцию или макрос передаётся больше одного параметра.</p>
<p>При вставке переменной в строку, Rust проверит её тип и попытается отобразить
осмысленное значение. Если вы хотите указать формат более детально, то можете
ознакомиться с <a href="http://doc.rust-lang.org/std/fmt/index.html">доступными способами форматирования строк (англ.)</a>. На
данный момент мы просто используем способ по умолчанию: печатать целые числа не
очень сложно.</p>
<h1>Функции</h1>
<p>Каждая программа на Rust имеет по крайней мере одну функцию — <code>main</code>:</p>
<pre><code class="language-rust">fn main() {
}
</code></pre>
<p>Это простейшее объявление функции. Как мы упоминали ранее, ключевое слово <code>fn</code>
объявляет функцию. За ним следует её имя, пустые круглые скобки (поскольку эта
функция не принимает аргументов), а затем тело функции, заключённое в фигурные
скобки. Вот функция <code>foo</code>:</p>
<pre><code class="language-rust">fn foo() {
}
</code></pre>
<p>Итак, что насчёт аргументов, принимаемых функцией? Вот функция, печатающая
число:</p>
<pre><code class="language-rust">fn print_number(x: i32) {
    println!(&quot;x равен: {}&quot;, x);
}
</code></pre>
<p>Вот полная программа, использующая функцию <code>print_number</code>:</p>
<pre><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x равен: {}&quot;, x);
}
</code></pre>
<p>Как видите, аргументы функций похожи на операторы <code>let</code>: вы можете объявить тип
аргумента после двоеточия.</p>
<p>Вот полная программа, которая складывает два числа и печатает их:</p>
<pre><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;сумма чисел: {}&quot;, x + y);
}
</code></pre>
<p>Аргументы разделяются запятой — и при вызове функции, и при её объявлении.</p>
<p>В отличие от <code>let</code>, вы <em>должны</em> объявлять типы аргументов функции. Этот код не
скомпилируется:</p>
<pre><code class="language-rust,ignore">fn print_sum(x, y) {
    println!(&quot;сумма чисел: {}&quot;, x + y);
}
</code></pre>
<p>Вы увидите такую ошибку:</p>
<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>
<p>Это осознанное решение при проектировании языка. Бесспорно, вывод типов во всей
программе возможен. Однако даже в Haskell считается хорошим стилем явно
документировать типы функций, хотя в этом языке и возможен полный вывод типов.
Мы считаем, что принудительное объявление типов функций при сохранении
локального вывода типов — это хороший компромисс.</p>
<p>Как насчёт возвращаемого значения? Вот функция, которая прибавляет один к
целому:</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Функции в Rust возвращают ровно одно значение, тип которого объявляется после
«стрелки». «Стрелка» представляет собой дефис (<code>-</code>), за которым следует знак
«больше» (<code>&gt;</code>). Заметьте, что в функции выше нет точки с запятой. Если бы мы
добавили её:</p>
<pre><code class="language-rust,ignore">fn add_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>мы бы получили ошибку:</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>Здесь показаны две интересные особенности Rust. Во-первых, это язык,
ориентированный на выражения, и во-вторых, смысл точки с запятой отличается от
смысла аналогичного символа в других языках с синтаксисом на основе фигурных
скобок и точки с запятой. Эти две особенности связаны.</p>
<p><a name="expressions-vs.-statements"></a></p>
<h2>Выражения и операторы</h2>
<p>Rust — в первую очередь язык, ориентированный на выражения. Есть только два типа
операторов, а всё остальное является выражением.</p>
<p>А в чём же разница? Выражение возвращает значение, в то время как оператор -
нет. Вот почему мы получаем здесь «not all control paths return a value»:
оператор <code>х + 1;</code> не возвращает значение. Есть два типа операторов в Rust:
«операторы объявления» и «операторы выражения». Все остальное — выражения.
Давайте сначала поговорим об операторах объявления.</p>
<p><em>Оператор объявления</em> — это связывание. В некоторых языках связывание переменных
может быть записано как выражение, а не только как оператор. Например, в Ruby:</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>Однако, в Rust использование <code>let</code> для связывания <em>не является</em> выражением.
Следующий код вызовет ошибку компиляции:</p>
<pre><code class="language-ignore">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>Здесь компилятор сообщил нам, что ожидал увидеть выражение, но <code>let</code> является
оператором, а не выражением.</p>
<p>Обратите внимание, что присвоение уже связанной переменной (например: <code>y = 5</code>)
является выражением, но его значение не особенно полезно. В отличие от других
языков, где результатом присваивания является присваиваемое значение (например,
<code>5</code> из предыдущего примера), в Rust значением присваивания является пустой
кортеж <code>()</code>.</p>
<pre><code class="language-rust">let mut y = 5;

let x = (y = 6);  // x будет присвоено значение `()`, а не `6`
</code></pre>
<p>Вторым типом операторов в Rust является <em>оператор выражения</em>. Его цель -
превратить любое выражение в оператор. В практическом плане, грамматика Rust
ожидает, что за операторами будут идти другие операторы. Это означает, что вы
используете точку с запятой для отделения выражений друг от друга. Rust выглядит
как многие другие языки, которые требуют использовать точку с запятой в конце
каждой строки. Вы увидите её в конце почти каждой строки кода на Rust.</p>
<p>Из-за чего мы говорим «почти»? Вы это уже видели в этом примере:</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Наша функция объявлена как возвращающая <code>i32</code>. Но если в конце есть точка с
запятой, то вместо этого функция вернёт <code>()</code>. Компилятор Rust обрабатывает эту
ситуацию и предлагает удалить точку с запятой.</p>
<h2>Досрочный возврат из функции</h2>
<p>А что насчёт досрочного возврата из функции? У нас есть для этого ключевое слово
<code>return</code>:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x;

    // дальнейший код не будет исполнен!
    x + 1
}
</code></pre>
<p><code>return</code> можно написать в последней строке тела функции, но это считается
плохим стилем:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x + 1;
}
</code></pre>
<p>Если вы никогда не работали с языком, в котором операторы являются выражениями,
предыдущее определение без <code>return</code> может показаться вам странным. Но со
временем вы просто перестанете замечать это.</p>
<h2>Расходящиеся функции</h2>
<p>Для функций, которые не возвращают управление («расходящихся»), в Rust есть
специальный синтаксис:</p>
<pre><code class="language-rust">fn diverges() -&gt; ! {
    panic!(&quot;Эта функция не возвращает управление!&quot;);
}
</code></pre>
<p><code>panic!</code> — это макрос, как и <code>println!()</code>, который мы встречали ранее. В отличие
от <code>println!()</code>, <code>panic!()</code> вызывает остановку текущего потока исполнения с
заданным сообщением.</p>
<p>Поскольку эта функция вызывает остановку исполнения, она никогда не вернёт
управление. Поэтому тип её возвращаемого значения обозначается знаком <code>!</code> и
читается как «расходится». Значение расходящейся функции может быть использовано
как значение любого типа:</p>
<pre><code class="language-should_panic"># fn diverges() -&gt; ! {
#    panic!(&quot;Эта функция никогда не выходит!&quot;);
# }
let x: i32 = diverges();
let x: String = diverges();
</code></pre>
<h1>Простые типы</h1>
<p>Язык Rust имеет несколько типов, которые считаются «простыми» («примитивными»).
Это означает, что они встроены в язык. Rust структурирован таким образом, что
стандартная библиотека также предоставляет ряд полезных типов, построенных на
базе этих простых типов, но это самые простые.</p>
<h1>Логический тип (<code>bool</code>)</h1>
<p>Rust имеет встроенный логический тип, называемый <code>bool</code>. Он может принимать два
значения, <code>true</code> и <code>false</code>:</p>
<pre><code class="language-rust">let x = true;

let y: bool = false;
</code></pre>
<p>Логические типы часто используются в [конструкции <code>if</code>]<a href="if.html">if</a>.</p>
<p>Вы можете найти больше информации о логических типах (<code>bool</code>) в <a href="http://doc.rust-lang.org/std/primitive.bool.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1>Символы (<code>char</code>)</h1>
<p>Тип <code>char</code> представляет собой одиночное скалярное значение Unicode. Вы можете
создать <code>char</code> с помощью одинарных кавычек: (<code>'</code>)</p>
<pre><code class="language-rust">let x = 'x';
let two_hearts = '💕';
</code></pre>
<p>Это означает, что в отличие от некоторых других языков, <code>char</code> в Rust
представлен не одним байтом, а четырьмя.</p>
<p>Вы можете найти больше информации о символах (<code>char</code>) в <a href="http://doc.rust-lang.org/std/primitive.char.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<p><a name="numeric-types"></a></p>
<h1>Числовые типы</h1>
<p>Rust имеет целый ряд числовых типов, разделённых на несколько категорий:
знаковые и беззнаковые, фиксированного и переменного размера, числа с плавающей
точкой и целые числа.</p>
<p>Эти типы состоят из двух частей: категория и размер. Например, <code>u16</code>
представляет собой тип без знака с размером в шестнадцать бит. Чем большим
количеством бит представлен тип, тем большее число мы можем задать.</p>
<p>Если для числового литерала не указан тип, то он будет выведен по умолчанию:</p>
<pre><code class="language-rust">let x = 42; // x имеет тип i32

let y = 1.0; // y имеет тип f64
</code></pre>
<p>Ниже представлен список различных числовых типов, со ссылками на их документацию
в стандартной библиотеке:</p>
<ul>
<li><a href="http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Давайте пройдёмся по их категориям.</p>
<h2>Знаковые и беззнаковые</h2>
<p>Целые типы бывают двух видов: знаковые и беззнаковые. Чтобы понять разницу,
давайте рассмотрим число с размером в четыре бита. Знаковые четырёхбитные числа,
позволяют хранить значения от <code>-8</code> до <code>+7</code>. Знаковые числа используют
представление «дополнение до двух» (дополнительный код). Беззнаковые
четырёхбитные числа, ввиду того что не нужно хранить отрицательные значения,
позволяют хранить значения от <code>0</code> до <code>+15</code>.</p>
<p>Беззнаковые типы используют <code>u</code> для своей категории, а знаковые типы используют
<code>i</code>. <code>i</code> означает «integer». Так, <code>u8</code> представляет собой число без знака с
размером восемь бит, а <code>i8</code> представляет собой число со знаком с размером восемь
бит.</p>
<h2>Типы фиксированного размера</h2>
<p>Типы с фиксированным размером соответственно имеют фиксированное количество бит
в своём представлении. Допустимыми размерами являются <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>.
Таким образом, <code>u32</code> представляет собой целое число без знака с размером 32
бита, а <code>i64</code> — целое число со знаком с размером 64 бита.</p>
<h2>Типы переменного размера</h2>
<p>Rust также предоставляет типы, размер которых зависит от размера указателя на
целевой машине. Эти типы имеют «size» в названии в качестве признака размера, и
могут быть знаковыми или беззнаковыми. Таким образом, существует два типа:
<code>isize</code> и <code>usize</code>.</p>
<h2>С плавающей точкой</h2>
<p>В Rust также есть два типа с плавающей точкой: <code>f32</code> и <code>f64</code>. Они соответствуют
IEEE-754 числам с плавающей точкой одинарной и двойной точности соответственно.</p>
<h1>Массивы</h1>
<p>В Rust, как и во многих других языках программирования, есть
типы-последовательности, для представления последовательностей неких вещей.
Самый простой из них — это <em>массив</em>, то есть последовательность элементов одного
и того же типа, имеющая фиксированный размер. Массивы неизменяемы по умолчанию.</p>
<pre><code class="language-rust">let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
</code></pre>
<p>Массивы имеют тип <code>[T; N]</code>. О значении <code>T</code> мы поговорим позже, когда будем
рассматривать <a href="generics.html">обобщённое программирование</a>. <code>N</code> — это константа
времени компиляции, представляющая собой длину массива.</p>
<p>Для инициализации всех элементов массива одним и тем же значением есть
специальный синтаксис. В этом примере каждый элемент <code>a</code> будет инициализирован
значением <code>0</code>:</p>
<pre><code class="language-rust">let a = [0; 20]; // a: [i32; 20]
</code></pre>
<p>Вы можете получить число элементов массива <code>a</code> с помощью метода <code>a.len()</code>:</p>
<pre><code class="language-rust">let a = [1, 2, 3];

println!(&quot;Число элементов в a: {}&quot;, a.len());
</code></pre>
<p>Вы можете получить определённый элемент массива с помощью <em>индекса</em>:</p>
<pre><code class="language-rust">let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]

println!(&quot;Второе имя: {}&quot;, names[1]);
</code></pre>
<p>Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому
мы получаем первое имя с помощью <code>names[0]</code>, а второе — с помощью <code>names[1]</code>.
Пример выше печатает <code>Второе имя: Brian</code>. Если вы попытаетесь использовать
индекс, который не входит в массив, вы получите ошибку: при доступе к массивам
происходит проверка границ во время исполнения программы. Такая ошибочная
попытка доступа — источник многих проблем в других языках системного
программирования.</p>
<p>Вы можете найти больше информации о массивах (<code>array</code>) в
<a href="http://doc.rust-lang.org/std/primitive.array.html">документации к стандартной библиотеке (англ.)</a>.</p>
<p><a name="slices"></a></p>
<h1>Срезы</h1>
<p><em>Срез</em> — это ссылка на (или «проекция» в) другую структуру данных. Они полезны,
когда нужно обеспечить безопасный, эффективный доступ к части массива без
копирования. Например, возможно вам нужно сослаться на единственную строку
файла, считанного в память. Из-за своей ссылочной природы, срезы создаются не
напрямую, а из существующих значений. У срезов есть длина, они могут быть
изменяемы или нет, и во многих случаях они ведут себя как массивы:</p>
<pre><code class="language-rust">let a = [0, 1, 2, 3, 4];
let middle = &amp;a[1..4]; // Срез `a`: только элементы 1, 2, и 3
let complete = &amp;a[..]; // Срез, содержащий все элементы массива `a`
</code></pre>
<p>Срезы имеют тип <code>&amp;[T]</code>. О значении <code>T</code> мы поговорим позже, когда будем
рассматривать <a href="generics.html">обобщённое программирование</a>.</p>
<p>Вы можете найти больше информации о срезах (<code>slice</code>) в <a href="http://doc.rust-lang.org/std/primitive.slice.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1><code>str</code></h1>
<p>Тип <code>str</code> в Rust является наиболее простым типом строк. Это
<a href="unsized-types.html">безразмерный тип</a>, поэтому сам по себе он не очень полезен, но он
становится полезным при использовании ссылки, [<code>&amp;str</code>]<a href="strings.html">strings</a>. Пока просто
остановимся на этом.</p>
<p>Вы можете найти больше информации о строках (<code>str</code>) в <a href="http://doc.rust-lang.org/std/primitive.str.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<p><a name="tuples"></a></p>
<h1>Кортежи</h1>
<p>Кортеж — это последовательность фиксированного размера. Вроде такой:</p>
<pre><code class="language-rust">let x = (1, &quot;привет&quot;);
</code></pre>
<p>Этот кортеж из двух элементов создан с помощью скобок и запятой между
элементами. Вот тот же код, но с аннотациями типов:</p>
<pre><code class="language-rust">let x: (i32, &amp;str) = (1, &quot;привет&quot;);
</code></pre>
<p>Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в
этом кортеже одновременно хранятся значения типов <code>i32</code> и <code>&amp;str</code>. В языках
системного программирования строки немного более сложны, чем в других языках.
Пока вы можете читать <code>&amp;str</code> как <em>срез строки</em>. Мы вскоре узнаем об этом больше.</p>
<p>Можно присваивать один кортеж другому, если они содержат значения одинаковых
типов и имеют одинаковую <a href="glossary.html#arity">арность</a>. Арность кортежей одинакова, когда их
длина совпадает.</p>
<pre><code class="language-rust">let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
</code></pre>
<p>Стоит отметить и ещё один момент, касающийся длины кортежей: кортеж нулевой
длины (<code>()</code>; пустой кортеж) часто называют «единичным значением».
Соответственно, тип такого значения — «единичный тип».</p>
<p>Доступ к полям кортежа можно получить с помощью <em>деконструирующего let</em>. Вот
пример:</p>
<pre><code class="language-rust">let (x, y, z) = (1, 2, 3);

println!(&quot;x это {}&quot;, x);
</code></pre>
<p>Помните, мы <a href="variable-bindings.html">говорили</a>, что левая часть оператора <code>let</code> может больше, чем
просто присваивать имена? Мы имели ввиду то, что приведено выше. Мы можем
написать слева от <code>let</code> шаблон, и, если он совпадает со значением справа,
произойдёт присваивание имён сразу нескольким значениям. В данном случае, <code>let</code>
«деконструирует» или «разбивает» кортеж, и присваивает его части трём именам.</p>
<p>Это очень удобный шаблон программирования, и мы ещё не раз увидим его.</p>
<p>Вы можете устранить неоднозначность трактовки для кортежа, состоящего из одного
элемента, и значения в скобках с помощью запятой:</p>
<pre><code class="language-rust">(0,); // одноэлементный кортеж
(0); // ноль в круглых скобках
</code></pre>
<h2>Индексация кортежей</h2>
<p>Вы также можете получить доступ к полям кортежа с помощью индексации:</p>
<pre><code class="language-rust">let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!(&quot;x is {}&quot;, x);
</code></pre>
<p>Как и в случае индексации массивов, индексы начинаются с нуля, но здесь, в
отличие от массивов, используется <code>.</code>, а не <code>[]</code>.</p>
<p>Вы можете найти больше информации о кортежах (<code>tuple</code>) в <a href="http://doc.rust-lang.org/std/primitive.tuple.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1>Функции</h1>
<p>Функции тоже имеют тип! Это выглядит следующим образом:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
</code></pre>
<p>В данном примере <code>x</code> — это «указатель на функцию», которая принимает в качестве
аргумента <code>i32</code> и возвращает <code>i32</code>.</p>
<h1>Комментарии</h1>
<p>Теперь, когда у нас есть несколько функций, неплохо бы узнать о комментариях.
Комментарии — это заметки, которые вы оставляете для других программистов, чтобы
помочь объяснить некоторые вещи в вашем коде. Компилятор в основном игнорирует
их («в основном», потому что есть документирующие комментарии и примеры в
документации).</p>
<p>В Rust есть два вида комментариев: <em>строчные комментарии</em> и <em>doc-комментарии</em>.</p>
<pre><code class="language-rust">// Строчные комментарии — это всё что угодно после '//' и до конца строки.

let x = 5; // это тоже строчный комментарий.

// Если у вас длинное объяснение для чего-либо, вы можете расположить строчные
// комментарии один за другим. Поместите пробел между '//' и вашим комментарием,
// так как это более читаемо.
</code></pre>
<p>Другое применение комментария — это doc-комментарий. Doc-комментарий использует
<code>///</code> вместо <code>//</code>, и поддерживает Markdown-разметку внутри:</p>
<pre><code class="language-rust">/// Прибавляем единицу к заданному числу.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>При написании doc-комментария очень полезно добавлять разделы для аргументов,
возвращаемых значений и привести некоторые примеры использования. Заметьте, что
здесь мы использовали новый макрос: <code>assert_eq!</code>. Он сравнивает два значения и
вызывает <code>panic!</code>, если они не равны. Для документации такие примеры очень
полезны. Так же есть и другой макрос, <code>assert!</code>, который вызывает <code>panic!</code> когда
значение равно <code>false</code>.</p>
<p>Вы можете использовать [<code>rustdoc</code>](documentation.html) для генерации HTML-
документации из этих doc-комментариев, а так же запуска кода из примеров как
тестов.</p>
<h1>Конструкция <code>if</code></h1>
<p><code>if</code> в Rust не сильно сложен и больше похож на <code>if</code> в динамически типизированных
языках, чем на более традиционный из системных. Давайте поговорим о нём, чтобы
вы поняли некоторые его нюансы.</p>
<p><code>if</code> является одной из форм более общего понятия, именуемого <em>ветвлением</em>. Это
название произошло от ветвей деревьев: конечный результат зависит от того, какой
из нескольких вариантов будет выбран.</p>
<p><code>if</code> содержит одно условие, в зависимости от которого будет выполняться одна из
двух ветвей:</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
}
</code></pre>
<p>При изменении значения <code>x</code> на какое-либо другое, эта строчка не будет выведена
на экран. Если подробнее, то когда условие будет иметь значение <code>true</code>,
следующий после него блок кода выполнится. В противном случае — нет.</p>
<p>Бывает нужно что-то выполнить, если условие не выполнится (выражение будет иметь
значение false). В таком случае можно использовать <code>else</code>:</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
} else {
    println!(&quot;x это не пять :(&quot;);
}
</code></pre>
<p>Когда необходимо больше одного выбора, можно использовать <code>else if</code>:</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
} else if x == 6 {
    println!(&quot;x это шесть!&quot;);
} else {
    println!(&quot;x это ни пять, ни шесть :(&quot;);
}
</code></pre>
<p>Всё это довольно прозаично. Однако, вы также можете сделать такую штуку:</p>
<pre><code class="language-rust">let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32
</code></pre>
<p>Которую мы можем (и должны) записать примерно следующим образом:</p>
<pre><code class="language-rust">let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
</code></pre>
<p>Это работает, потому что <code>if</code> является выражением. Его значением является
значение последнего выражения из выбранной ветви. <code>if</code> без <code>else</code> всегда
возвращает <code>()</code> в качестве значения.</p>
<h1>Циклы</h1>
<p>На данный момент в Rust есть три способа организовать циклическое исполнение
кода. Это <code>loop</code>, <code>while</code> и <code>for</code>. У каждого подхода своё применения.</p>
<h2>Циклы <code>loop</code></h2>
<p>Бесконечный цикл (<code>loop</code>) — простейшая форма цикла в Rust. С помощью этого
ключевого слова можно организовать цикл, который продолжается, пока не
выполнится какой-либо оператор, прерывающий его. Бесконечный цикл в Rust
выглядит так:</p>
<pre><code class="language-rust,ignore">loop {
    println!(&quot;Зациклились!&quot;);
}
</code></pre>
<h2>Циклы <code>while</code></h2>
<p>Цикл <code>while</code> — это ещё один вид конструкции цикла в Rust. Выглядит он так:</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
</code></pre>
<p>Он применяется, если неизвестно, сколько раз нужно выполнить тело цикла, чтобы
получить результат. При каждой итерации цикла проверяется условие, и если оно
истинно, то запускается следующая итерация. Иначе цикл <code>while</code> завершается.</p>
<p>Если вам нужен бесконечный цикл, то можете сделать условие всегда истинным:</p>
<pre><code class="language-rust,ignore">while true {
</code></pre>
<p>Однако, для такого случая в Rust имеется ключевое слово <code>loop</code>:</p>
<pre><code class="language-rust,ignore">loop {
</code></pre>
<p>В Rust анализатор потока управления обрабатывает конструкцию <code>loop</code> иначе, чем
<code>while true</code>, хотя для нас это одно и тоже. На данном этапе изучения Rust нам не
важно знать в чем именно различие между этими конструкциями, но если вы хотите
сделать бесконечный цикл, то используйте конструкцию <code>loop</code>. Компилятор
сможет транслировать ваш код в более эффективный и безопасный машинный код.</p>
<p><a name="for"></a></p>
<h2>Циклы <code>for</code></h2>
<p>Цикл <code>for</code> нужен для повторения блока кода определённое количество раз. Циклы
<code>for</code> в Rust работают немного иначе, чем в других языках программирования.
Например в Си-подобном языке цикл <code>for</code> выглядит так:</p>
<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>
<p>Однако, этот код в Rust будет выглядеть следующим образом:</p>
<pre><code class="language-rust">for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}
</code></pre>
<p>Можно представить цикл более абстрактно:</p>
<pre><code class="language-ignore">for переменная in выражение {
    тело_цикла
}
</code></pre>
<p>Выражение — это <a href="iterators.html">итератор</a>. Их мы будем рассматривать позже в этом
руководстве. Итератор возвращает серию элементов, где каждый элемент будет
являться одной итерацией цикла. Значение этого элемента затем присваивается
<code>переменной</code>, которая будет доступна в теле цикла. После окончания тела цикла,
берётся следующее значение итератора и снова выполняется тело цикла. Когда в
итераторе закончатся значения, цикл <code>for</code> завершается.</p>
<p>В нашем примере, <code>0..10</code> — это выражение, которое задаёт начальное и конечное
значение, и возвращает итератор. Обратите внимание, что конечное значение не
включается в него. В нашем примере будут напечатаны числа от <code>0</code> до <code>9</code>, но не
будет напечатано <code>10</code>.</p>
<p>В Rust намеренно нет цикла <code>for</code> в стиле C. Управлять каждым элементом цикла
вручную сложно, и это может приводить к ошибкам даже у опытных программистов на
C.</p>
<h3>Перечисление</h3>
<p>Если вы хотите отслеживать число прошедших итераций, используйте функцию
<code>.enumerate()</code>.</p>
<h4>С интервалами</h4>
<pre><code class="language-rust">for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} и j = {}&quot;, i, j);
}
</code></pre>
<p>Выводит:</p>
<pre><code class="language-text">i = 0 и j = 5
i = 1 и j = 6
i = 2 и j = 7
i = 3 и j = 8
i = 4 и j = 9
</code></pre>
<p>Не забудьте написать скобки вокруг интервала.</p>
<h4>С итераторами</h4>
<pre><code class="language-rust"># let lines = &quot;привет\nмир\nhello\nworld&quot;.lines();
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}
</code></pre>
<p>Outputs:</p>
<pre><code class="language-text">0: привет
1: мир
2: hello
3: world
</code></pre>
<h2>Раннее прерывание цикла</h2>
<p>Давайте ещё раз посмотрим на цикл <code>while</code>:</p>
<pre><code class="language-rust">let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
</code></pre>
<p>В этом примере в условии для выхода из цикла используется изменяемое имя <code>done</code>
логического типа. В Rust имеются два ключевых слова, которые помогают работать с
итерациями цикла: <code>break</code> и <code>continue</code>.</p>
<p>Мы можем переписать цикл с помощью <code>break</code>, чтобы избавиться от переменной
<code>done</code>:</p>
<pre><code class="language-rust">let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}
</code></pre>
<p>Теперь мы используем бесконечный цикл <code>loop</code> и <code>break</code> для выхода из цикла.
Использование явного <code>return</code> также остановит выполнение цикла.</p>
<p><code>continue</code> похож на <code>break</code>, но вместо выхода из цикла переходит к следующей
итерации. Следующий пример отобразит только нечётные числа:</p>
<pre><code class="language-rust">for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}
</code></pre>
<h2>Метки циклов</h2>
<p>Когда у вас много вложенных циклов, вы можете захотеть указать, к какому именно
циклу относится <code>break</code> или <code>continue</code>. Как и во многих других языках, по
умолчанию эти операторы будут относиться к самому внутреннему циклу. Если вы
хотите прервать внешний цикл, вы можете использовать метку. Так, этот код будет
печатать на экране только когда и <code>x</code>, и <code>y</code> нечётны:</p>
<pre><code class="language-rust">'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // продолжает цикл по x
        if y % 2 == 0 { continue 'inner; } // продолжает цикл по y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}
</code></pre>
<h1>Владение</h1>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li>владение, её вы читаете сейчас</li>
<li><a href="references-and-borrowing.html">заимствование</a>, и связанная с ним возможность «ссылки»</li>
<li><a href="lifetimes.html">время жизни</a>, расширение понятия заимствования</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1>Мета</h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор
Rust отказывается компилировать программу, которая по мнению автора является
абсолютно правильной. Это часто происходит потому, что мысленное представление
программиста о том, как должно работать владение, не совпадает с реальными
правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете
испытывать подобные трудности. Однако существует и хорошая новость: более
опытные разработчики на Rust говорят, что чем больше они работают с правилами
системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<h1>Владение</h1>
<p><a href="variable-bindings.html">Связанные имена</a> имеют одну особенность в Rust: они «владеют» тем, с
чем они связаны. Это означает, что, когда имя выходит за пределы области
видимости, ресурс, с которым оно связано, будет освобождён. Например:</p>
<pre><code class="language-rust">fn foo() {
    let v = vec![1, 2, 3];
}
</code></pre>
<p>Когда <code>v</code> входит в область видимости, создаётся новый [<code>Vec&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/vec/struct.Vec.html">vect</a>. В данном
случае вектор также выделяет из <a href="the-stack-and-the-heap.html">кучи</a> пространство для трёх элементов.
Когда <code>v</code> выходит из области видимости в конце <code>foo()</code>, Rust очищает все,
связанное с вектором, даже динамически выделенную память. Это происходит
детерминировано, в конце области видимости.</p>
<p><a name="move-semantics"></a></p>
<h1>Семантика перемещения</h1>
<p>Хотя тут есть некоторые тонкости: Rust гарантирует, что существует <em>ровно одно</em>
связывание какого-либо ресурса. Например, если у нас есть вектор, то мы можем
присвоить этот вектор другому имени:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let v2 = v;
</code></pre>
<p>Но, если после этого мы попытаемся использовать <code>v</code>, то получим ошибку:</p>
<pre><code class="language-rust,ignore">let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] = {}&quot;, v[0]);
</code></pre>
<p>Ошибка выглядит следующим образом:</p>
<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] = {}&quot;, v[0]);
                        ^
</code></pre>
<p>То же самое произойдёт, если мы определим функцию, которая принимает владение, и
попробуем использовать значение после того, как мы передали это значение в
качестве аргумента в эту функцию:</p>
<pre><code class="language-rust,ignore">fn take(v: Vec&lt;i32&gt;) {
    // что будет здесь не очень важно
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] = {}&quot;, v[0]);
</code></pre>
<p>Та же самая ошибка: «use of moved value» («используется перемещённое значение»).
Когда мы передаём право владения куда-то ещё, мы как бы говорим, что мы
«перемещаем» то, на что ссылаемся. При этом не нужно указывать какую-либо
специальную аннотацию, Rust делает это по умолчанию.</p>
<h2>Подробности</h2>
<p>Причина, по которой мы не можем использовать значение после того, как мы его
переместили, неочевидна, но очень важна. Когда мы пишем код вроде этого:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let v2 = v;
</code></pre>
<p>Первая строка создаёт некоторые данные для вектора в <a href="the-stack-and-the-heap.html">стеке</a>, <code>v</code>. Данные
самого вектора, однако, сохраняются в <a href="the-stack-and-the-heap.html">куче</a>, и поэтому стековые данные
содержат указатель на данные в куче. Когда мы перемещаем <code>v</code> в <code>v2</code>, то
создаётся копия стековых данных для <code>v2</code>. Что будет означать, что два указателя
ссылаются на расположенный в куче вектор. Такое поведение могло бы быть
проблемой: оно нарушало бы гарантии безопасности Rust, привнося гонки по данным.
Поэтому Rust запрещает использование <code>v</code> после того, как мы выполнили его
перемещение.</p>
<p>Важно также отметить, что оптимизация может удалить саму копию байтов на стеке,
в зависимости от обстоятельств. Так что это может быть не так уж неэффективно,
как выглядит на первый взгляд.</p>
<h2>Типы, реализующие типаж <code>Copy</code></h2>
<p>Мы установили, что как только владение передаётся другому имени, вы больше не
можете использовать исходное. Тем не менее, существует <a href="traits.html">типаж</a>, который
изменяет такое поведение, и он называется <code>Copy</code>. Мы ещё не обсуждали типажи, но
пока вы можете думать о них как об аннотациях к конкретному типу, которые
придают дополнительное поведение. Например:</p>
<pre><code class="language-rust">let v = 1;

let v2 = v;

println!(&quot;v = {}&quot;, v);
</code></pre>
<p>В этом примере <code>v</code> связан с типом <code>i32</code>. Этот тип реализует типаж <code>Copy</code>. Это
означает, что когда мы присваиваем значение <code>v</code> имени <code>v2</code>, будет создана копия
данных, как и при перемещении. Но, в отличие от перемещения, мы можем
использовать <code>v</code> в дальнейшем. Это происходит потому, что в <code>i32</code> нет указателей
на данные в каком-либо другом месте. При таком копировании создаётся полная
копия.</p>
<p>Мы будем обсуждать, как сделать свои собственные типы, реализующие типаж <code>Copy</code>
в разделе <a href="traits.html">Типажи</a>.</p>
<h1>Больше, чем владение</h1>
<p>Конечно, если бы нам нужно было вернуть владение обратно из функции, то мы бы
написали:</p>
<pre><code class="language-rust">fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // делаем что-либо с v

    // возвращаем владение
    v
}
</code></pre>
<p>Это сильно утомляет. Функция становится тем хуже, чем больше прав владения она
хочет забрать себе:</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // делаем что-нибудь с v1 и v2

    // возвращаем владение и результат нашей функции
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>Брр! Возвращаемый тип, строка возврата, и вызов функции получается намного
более сложным.</p>
<p>К счастью, Rust предлагает такую возможность, как заимствование, которая
помогает нам  решить эту проблему. Это тема следующего раздела!</p>
<h1>Ссылки и заимствование</h1>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li>заимствование, её вы читаете сейчас</li>
<li><a href="lifetimes.html">время жизни</a>, расширение понятия заимствования</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1>Мета</h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор
Rust отказывается компилировать программу, которая по мнению автора является
абсолютно правильной. Это часто происходит потому, что мысленное представление
программиста о том, как должно работать владение, не совпадает с реальными
правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете
испытывать подобные трудности. Однако существует и хорошая новость: более
опытные разработчики на Rust говорят, что чем больше они работают с правилами
системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<p><a name="borrowing"></a></p>
<h1>Заимствование</h1>
<p>В конце главы <a href="ownership.html">Владение</a> у нас была убогая функция, которая выглядела
так:</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>Однако, этот код не является идиоматичным с точки зрения Rust, так как он не
использует заимствование. Вот первый шаг:</p>
<pre><code class="language-rust">fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// we can use v1 and v2 here!
</code></pre>
<p>Вместо того, чтобы принимать <code>Vec&lt;i32&gt;</code> в качестве аргументов, мы будем
принимать ссылки: <code>&amp;Vec&lt;i32&gt;</code>. И вместо передачи <code>v1</code> и <code>v2</code> напрямую, мы будем
передавать <code>&amp;v1</code> и <code>&amp;v2</code>. Мы называем тип <code>&amp;T</code> «ссылка», и вместо того, чтобы
забирать владение ресурсом, она его заимствует. Имена, которые заимствуют что-
то, не освобождают ресурс, когда они выходят из области видимости. Это означает,
что, после вызова <code>foo()</code>, мы снова можем использовать наши исходные имена.</p>
<p>Ссылки являются неизменяемыми, как и имена. Это означает, что внутри <code>foo()</code>
векторы не могут быть изменены:</p>
<pre><code class="language-rust,ignore">fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);
</code></pre>
<p>выдаёт ошибку:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>Добавление значения изменяет вектор, и поэтому компилятор не позволил нам это
сделать.</p>
<h1>Ссылки &amp;mut</h1>
<p>Вот второй вид ссылок: <code>&amp;mut T</code>. Это «изменяемая ссылка», которая позволяет
изменять ресурс, который вы заимствуете. Например:</p>
<pre><code class="language-rust">let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);
</code></pre>
<p>Этот код напечатает <code>6</code>. Мы создали <code>y</code>, изменяемую ссылку на <code>x</code>, а затем
добавили единицу к значению, на которое указывает <code>y</code>. Следует отметить, что <code>x</code>
также должно быть помечено как <code>mut</code>. Если бы этого не было, то мы не могли бы
получить изменяемую ссылку неизменяемого значения.</p>
<p>Во всем остальном изменяемые ссылки (<code>&amp;mut</code>) такие же, как и неизменяемые (<code>&amp;</code>).
Однако, существует большая разница между этими двумя концепциями, и тем, как они
взаимодействуют. Вы можете сказать, что в приведённом выше примере есть что-то
подозрительное, потому что нам зачем-то понадобилась дополнительная область
видимости, созданная с помощью <code>{</code> и <code>}</code>. Если мы уберем эти скобки, то получим
ошибку:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Оказывается, есть определённые правила создания ссылок.</p>
<h1>Правила</h1>
<p>Вот правила заимствования в Rust.</p>
<p>Во-первых, область видимости любой ссылки должна находиться в пределах области
видимости владельца. Во-вторых, одновременно у вас может быть только один из
двух перечисленных ниже видов заимствования, но не оба сразу:</p>
<ul>
<li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс;</li>
<li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
</ul>
<p>Вы можете заметить, что это похоже, хотя и не соответствует точно, определению
состояния гонки данных:</p>
<blockquote>
<p>Состояние «гонки данных» возникает, когда два или более указателей
осуществляют доступ к одной и той же области памяти одновременно, по крайней
мере один из них производит запись, и операции не синхронизированы.</p>
</blockquote>
<p>Что касается неизменяемых ссылок, то вы можете иметь их столько, сколько хотите,
так как ни одна из них не производит запись. Если же вы производите запись, и
вам нужно два или больше указателей на одну и ту же область памяти, то вы можете
иметь только одну <code>&amp;mut</code> одновременно. Так Rust предотвращает возникновение
состояния гонки данных во время компиляции: мы получим ошибку компиляции, если
нарушим эти правила.</p>
<p>Имея это в виду, давайте рассмотрим наш пример еще раз.</p>
<h2>Осмысливаем области видимости (Thinking in scopes)</h2>
<p>Вот код:</p>
<pre><code class="language-rust,ignore">let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);
</code></pre>
<p>Этот код выдает нам такую ошибку:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<p>Это потому, что мы нарушили правила: у нас есть изменяемая ссылка <code>&amp;mut T</code>,
указывающая на <code>x</code>, и поэтому мы не можем создать какую-либо <code>&amp;T</code>. Одно из двух.
Примечание подсказывает как следует рассматривать эту проблему:</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Другими словами, изменяемая ссылка сохраняется до конца нашего примера. А мы
хотим, чтобы изменяемое заимствование заканчивалось <em>до</em> того, как мы пытаемся
вызвать <code>println!</code> и создать неизменяемое заимствование. В Rust заимствование
привязано к области видимости, в которой оно является действительным. И эти
области видимости выглядят следующим образом:</p>
<pre><code class="language-rust,ignore">let mut x = 5;

let y = &amp;mut x;    // -+ заимствование x через &amp;mut начинается здесь
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - пытаемся позаимствовать x здесь
                   // -+ заимствование x через &amp;mut заканчивается здесь
</code></pre>
<p>Конфликт областей видимости: мы не можем создать <code>&amp;x</code> до тех пор, пока <code>y</code>
находится в области видимости.</p>
<p>Поэтому, когда мы добавляем фигурные скобки:</p>
<pre><code class="language-rust">let mut x = 5;

{                   
    let y = &amp;mut x; // -+ заимствование через &amp;mut начинается здесь
    *y += 1;        //  |
}                   // -+ ... и заканчивается здесь

println!(&quot;{}&quot;, x);  // &lt;- пытаемся позаимствовать x здесь
</code></pre>
<p>Никаких проблем нет. Наша изменяемая ссылка выходит из области видимости до
создания неизменяемой. Но область видимости является ключом к определению того,
как долго длится заимствование.</p>
<h2>Проблемы, которые предотвращает заимствование</h2>
<p>Почему нужны эти ограничивающие правила? Ну, как мы уже отметили, эти правила
предотвращают гонки данных. Какие виды проблем могут привести к состоянию гонки
данных? Вот некоторые из них.</p>
<h3>Недействительный итератор</h3>
<p>Одним из примеров является «недействительный итератор». Такое может произойти,
когда вы пытаетесь изменить коллекцию, которую в данный момент обходите.
Проверка заимствования Rust предотвращает это:</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>Этот код печатает числа от одного до трёх. Когда мы обходим вектор, мы получаем
лишь ссылки на элементы. И сам <code>v</code> заимствован как неизменяемый, что означает,
что мы не можем изменить его в процессе обхода:</p>
<pre><code class="language-rust,ignore">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>Мы не можем изменить <code>v</code>, потому что он уже заимствован в цикле.</p>
<h3>Использование после освобождения (use after free)</h3>
<p>Ссылки должны жить так же долго, как и ресурс, на который они ссылаются. Rust
проверяет области видимости ваших ссылок, чтобы удостовериться, что это правда.</p>
<p>Если Rust не будет проверять это свойство, то мы можем случайно использовать
ссылку, которая будет недействительна. Например:</p>
<pre><code class="language-rust,ignore">let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);
</code></pre>
<p>Мы получим следующую ошибку:</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>Другими словами, <code>y</code> действителен только для той области видимости, где
существует <code>x</code>. Как только <code>x</code> выходит из области видимости, ссылка на него
становится недействительной. Таким образом, ошибка сообщает, что заимствование
«не живет достаточно долго» («does not live long enough»), потому что оно не
является действительным столько времени, сколько требуется.</p>
<p>Такая же проблема возникает, когда ссылка объявлена <em>перед</em> значением, на
которое она ссылается. Это происходит потому что ресурсы в одном блоке
освобождаются в порядке, противоположном порядку их объявления:</p>
<pre><code class="language-rust,ignore">let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);
</code></pre>
<p>Мы получим такую ошибку:</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>В примере выше <code>y</code> объявлена перед <code>x</code>, т.е. живёт дольше <code>x</code>, а это запрещено.</p>
<h1>Время жизни</h1>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li><a href="references-and-borrowing.html">заимствование</a>, и связанная с ним возможность «ссылки»</li>
<li>время жизни, её вы читаете сейчас</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1>Мета</h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие пользователи Rust занимаются тем, что мы зовём «борьбой с проверкой
заимствования» — компилятор Rust отказывается компилировать программу, которая
по мнению автора является абсолютно правильной. Это часто происходит потому, что
мысленное представление программиста о том, как должно работать владение, не
совпадает с реальными правилами, которыми оперирует Rust. Вы, наверное, поначалу
также будете испытывать подобные трудности. Однако существует и хорошая новость:
более опытные разработчики на Rust говорят, что чем больше они работают с
правилами системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<h1>Время жизни</h1>
<p>Одалживание ссылки на ресурс, которым кто-то владеет, может быть довольно
сложным. Например, представьте себе следующую последовательность операций:</p>
<ul>
<li>Мы получаем абстрактную ссылку на какой-то ресурс.</li>
<li>Мы одалживаем вам ссылку на этот ресурс.</li>
<li>Мы решаем, что ресурс нам больше не требуется, и освобождаем его, в то время
как у вас все еще есть на него ссылка.</li>
<li>Вы решаете использовать этот ресурс.</li>
</ul>
<p>Ой-ой! Ваша ссылка указывает на недопустимый ресурс. Это называется «висячий
указатель» или «использование после освобождения», когда ресурсом является
память.</p>
<p>Чтобы исправить это, мы должны убедиться, что четвертый шаг никогда не
произойдет после третьего. Система владения в Rust делает это через понятие
времени жизни, которое описывает область видимости, на протяжении которой ссылка
будет действительна.</p>
<p>Когда у нас есть функция, которая принимает ссылку в качестве аргумента, мы
можем явно или неявно указать время жизни ссылки:</p>
<pre><code class="language-rust">// неявно
fn foo(x: &amp;i32) {
}

// явно
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}
</code></pre>
<p>Читается <code>'a</code> как «время жизни a». Технически, все ссылки имеют некоторое время
жизни, связанное с ними, но компилятор позволяет опускать его в общих случаях.
Прежде чем мы перейдем к этому, давайте разберем пример ниже, с явным указанием
времени жизни:</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a&gt;(...)
</code></pre>
<p>Эта часть объявляет параметры времени жизни. Она говорит, что <code>bar</code> имеет один
параметр времени жизни, <code>'a</code>. Если бы в качестве параметров функции у нас было
две ссылки, то это выглядело бы так:</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a, 'b&gt;(...)
</code></pre>
<p>Затем в списке параметров функции мы используем заданные параметры времени
жизни:</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a i32)
</code></pre>
<p>Если бы мы хотели <code>&amp;mut</code> ссылку, то сделали бы так:</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a mut i32)
</code></pre>
<p>Если вы сравните <code>&amp;mut i32</code> с <code>&amp;'a mut i32</code>, то увидите, что они отличаются
только определением времени жизни <code>'a</code>, написанным между <code>&amp;</code> и <code>mut i32</code>. <code>&amp;mut i32</code> читается как «изменяемая ссылка на i32», а <code>&amp;'a mut i32</code> — как «изменяемая
ссылка на i32 со временем жизни 'a».</p>
<h2>Внутри [<code>struct</code>]<a href="structs.html">struct</a>'ов</h2>
<p>Вы также должны будете явно указать время жизни при работе со
[<code>struct</code>]<a href="structs.html">struct</a>'ми:</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // то же самое, что и `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre>
<p>Как вы можете заметить, структуры также могут иметь время жизни. Так же как и
функции,</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
# x: &amp;'a i32,
# }
</code></pre>
<p>объявляет время жизни и</p>
<pre><code class="language-rust"># struct Foo&lt;'a&gt; {
x: &amp;'a i32,
# }
</code></pre>
<p>использует его. Почему же мы должны определять время жизни здесь? Мы должны
убедиться, что ссылка на <code>Foo</code> не может жить дольше, чем ссылка на <code>i32</code>,
содержащаяся в нем.</p>
<h2>Блоки <code>impl</code></h2>
<p>Давайте реализуем метод для <code>Foo</code>:</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // то же самое, что и `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre>
<p>Как вы можете видеть, нам нужно объявить время жизни для <code>Foo</code> в строке с
<code>impl</code>. Мы повторяем <code>'a</code> дважды, как в функциях: <code>impl&lt;'a&gt;</code> определяет  время
жизни <code>'a</code>, и <code>Foo&lt;'a&gt;</code> использует его.</p>
<h2>Несколько времён жизни (Multiple lifetimes)</h2>
<p>Если вы имеете несколько ссылок, вы можете использовать одно и то же время
жизни несколько раз:</p>
<pre><code class="language-rust">fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Этот код говорит, что <code>x</code> и <code>y</code> находятся в одной области видимости друг с
другом, и что возвращаемое значение живо на протяжении той же области видимости.
Если вы хотите, чтобы <code>x</code> и <code>y</code> имели разные времена жизни, вы должны
использовать параметры нескольких времён жизни:</p>
<pre><code class="language-rust">fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
</code></pre>
<p>В этом примере <code>x</code> и <code>y</code> имеют различные области видимости, но возвращаемое
значение имеет то же время жизни, что и <code>x</code>.</p>
<h2>Осмысливаем области видимости (Thinking in scopes)</h2>
<p>Один из способов понять, что же такое время жизни — это визуализировать область,
в которой ссылка является действительной. Например:</p>
<pre><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y входит в область видимости
                    //  |
    // что-то       //  |
                    //  |
}                   // -+ y выходит из области видимости
</code></pre>
<p>Добавим нашу структуру <code>Foo</code>:</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y входит в область видимости
    let f = Foo { x: y }; // -+ f входит в область видимости
    // что-то             //  |
                          //  |
}                         // -+ f и y выходят из области видимости
</code></pre>
<p>Наша <code>f</code> живет в области видимости <code>y</code>, поэтому все работает. Что же произойдёт,
если это будет не так? Этот код не будет работать:</p>
<pre><code class="language-rust,ignore">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x входит в область видимости
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y входит в область видимости
        let f = Foo { x: y }; // ---+ f входит в область видимости
        x = &amp;f.x;             //  | | здесь ошибка
    }                         // ---+ f и y выходят из области видимости
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x выходит из области видимости
</code></pre>
<p>Уф! Как вы можете видеть здесь, области видимости <code>f</code> и <code>y</code> меньше, чем область
видимости <code>x</code>. Но когда мы выполняем <code>x = &amp;f.x</code>, мы присваиваем <code>x</code> ссылку на
что-то, что вот-вот выйдет из области видимости.</p>
<p>Присвоение имени времени жизни — это способ задать имя области видимости. Чтобы
думать о чём-то, нужно иметь название для этого.</p>
<h2>'static</h2>
<p>Время жизни с именем «static» — особенное. Оно обозначает, что что-то имеет
время жизни, равное времени жизни всей программы. Большинство программистов на
Rust впервые сталкиваются с <code>'static</code>, когда имеют дело со строками:</p>
<pre><code class="language-rust">let x: &amp;'static str = &quot;Привет, мир.&quot;;
</code></pre>
<p>Строковые литералы имеют тип <code>&amp;'static str</code>, потому что ссылка всегда
действительна: строки располагаются в сегменте данных конечного двоичного файла.
Другой пример — глобальные переменные:</p>
<pre><code class="language-rust">static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;
</code></pre>
<p>В этом примере <code>i32</code> добавляется в сегмент данных двоичного файла, а <code>x</code>
ссылается на него.</p>
<h2>Опускание времени жизни</h2>
<p>В Rust есть мощный локальный вывод типов. Однако, сигнатуры объявлений верхнего
уровня не выводятся, чтобы можно было рассуждать о типах на основании одних лишь
сигнатур. Из соображений удобства, введён ограниченный механизм вывода типов
сигнатур функций, называемый «опускание времени жизни» («lifetime elision»). Он
выводит типы на основании только элементов сигнатуры — тело функции при этом не
учитывается. При этом его назначение — это вывести лишь параметры времени жизни
аргументов. Для этого он реализует три простых правила. Таким образом, опускание
времени жизни упрощает написание сигнатур, одновременно не скрывая реальные типы
аргументов.</p>
<p>Когда речь идет о неявном времени жизни, мы используем термины <em>входное время
жизни</em> (<em>input lifetime</em>) и <em>выходное время жизни</em> (<em>output lifetime</em>). <em>Входное
время жизни</em> связано с передаваемыми в функцию параметрами, а <em>выходное время
жизни</em> связано с возвращаемым функцией значением. Например, эта функция имеет
входное время жизни:</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str)
</code></pre>
<p>А эта имеет выходное время жизни:</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;() -&gt; &amp;'a str
</code></pre>
<p>Эта же имеет как входное, так и выходное время жизни:</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>Ниже представлены три правила:</p>
<ul>
<li>
<p>Каждое неявное время жизни в аргументах функции становится отдельным
временем жизни.</p>
</li>
<li>
<p>Если есть ровно одно входное время жизни, явное или неявное, то это время
жизни назначается всем неявным выходным временам жизни.</p>
</li>
<li>
<p>Если есть несколько входных времён жизни, но одно из них это <code>&amp;self</code> или <code>&amp;mut self</code>, то всем неявным выходным временам жизни назначается время жизни <code>self</code>.</p>
</li>
</ul>
<p>В противном случае, неявное задание выходного времени жизни является ошибкой.</p>
<h3>Примеры</h3>
<p>Вот некоторые примеры функций, представленные в двух видах: с явно и неявно
заданным временем жизни:</p>
<pre><code class="language-rust,ignore">fn print(s: &amp;str); // неявно
fn print&lt;'a&gt;(s: &amp;'a str); // явно

fn debug(lvl: u32, s: &amp;str); // неявно
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // явно

// В предыдущем примере для `lvl` не требуется указывать время жизни, потому что
// это не ссылка (`&amp;`). Только элементы, связанные с ссылками (например, такие
// как структура, содержащая ссылку) требуют указания времени жизни.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // неявно
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // явно

fn get_str() -&gt; &amp;str; // НЕКОРРЕКТНО, нет входных параметров

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // НЕКОРРЕКТНО, два входных параметра
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Развёрнуто: Выходное время жизни неясно

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // неявно
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // явно

fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command // неявно
fn args&lt;'a, 'b, T:ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // явно

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // неявно
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt; // явно
</code></pre>
<h1>Изменяемость (mutability)</h1>
<p>Изменяемость, то есть возможность изменить что-то, работает в Rust несколько
иначе, чем в других языках. Во-первых, по умолчанию связанные имена не
изменяемы:</p>
<pre><code class="language-rust,ignore">let x = 5;
x = 6; // ошибка!
</code></pre>
<p>Изменяемость можно добавить с помощью ключевого слова <code>mut</code>:</p>
<pre><code class="language-rust">let mut x = 5;

x = 6; // нет проблем!
</code></pre>
<p>Это изменяемое <a href="variable-bindings.html">связанное имя</a>. Когда связанное имя изменяемо, это означает,
что мы можем поменять связанное с ним значение. В примере выше не то, чтобы само
значение <code>x</code> менялось, просто имя <code>x</code> связывается с другим значением типа <code>i32</code>.</p>
<p>Если же вы хотите изменить само связанное значение, вам понадобится
<a href="references-and-borrowing.html">изменяемая ссылка</a>:</p>
<pre><code class="language-rust">let mut x = 5;
let y = &amp;mut x;
</code></pre>
<p><code>y</code> — это неизменяемое имя для изменяемой ссылки. Это значит, что <code>y</code> нельзя
связать ещё с чем-то (<code>y = &amp;mut z</code>), но можно изменить то, на что указывает
связанная ссылка (<code>*y = 5</code>). Тонкая разница.</p>
<p>Конечно, вы можете объявить и изменяемое имя для изменяемой ссылки:</p>
<pre><code class="language-rust">let mut x = 5;
let mut y = &amp;mut x;
</code></pre>
<p>Теперь <code>y</code> можно связать с другим значением, и само это значение тоже можно
менять.</p>
<p>Стоит отметить, что <code>mut</code> — это часть <a href="patterns.html">шаблона</a>, поэтому можно делать
такие вещи:</p>
<pre><code class="language-rust">let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
# }
</code></pre>
<h1>Внутренняя (interior) и внешняя (exterior) изменяемость</h1>
<p>Однако, когда мы говорим, что что-либо «неизменяемо» в Rust, это не означает,
что оно совсем не может измениться. Мы говорим о «внешней изменяемости». Для
примера рассмотрим [<code>Arc&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/sync/struct.Arc.html">arc</a>:</p>
<pre><code class="language-rust">use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
</code></pre>
<p>Когда мы вызываем метод <code>clone()</code>, <code>Arc&lt;T&gt;</code> должна обновить счётчик ссылок. Мы
не использовали модификатор <code>mut</code>, а значит <code>x</code> — неизменяемое имя. Мы не можем
получить ссылку (<code>&amp;mut 5</code>) или сделать что-то подобное. И что же?</p>
<p>Для того чтобы понять это, мы должны вернуться назад к основам философии Rust,
к сохранности памяти и механизму, гарантирующему это, к системе
<a href="ownership.html">владения</a>, и, в частности, к <a href="references-and-borrowing.html#borrowing">заимствованию</a>:</p>
<blockquote>
<p>Одновременно у вас может быть только один из двух перечисленных ниже видов
заимствования, но не оба сразу:</p>
<ul>
<li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс,</li>
<li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
</ul>
</blockquote>
<p>Итак, что же здесь на самом деле является «неизменяемым»? Безопасно ли иметь два
указателя на один объект? В случае с <code>Arc&lt;T&gt;</code>, да: изменяемый объект полностью
находится внутри самой структуры. По этой причине, метод <code>clone()</code> возвращает
неизменяемую ссылку (<code>&amp;T</code>). Если бы он возвращал изменяемую ссылку (<code>&amp;mut T</code>),
то у нас были бы проблемы. Таким образом, <code>let mut z = Arc::new(5);</code> объявляет
атомарный счётчик ссылок с внешней изменяемостью.</p>
<p>Другие типы, например те, что определены в модуле [<code>std::cell</code>]<a href="http://doc.rust-lang.org/std/cell/index.html">stdcell</a>,
напротив, имеют «внутреннюю изменяемость». Например:</p>
<pre><code class="language-rust">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
</code></pre>
<p>RefCell возвращает изменяемую ссылку <code>&amp;mut</code> при помощи метода <code>borrow_mut()</code>. А
не опасно ли это? Что, если мы сделаем так:</p>
<pre><code class="language-rust,ignore">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
</code></pre>
<p>Это приведёт к панике во время исполнения. Вот что делает <code>RefCell</code>: он
принудительно выполняет проверку правил заимствования во время исполнения и
вызывает <code>panic!</code>, если они были нарушены.</p>
<p>Стоит отметить, что тип изменяемости — внутренняя или внешняя — определяется
самим типом. Нет способа волшебно превратить значение с внутренней изменяемостью
в значение со внешней, и наоборот.</p>
<p>Всё это подводит нас к другим аспектам правил изменяемости Rust. Давайте
поговорим о них.</p>
<h2>Изменяемость на уровне полей</h2>
<p>Изменяемость — это свойство либо ссылки (<code>&amp;mut</code>), либо имени (<code>let mut</code>). Это
значит, что, например, у вас не может быть <a href="structs.html">структуры</a>, часть полей
которой изменяется, а другая часть — нет:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    mut y: i32, // нельзя
}
</code></pre>
<p>Изменяемость структуры определяется при её связывании:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
</code></pre>
<p>Однако, используя [<code>Cell&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/cell/struct.Cell.html">cell</a>, вы можете эмулировать изменяемость на
уровне полей:</p>
<pre><code class="language-rust">use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!(&quot;y: {:?}&quot;, point.y);
</code></pre>
<p>Это выведет на экран <code>y: Cell { value: 7 }</code>. Мы успешно изменили значение <code>y</code>.</p>
<h1>Структуры</h1>
<p>Структура — это другой вид <em>агрегатного типа</em>, как и кортеж. Разница в том, что
в структурах у каждого элемента есть имя. Элемент структуры называется <em>полем</em>
или <em>членом структуры</em>. Смотрите:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!(&quot;Начало координат находится в ({}, {})&quot;, origin.x, origin.y);
}
</code></pre>
<p>Этот код делает много разных вещей, поэтому давайте разберём его по порядку. Мы
объявляем структуру с помощью ключевого слова <code>struct</code>, за которым следует имя
объявляемой структуры. Обычно, имена типов-структур начинаются с заглавной буквы
и используют чередующийся регистр букв: название <code>PointInSpace</code> выглядит
привычно, а <code>Point_In_Space</code> — нет.</p>
<p>Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора
<code>let</code>. Однако в данном случае мы используем синтаксис вида <code>ключ: значение</code> для
установки значения каждого поля. Порядок инициализации полей не обязательно
должен совпадать с порядком их объявления.</p>
<p>Наконец, поскольку у полей есть имена, мы можем получить поле с помощью операции
<code>точка</code>: <code>origin.x</code>.</p>
<p>Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не
отличаются от других именованных сущностей. Чтобы они стали изменяемы,
используйте ключевое слово <code>mut</code>:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!(&quot;Точка находится в ({}, {})&quot;, point.x, point.y);
}
</code></pre>
<p>Этот код напечатает <code>Точка находится в (5, 0)</code>.</p>
<p>Rust не поддерживает изменяемость отдельных полей, поэтому вы не можете написать
что-то вроде такого:</p>
<pre><code class="language-rust,ignore">struct Point {
    mut x: i32,
    y: i32,
}
</code></pre>
<p>Изменяемость — это свойство имени, а не самой структуры. Если вы привыкли к
управлению изменяемостью на уровне полей, сначала это может показаться
непривычным, но на самом деле такое решение сильно упрощает вещи. Оно даже
позволяет вам делать имена изменяемыми только на короткое время:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    let point = point; // это новое имя неизменяемо

    point.y = 6; // это вызывает ошибку
}
</code></pre>
<h1>Синтаксис обновления (update syntax)</h1>
<p>Вы можете включить в описание структуры <code>..</code> чтобы показать, что вы хотите
использовать значения полей какой-то другой структуры. Например:</p>
<pre><code class="language-rust">struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
</code></pre>
<p>Этот код присваивает <code>point</code> новое <code>y</code>, но оставляет старые <code>x</code> и <code>z</code>. Это не
обязательно должна быть та же самая структура — вы можете использовать этот
синтаксис когда создаёте новые структуры, чтобы скопировать значения неуказанных
полей:</p>
<pre><code class="language-rust"># struct Point3d {
#     x: i32,
#     y: i32,
#     z: i32,
# }
let origin = Point3d { x: 0, y: 0, z: 0 };
let point = Point3d { z: 1, x: 2, .. origin };
</code></pre>
<h1>Кортежные структуры</h1>
<p>В Rust есть ещё один тип данных, который представляет собой нечто среднее между
кортежем и структурой. Он называется <em>кортежной структурой</em>. Кортежные структуры
именуются, а вот у их полей имён нет:</p>
<pre><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
</code></pre>
<p>Эти два объекта различны, несмотря на то, что у них одинаковые значения:</p>
<pre><code class="language-rust"># struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</code></pre>
<p>Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
Мы бы скорее объявили типы <code>Color</code> и <code>Point</code> вот так:</p>
<pre><code class="language-rust">struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
</code></pre>
<p>Теперь у нас есть настоящие имена, а не только позиции. Хорошие имена важны, и
при использовании структуры у нас есть эти имена.</p>
<p>Однако, <em>есть</em> один случай, когда кортежные структуры очень полезны. Это
кортежная структура с всего одним элементом. Такое использование называется
<em>новым типом</em>, потому что оно позволяет создать новый тип, отличный от типа
значения, содержащегося в кортежной структуре. При этом новый тип обозначает
что-то другое:</p>
<pre><code class="language-rust">struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!(&quot;Длина в дюймах: {}&quot;, integer_length);
</code></pre>
<p>Как вы можете видеть в данном примере, извлечь вложенный целый тип можно с
помощью деконструирующего <code>let</code>. Мы обсуждали это выше, в разделе «кортежи». В
данном случае, оператор <code>let Inches(integer_length)</code> присваивает <code>10</code> имени
<code>integer_length</code>.</p>
<h1>Перечисления</h1>
<p>В Rust есть «типы-суммы», или <em>перечисления</em> (тип-сумма — это термин из теории
типов). Перечисления — это очень полезная возможность Rust, и они очень много
используются в стандартной библиотеке языка. Они объявляются с помощью ключевого
слова <code>enum</code>. <code>enum</code> — это тип, который соотносит набор неких вариантов одному
имени. Например, ниже мы определяем перечисление <code>Character</code> (символ),
представляющее собой или цифру (<code>Digit</code>), или что-то другое.</p>
<pre><code class="language-rust">enum Character {
    Digit(i32),
    Other,
}
</code></pre>
<p>Большая часть обычных типов могут быть вариантами перечисления. Вот несколько
примеров:</p>
<pre><code class="language-rust">struct Empty;
struct Color(i32, i32, i32);
struct Length(i32);
struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }
struct HeightDatabase(Vec&lt;i32&gt;);
</code></pre>
<p>Здесь мы видим, что, в зависимости от типа, вариант перечисления может
содержать, а может и не содержать вложенные данные. Например, в перечислении
<code>Character</code>, вариант <code>Digit</code> даёт значимое имя числу типа <code>i32</code>. А вот вариант
<code>Other</code> представляет собой лишь имя, без значения. Однако наиболее полезно
именно то, что отдельные варианты представляют собой различные виды символов.</p>
<p>Как и структуры, варианты перечислений по умолчанию не сравнимы операциями
сравнения (<code>==</code>, <code>!=</code>), не упорядочены (не реализуют <code>&lt;</code>, <code>&gt;=</code> и другие) и не
поддерживают другие двухместные операции, такие как умножение (<code>*</code>) и сложение
(<code>+</code>). Нижеследующий код, как таковой, не верен (если мы используем приведённый
выше тип-перечисление <code>Character</code>):</p>
<pre><code class="language-rust,ignore">// Оба этих присваивания успешны
let ten  = Character::Digit(10);
let four = Character::Digit(4);

// Error: `*` is not implemented for type `Character`
let forty = ten * four;

// Error: `&lt;=` is not implemented for type `Character`
let four_is_smaller = four &lt;= ten;

// Error: `==` is not implemented for type `Character`
let four_equals_ten = four == ten;
</code></pre>
<p>Мы используем синтаксис <code>::</code> чтобы использовать имя каждого из вариантов. Их
область видимости ограничена именем самого перечисления <code>enum</code>. Это позволяет
использовать оба варианта из примера ниже совместно:</p>
<pre><code class="language-rust,ignore">Character::Digit(10);
Hand::Digit;
</code></pre>
<p>Оба варианта имеют одинаковые имена, <code>Digit</code>, но область видимости каждого из
них ограничена соответствующим именем <code>enum</code>.</p>
<p>То, что пользовательские типы по умолчанию не поддерживают операции, может
показаться довольно ограниченным. Но это ограничение, которое мы всегда можем
преодолеть. Есть два способа: реализовать операцию самостоятельно, или
воспользоваться сопоставлением с образцом с помощью [<code>match</code>]<a href="match.html">match</a>, о котором
вы узнаете в следующем разделе. Пока мы еще недостаточно знаем Rust, чтобы
реализовывать операции, но мы научимся делать это в разделе [<code>traits</code>]<a href="traits.html">traits</a>.</p>
<h1>Конструкция <code>match</code></h1>
<p>Простого <code>if</code>/<code>else</code> часто недостаточно, потому что нужно проверить больше, чем
два возможных варианта. Да и к тому же условия в <code>else</code> часто становятся очень
сложными. Как же решить эту проблему?</p>
<p>В Rust есть ключевое слово <code>match</code>, позволяющее заменить группы операторов
<code>if</code>/<code>else</code> чем-то более удобным. Смотрите:</p>
<pre><code class="language-rust">let x = 5;

match x {
    1 =&gt; println!(&quot;один&quot;),
    2 =&gt; println!(&quot;два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    4 =&gt; println!(&quot;четыре&quot;),
    5 =&gt; println!(&quot;пять&quot;),
    _ =&gt; println!(&quot;что-то ещё&quot;),
}
</code></pre>
<p><code>match</code> принимает выражение и выбирает одну из ветвей исполнения согласно его
значению. Каждая <em>ветвь</em> имеет форму <code>значение =&gt; выражение</code>. Выражение ветви
вычисляется, когда значение данной ветви совпадает со значением, принятым
оператором <code>match</code> (в данном случае, <code>x</code>). Эта конструкция называется <code>match</code>
(сопоставление), потому что она выполняет сопоставление значения неким
«шаблонам». Глава «<a href="patterns.html">Шаблоны</a>» описывает все шаблоны, которые можно
использовать в <code>match</code>.</p>
<p>Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
<code>match</code> <em>проверяются на полноту</em>. Видите последнюю ветвь, со знаком
подчёркивания (<code>_</code>)? Если мы удалим её, Rust выдаст ошибку:</p>
<pre><code class="language-text">error: non-exhaustive patterns: `_` not covered
</code></pre>
<p>Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
значения. Поскольку <code>x</code> — это целое число, оно может принимать разные значения —
например, <code>6</code>. Однако, если мы убираем ветвь <code>_</code>, ни одна ветвь не совпадёт,
поэтому такой код не скомпилируется. <code>_</code> — это «совпадение с любым значением».
Если ни одна другая ветвь не совпала, совпадёт ветвь с <code>_</code>. Поскольку в примере
выше есть ветвь с <code>_</code>, мы покрываем всё множество значений <code>x</code>, и наша программа
скомпилируется.</p>
<p><code>match</code> также является выражением. Это значит, что мы можем использовать его в
правой части оператора <code>let</code> или непосредственно как выражение:</p>
<pre><code class="language-rust">let x = 5;

let numer = match x {
    1 =&gt; &quot;one&quot;,
    2 =&gt; &quot;two&quot;,
    3 =&gt; &quot;three&quot;,
    4 =&gt; &quot;four&quot;,
    5 =&gt; &quot;five&quot;,
    _ =&gt; &quot;something else&quot;,
};
</code></pre>
<p>Иногда с помощью <code>match</code> можно удобно преобразовать значения одного типа в
другой.</p>
<h1>Сопоставление с образцом для перечислений</h1>
<p>Другой полезный способ использования <code>match</code> — обработка возможных вариантов
перечисления:</p>
<pre><code class="language-rust">enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit =&gt; quit(),
        Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
        Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
        Message::Write(s) =&gt; println!(&quot;{}&quot;, s),
    };
}
</code></pre>
<p>Как обычно, компилятор Rust проверяет полноту, поэтому в <code>match</code> должна быть
ветвь для каждого варианта перечисления. Если какой-то вариант отсутствует,
программа не скомпилируется и вам придётся использовать <code>_</code>.</p>
<p>Здесь мы не можем использовать обычный <code>if</code> вместо <code>match</code>, в отличие от кода,
который мы видели раньше. Но мы могли бы использовать [<code>if let</code>]<a href="if-let.html">if-let</a> — его
можно воспринимать как сокращённую форму записи <code>match</code>.</p>
<h1>Шаблоны сопоставления <code>match</code></h1>
<p>Шаблоны достаточно часто используются в Rust. Мы уже использовали их в разделе
<a href="variable-bindings.html">Связывание переменных</a>, в разделе [Конструкция <code>match</code>]<a href="match.html">match</a>, а
также в некоторых других местах. Давайте коротко пробежимся по всем
возможностям, которые можно реализовать с помощью шаблонов!</p>
<p>Быстро освежим в памяти: сопоставлять с шаблоном литералы можно либо напрямую,
либо с использованием символа <code>_</code>, который означает <em>любой</em> случай:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 =&gt; println!(&quot;один&quot;),
    2 =&gt; println!(&quot;два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
</code></pre>
<p>Этот код напечатает <code>один</code>.</p>
<h1>Сопоставление с несколькими шаблонами</h1>
<p>Вы можете сопоставлять с несколькими шаблонами, используя <code>|</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;один или два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
</code></pre>
<p>Этот код напечатает <code>один или два</code>.</p>
<h1>Деструктуризация</h1>
<p>Если вы работаете с составным типом данных, вроде [<code>struct</code>]<a href="structs.html">struct</a>, вы можете
разобрать его на части («деструктурировать») внутри шаблона:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
</code></pre>
<p>Мы можем использовать <code>:</code>, чтобы привязать значение к новому имени.</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
</code></pre>
<p>Если нас интересуют только некоторые значения, мы можем не давать имена всем
составляющим:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x равен {}&quot;, x),
}
</code></pre>
<p>Этот код напечатает <code>x равен 0</code>.</p>
<p>Вы можете использовать это в любом сопоставлении: не обязательно игнорировать
именно первый элемент:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } =&gt; println!(&quot;y равен {}&quot;, y),
}
</code></pre>
<p>Этот код напечатает <code>y равен 0</code>.</p>
<p>Можно произвести деструктуризацию любого составного типа данных — например,
<a href="primitive-types.html#tuples">кортежей</a> и <a href="enums.html">перечислений</a>.</p>
<h1>Игнорирование связывания</h1>
<p>Вы можете использовать в шаблоне <code>_</code>, чтобы проигнорировать соответствующее
значение. Например, вот сопоставление <code>Result&lt;T, E&gt;</code>:</p>
<pre><code class="language-rust"># let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;Здесь была какая-то ошибка&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;получили значение: {}&quot;, value),
    Err(_) =&gt; println!(&quot;произошла ошибка&quot;),
}
</code></pre>
<p>В первой ветви мы привязываем значение варианта <code>Ok</code> к имени <code>value</code>. А в ветви
обработки варианта <code>Err</code> мы используем <code>_</code>, чтобы проигнорировать конкретную
ошибку, и просто печатаем общее сообщение.</p>
<p><code>_</code> допустим в любом шаблоне, который связывает имена. Это можно использовать,
чтобы проигнорировать части большой структуры:</p>
<pre><code class="language-rust">fn coordinate() -&gt; (i32, i32, i32) {
    // создаём и возвращаем какой-то кортеж из трёх элементов
# (1, 2, 3)
}

let (x, _, z) = coordinate();
</code></pre>
<p>Здесь мы связываем первый и последний элемент кортежа с именами <code>x</code> и <code>z</code>
соответственно, а второй элемент игнорируем.</p>
<p>Похожим образом, в шаблоне можно использовать <code>..</code>, чтобы проигнорировать
несколько значений.</p>
<pre><code class="language-rust">enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Получили кортеж!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;Вот неудача.&quot;),
}
</code></pre>
<p>Этот код печатает <code>Получили кортеж!</code>.</p>
<h1>ref и ref mut</h1>
<p>Если вы хотите получить <a href="references-and-borrowing.html">ссылку</a>, то используйте ключевое слово <code>ref</code>:</p>
<pre><code class="language-rust">let x = 5;

match x {
    ref r =&gt; println!(&quot;Получили ссылку на {}&quot;, r),
}
</code></pre>
<p>Этот код напечатает <code>Получили ссылку на 5</code>.</p>
<p>Здесь <code>r</code> внутри <code>match</code> имеет тип <code>&amp;i32</code>. Другими словами, ключевое слово <code>ref</code>
<em>создает</em> ссылку, для использования в шаблоне. Если вам нужна изменяемая ссылка,
то <code>ref mut</code> будет работать аналогичным образом:</p>
<pre><code class="language-rust">let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Получили изменяемую ссылку на {}&quot;, mr),
}
</code></pre>
<h1>Сопоставление с диапазоном</h1>
<p>Вы можете сопоставлять с диапазоном значений, используя <code>...</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;от одного до пяти&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
</code></pre>
<p>Этот код напечатает <code>от одного до пяти</code>.</p>
<p>Диапазоны в основном используются с числами или одиночными символами (<code>char</code>).</p>
<pre><code class="language-rust">let x = '💅';

match x {
    'а' ... 'и' =&gt; println!(&quot;ранняя буква&quot;),
    'к' ... 'я' =&gt; println!(&quot;поздняя буква&quot;),
    _ =&gt; println!(&quot;что-то ещё&quot;),
}
</code></pre>
<p>Этот код напечатает <code>что-то ещё</code>.</p>
<h1>Связывание</h1>
<p>Вы можете связать значение с именем с помощью символа <code>@</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;получили элемент диапазона {}&quot;, e),
    _ =&gt; println!(&quot;что угодно&quot;),
}
</code></pre>
<p>Этот код напечатает <code>получили элемент диапазона 1</code>. Это полезно, когда вы хотите
сделать сложное сопоставление для части структуры данных:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let mut x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
</code></pre>
<p>Этот код напечатает <code>Some(&quot;Steve&quot;)</code>: мы связали внутреннюю <code>name</code> с <code>a</code>.</p>
<p>Если вы используете <code>@</code> совместно с <code>|</code>, то вы должны убедиться, что имя
связывается в каждой из частей шаблона:</p>
<pre><code class="language-rust">let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;получили элемент диапазона {}&quot;, e),
    _ =&gt; println!(&quot;что угодно&quot;),
}
</code></pre>
<h1>Ограничители шаблонов</h1>
<p>Вы можете ввести <em>ограничители шаблонов</em> (<em>match guards</em>) с помощью <code>if</code>:</p>
<pre><code class="language-rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Получили целое больше пяти!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Получили целое!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;Неудача.&quot;),
}
</code></pre>
<p>Этот код напечатает <code>Получили целое!</code>.</p>
<p>Если вы используете <code>if</code> с несколькими шаблонами, он применяется к обоим частям:</p>
<pre><code class="language-rust">let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;да&quot;),
    _ =&gt; println!(&quot;нет&quot;),
}
</code></pre>
<p>Этот код печатает <code>нет</code>, потому что <code>if</code> применяется ко всему <code>4 | 5</code>, а не
только к <code>5</code>. Другими словами, приоритет <code>if</code> выглядит так:</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h1>Заключение</h1>
<p>Вот так! Существует много разных способов использования конструкции
сопоставления с шаблоном, и все они могут быть смешаны и состыкованы, в
зависимости от того, что вы хотите сделать:</p>
<pre><code class="language-rust,ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>Шаблоны — это очень мощный инструмент. Используйте их.</p>
<h1>Синтаксис методов</h1>
<p>Функции — это хорошо, но если вы хотите вызвать несколько связных функций для
каких-либо данных, то это может быть неудобно. Рассмотрим этот код:</p>
<pre><code class="language-rust,ignore">baz(bar(foo)));
</code></pre>
<p>Читать данную строку кода следует слева направо, поэтому мы наблюдаем такой
порядок: «baz bar foo». Но он противоположен порядку, в котором функции будут
вызываться: «foo bar baz». Было бы классно записать вызовы в том порядке, в
котором они происходят, не так ли?</p>
<pre><code class="language-rust,ignore">foo.bar().baz();
</code></pre>
<p>К счастью, как вы уже наверно догадались, это возможно! Rust предоставляет
возможность использовать такой <em>синтаксис вызова метода</em> с помощью ключевого
слова <code>impl</code>.</p>
<h1>Вызов методов</h1>
<p>Вот как это работает:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());
}
</code></pre>
<p>Этот код напечатает <code>12.566371</code>.</p>
<p>Мы создали структуру, которая представляет собой круг. Затем мы написали блок
<code>impl</code> и определили метод <code>area</code> внутри него.</p>
<p>Методы принимают специальный первый параметр, <code>&amp;self</code>. Есть три возможных
варианта: <code>self</code>, <code>&amp;self</code> и <code>&amp;mut self</code>. Вы можете думать об этом специальном
параметре как о <code>x</code> в <code>x.foo()</code>. Три варианта соответствуют трем возможным видам
элемента <code>x</code>: <code>self</code> — если это просто значение в стеке, <code>&amp;self</code> — если это
ссылка и <code>&amp;mut self</code> — если это изменяемая ссылка. Мы передаем параметр <code>&amp;self</code>
в метод <code>area</code>, поэтому мы можем использовать его так же, как и любой другой
параметр. Так как мы знаем, что это <code>Circle</code>, мы можем получить доступ к полю
<code>radius</code> так же, как если бы это была любая другая структура.</p>
<p>По умолчанию следует использовать <code>&amp;self</code>, также как следует предпочитать
заимствование владению, а неизменные ссылки изменяемым. Вот пример, включающий
все три варианта:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&amp;self) {
       println!(&quot;принимаем self по ссылке!&quot;);
    }

    fn mutable_reference(&amp;mut self) {
       println!(&quot;принимаем self по изменяемой ссылке!&quot;);
    }

    fn takes_ownership(self) {
       println!(&quot;принимаем владение self!&quot;);
    }
}
</code></pre>
<h1>Цепочка вызовов методов</h1>
<p>Итак, теперь мы знаем, как вызвать метод, например <code>foo.bar()</code>. Но что насчет
нашего первоначального примера, <code>foo.bar().baz()</code>? Это называется «цепочка
вызовов», и мы можем сделать это, вернув <code>self</code>.</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn grow(&amp;self, increment: f64) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius + increment }
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());

    let d = c.grow(2.0).area();
    println!(&quot;{}&quot;, d);
}
</code></pre>
<p>Проверьте тип возвращаемого значения:</p>
<pre><code class="language-rust"># struct Circle;
# impl Circle {
fn grow(&amp;self) -&gt; Circle {
# Circle } }
</code></pre>
<p>Мы просто указываем, что возвращается <code>Circle</code>. С помощью этого метода мы можем
создать новый круг, площадь которого будет в 100 раз больше, чем у старого.</p>
<h1>Статические методы</h1>
<p>Вы также можете определить методы, которые не принимают параметр <code>self</code>. Вот
шаблон программирования, который очень распространен в коде на Rust:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
</code></pre>
<p>Этот <em>статический метод</em>, который создает новый <code>Circle</code>. Обратите внимание, что
статические методы вызываются с помощью синтаксиса: <code>Struct::method()</code>, а не
<code>ref.method()</code>.</p>
<h1>Шаблон «строитель» (Builder Pattern)</h1>
<p>Давайте предположим, что нам нужно, чтобы наши пользователи могли создавать
круги и чтобы у них была возможность задавать только те свойства, которые им
нужны. В противном случае, атрибуты <code>x</code> и <code>y</code> будут <code>0.0</code>, а <code>radius</code> будет
<code>1.0</code>. Rust не поддерживает перегрузку методов, именованные аргументы или
переменное количество аргументов. Вместо этого мы используем шаблон «строитель».
Он выглядит следующим образом:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -&gt; CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 0.0, }
    }

    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&amp;self) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!(&quot;площадь: {}&quot;, c.area());
    println!(&quot;x: {}&quot;, c.x);
    println!(&quot;y: {}&quot;, c.y);
}
</code></pre>
<p>Всё, что мы сделали здесь — это создали ещё одну структуру, <code>CircleBuilder</code>. В
ней мы определили методы строителя. Также мы определили метод <code>area()</code> в
<code>Circle</code>. Мы также сделали еще один метод в <code>CircleBuilder</code>: <code>finalize()</code>. Этот
метод создаёт наш окончательный <code>Circle</code> из строителя. Таким образом, мы можем
использовать методы <code>CircleBuilder</code> чтобы уточнить создание <code>Circle</code>.</p>
<h1>Вектора</h1>
<p>«Вектор» — это динамический или, по-другому, «растущий» массив, реализованный в
виде стандартного библиотечного типа [<code>Vec&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/vec/index.html">vec</a> (где <code>&lt;T&gt;</code> является
<a href="generics.html">обобщённым типом</a>). Вектора всегда размещают данные в куче. Вы можете
создавать их с помощью макроса <code>vec!</code>:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5]; // v: Vec&lt;i32&gt;
</code></pre>
<p>(Заметьте, что, в отличие от макроса <code>println!</code>, который мы использовали ранее,
с <code>vec!</code> используются квадратные скобки <code>[]</code>. Rust разрешает использование и
круглых, и квадратных скобок в обеих ситуациях — это просто стилистическое
соглашение.)</p>
<p>Для создания вектора из повторяющихся значений есть другая форма <code>vec!</code>:</p>
<pre><code class="language-rust">let v = vec![0; 10]; // десять нулей
</code></pre>
<h2>Доступ к элементам</h2>
<p>Чтобы получить значение по определенному индексу в векторе, мы используем <code>[]</code>:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];

println!(&quot;Третий элемент вектора v равен {}&quot;, v[2]);
</code></pre>
<p>Индексы отсчитываются от <code>0</code>, так что третьим элементом является <code>v[2]</code>.</p>
<h2>Обход</h2>
<p>Вы можете обойти элементы вектора с помощью <code>for</code>. Есть три варианта:</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;Ссылка {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;Изменяемая ссылка {}&quot;, i);
}

for i in v {
    println!(&quot;Владение вектором и его элементами {}&quot;, i);
}
</code></pre>
<p>У векторов есть много других полезных методов, о которых вы можете прочитать в
<a href="http://doc.rust-lang.org/std/vec/index.html">документации API</a>.</p>
<h1>Строки</h1>
<p>Строки — важное понятие для любого программиста. Система обработки строк в Rust
немного отличается от других языков, потому что это язык системного
программирования. Работать со структурами данных с переменным размером довольно
сложно, и строки — как раз такая структура данных. Кроме того, работа со
строками в Rust также отличается и от некоторых системных языков, таких как C.</p>
<p>Давайте разбираться в деталях. <em>string</em> — это последовательность скалярных
значений юникод, закодированных в виде потока байт UTF-8. Все строки должны быть
гарантированно валидными UTF-8 последовательностями. Кроме того, строки не
оканчиваются нулём и могут содержать нулевые байты.</p>
<p>В Rust есть два основных типа строк: <code>&amp;str</code> и <code>String</code>. Сперва поговорим о
<code>&amp;str</code> — это «строковый срез». Строковые срезы имеют фиксированный размер и
не могут быть изменены. Они представляют собой ссылку на последовательность
байт UTF-8:</p>
<pre><code class="language-rust">let greeting = &quot;Всем привет.&quot;; // greeting: &amp;'static str
</code></pre>
<p><code>&quot;Всем привет.&quot;</code> — это строковый литерал, его тип — <code>&amp;'static str</code>.
Строковые литералы являются статически размещенными строковыми срезами. Это
означает, что они сохраняются внутри нашей скомпилированной программы и
существуют в течение всего периода ее выполнения. Имя <code>greeting</code> представляет
собой ссылку на эту статически размещенную строку. Любая функция, ожидающая
строковый срез, может также принять в качестве аргумента строковый литерал.</p>
<p>Строковые литералы могут состоять из нескольких строк. Такие литералы можно
записывать в двух разных формах. Первая будет включать в себя перевод на новую
строку и ведущие пробелы:</p>
<pre><code class="language-rust">let s = &quot;foo
    bar&quot;;

assert_eq!(&quot;foo\n        bar&quot;, s);
</code></pre>
<p>Вторая форма, включающая в себя <code>\</code>, вырезает пробелы и перевод на новую строку:</p>
<pre><code class="language-rust">let s = &quot;foo\
    bar&quot;; 

assert_eq!(&quot;foobar&quot;, s);
</code></pre>
<p>Но в Rust есть не только <code>&amp;str</code>. Тип <code>String</code> представляет собой строку,
размещенную в куче. Эта строка расширяема, и она также гарантированно является
последовательностью UTF-8. <code>String</code> обычно создаётся путем преобразования из
строкового среза с использованием метода <code>to_string</code>.</p>
<pre><code class="language-rust">let mut s = &quot;Привет&quot;.to_string(); // mut s: String
println!(&quot;{}&quot;, s);

s.push_str(&quot;, мир.&quot;);
println!(&quot;{}&quot;, s);
</code></pre>
<p><code>String</code> преобразуются в <code>&amp;str</code> с помощью <code>&amp;</code>:</p>
<pre><code class="language-rust">fn takes_slice(slice: &amp;str) {
    println!(&quot;Получили: {}&quot;, slice);
}

fn main() {
    let s = &quot;Привет&quot;.to_string();
    takes_slice(&amp;s);
}
</code></pre>
<p>Это преобразование не происходит в случае функций, которые принимают какой-то
типаж <code>&amp;str</code>, а не сам <code>&amp;str</code>. Например, у метода
[<code>TcpStream::connect</code>]<a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect">connect</a> есть параметр типа <code>ToSocketAddrs</code>. Сюда можно
передать <code>&amp;str</code>, но <code>String</code> нужно явно преобразовать с помощью <code>&amp;*</code>.</p>
<pre><code class="language-rust,no_run">use std::net::TcpStream;

TcpStream::connect(&quot;192.168.0.1:3000&quot;); // параметр &amp;str

let addr_string = &quot;192.168.0.1:3000&quot;.to_string();
TcpStream::connect(&amp;*addr_string); // преобразуем addr_string в &amp;str
</code></pre>
<p>Представление <code>String</code> как <code>&amp;str</code> — дешёвая операция, но преобразование <code>&amp;str</code>
в <code>String</code> предполагает выделение памяти. Не стоит делать это без необходимости!</p>
<h2>Индексация</h2>
<p>Поскольку строки являются валидными UTF-8 последовательностями, то они не
поддерживают индексацию:</p>
<pre><code class="language-rust,ignore">let s = &quot;привет&quot;;

println!(&quot;Первая буква s — {}&quot;, s[0]); // ОШИБКА!!!
</code></pre>
<p>Как правило, доступ к вектору с помощью <code>[]</code> является очень быстрой операцией.
Но поскольку каждый символ в строке, закодированной UTF-8, может быть
представлен несколькими байтами, то при поиске вы должны перебрать n-ое
количество литер в строке. Это значительно более дорогая операция, а мы не хотим
вводить в заблуждение. Кроме того, «литера» — это не совсем то, что определено в
Unicode. Мы можем выбрать как рассматривать строку: как отдельные байты или как
кодовые единицы (codepoints):</p>
<pre><code class="language-rust">let hachiko = &quot;忠犬ハチ公&quot;;

for b in hachiko.as_bytes() {
    print!(&quot;{}, &quot;, b);
}

println!(&quot;&quot;);

for c in hachiko.chars() {
    print!(&quot;{}, &quot;, c);
}

println!(&quot;&quot;);
</code></pre>
<p>Этот код напечатает:</p>
<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
忠, 犬, ハ, チ, 公, 
</code></pre>
<p>Как вы можете видеть, количество байт больше, чем количество символов (<code>char</code>).</p>
<p>Вы можете получить что-то наподобие индекса, как показано ниже:</p>
<pre><code class="language-rust"># let hachiko = &quot;忠犬ハチ公&quot;;
let dog = hachiko.chars().nth(1); // что-то вроде hachiko[1]
</code></pre>
<p>Это подчеркивает, что мы должны пройти по списку <code>chars</code> от его начала.</p>
<h2>Срезы</h2>
<p>Вы можете получить срез строки с помощью синтаксиса срезов:</p>
<pre><code class="language-rust">let dog = &quot;hachiko&quot;;
let hachi = &amp;dog[0..5];
</code></pre>
<p>Но заметьте, что это индексы <em>байтов</em>, а не <em>символов</em>. Поэтому этот код
запаникует:</p>
<pre><code class="language-rust,should_panic">let dog = &quot;忠犬ハチ公&quot;;
let hachi = &amp;dog[0..2];
</code></pre>
<p>с такой ошибкой:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary'
</code></pre>
<h2>Конкатенация</h2>
<p>Если у вас есть <code>String</code>, то вы можете присоединить к нему в конец <code>&amp;str</code>:</p>
<pre><code class="language-rust">let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;;

let hello_world = hello + world;
</code></pre>
<p>Но если у вас есть две <code>String</code>, то необходимо использовать <code>&amp;</code>:</p>
<pre><code class="language-rust">let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;.to_string();

let hello_world = hello + &amp;world;
</code></pre>
<p>Это потому, что <code>&amp;String</code> может быть автоматически приведен к <code>&amp;str</code>. Эта
возможность называется «<a href="deref-coercions.html">Приведение при разыменовании</a>».</p>
<h1>Обобщённое программирование</h1>
<p>Иногда, при написании функции или типа данных, мы можем захотеть, чтобы они
работали для нескольких типов аргументов. К счастью, у Rust есть возможность,
которая даёт нам лучший способ реализовать это: обобщённое программирование.
Обобщённое программирование называется «параметрическим полиморфизмом» в
теории типов. Это означает, что типы или функции имеют несколько форм (poly —
кратно, morph — форма) по данному параметру («параметрический»).</p>
<p>В любом случае, хватит о теории типов; давайте рассмотрим какой-нибудь
обобщённый код. Стандартная библиотека Rust предоставляет тип <code>Option&lt;T&gt;</code>,
который является обобщённым типом:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
<p>Часть <code>&lt;T&gt;</code>, которую вы раньше уже видели несколько раз, указывает, что это
обобщённый тип данных. Внутри перечисления, везде, где мы видим <code>T</code>, мы
подставляем вместо этого абстрактного типа тот, который используется в
обобщении. Вот пример использования <code>Option&lt;T&gt;</code> с некоторыми дополнительными
аннотациями типов:</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = Some(5);
</code></pre>
<p>В определении типа мы используем <code>Option&lt;i32&gt;</code>. Обратите внимание, что это очень
похоже на <code>Option&lt;T&gt;</code>. С той лишь разницей, что, в данном конкретном <code>Option</code>,
<code>T</code> имеет значение <code>i32</code>. В правой стороне выражения мы используем <code>Some(T)</code>,
где <code>T</code> равно <code>5</code>. Так как <code>5</code> является представителем типа <code>i32</code>, то типы по
обе стороны совпадают, поэтому компилятор счастлив. Если же они не совпадают, то
мы получим ошибку:</p>
<pre><code class="language-rust,ignore">let x: Option&lt;f64&gt; = Some(5);
// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,
// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)
</code></pre>
<p>Но это не значит, что мы не можем сделать <code>Option&lt;T&gt;</code>, который содержит <code>f64</code>!
Просто типы должны совпадать:</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = Some(5);
let y: Option&lt;f64&gt; = Some(5.0f64);
</code></pre>
<p>Это просто прекрасно. Одно определение — многостороннее использование.</p>
<p>Обобщать можно более, чем по одному параметру. Рассмотрим другой обобщённый тип
из стандартной библиотеки Rust — <code>Result&lt;T, E&gt;</code>:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>Этот тип является обобщённым сразу для <em>двух</em> типов: <code>T</code> и <code>E</code>. Кстати,
заглавные буквы могут быть любыми. Мы могли бы определить <code>Result&lt;T, E&gt;</code> как:</p>
<pre><code class="language-rust">enum Result&lt;A, Z&gt; {
    Ok(A),
    Err(Z),
}
</code></pre>
<p>если бы захотели. Соглашение гласит, что первый обобщённый параметр для 'типа'
должен быть <code>T</code>, и что для 'ошибки' используется <code>E</code>. Но Rust не проверяет
этого.</p>
<p>Тип <code>Result&lt;T, E&gt;</code> предназначен для того, чтобы возвращать результат вычисления,
и имеет возможность вернуть ошибку, если произойдёт какой-либо сбой.</p>
<h2>Обобщённые функции</h2>
<p>Мы можем задавать функции, которые принимают обобщённые типы, с помощью
аналогичного синтаксиса:</p>
<pre><code class="language-rust">fn takes_anything&lt;T&gt;(x: T) {
    // делаем что-то с x
}
</code></pre>
<p>Синтаксис состоит из двух частей: <code>&lt;T&gt;</code> говорит о том, что «эта функция является
обобщённой по одному типу, <code>T</code>», а <code>x: T</code> говорит о том, что «х имеет тип <code>T</code>».</p>
<p>Несколько аргументов могут иметь один и тот же обобщённый тип:</p>
<pre><code class="language-rust">fn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
    // ...
}
</code></pre>
<p>Мы можем написать версию, которая принимает несколько типов:</p>
<pre><code class="language-rust">fn takes_two_things&lt;T, U&gt;(x: T, y: U) {
    // ...
}
</code></pre>
<p>Обобщённые функции наиболее полезны в связке с «ограничениями по типажам», о
которых мы расскажем в главе <a href="traits.html">Типажи</a>.</p>
<h2>Обобщённые структуры</h2>
<p>Вы также можете задать обобщённый тип для <code>struct</code>:</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
</code></pre>
<p>Аналогично функциям, мы также объявляем обобщённые параметры в <code>&lt;T&gt;</code>, а затем
используем их в объявлении типа <code>x: T</code>.</p>
<h1>Типажи</h1>
<p>Типаж --- это возможность объяснить компилятору, что данный тип должен
предоставлять определённую функциональность.</p>
<p>Вы помните ключевое слово <code>impl</code>, используемое для вызова функции через
синтаксис метода?</p>
<pre><code class="language-rust"># #![feature(core)]
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>Типажи схожи, за исключением того, что мы определяем типаж, содержащий лишь
сигнатуру метода, а затем реализуем этот типаж для нужной структуры. Например,
как показано ниже:</p>
<pre><code class="language-rust"># #![feature(core)]
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>Как вы можете видеть, блок <code>trait</code> очень похож на блок <code>impl</code>. Различие состоит
лишь в том, что тело метода не определяется, а определяется только его
сигнатура. Когда мы реализуем типаж, мы используем <code>impl Trait for Item</code>, а не
просто <code>impl Item</code>.</p>
<p>Мы можем использовать типажи для ограничения обобщённых типов. Рассмотрим
похожую функцию, которая также не компилируется, и выводит ошибку:</p>
<pre><code class="language-rust,ignore">fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Rust выводит:</p>
<pre><code class="language-text">error: type `T` does not implement any method in scope named `area`
</code></pre>
<p>Поскольку <code>T</code> может быть любого типа, мы не можем быть уверены, что он реализует
метод <code>area</code>. Но мы можем добавить «ограничение по типажу» к нашему обобщённому
типу <code>T</code>, гарантируя, что он будет соответствовать требованиям:</p>
<pre><code class="language-rust"># trait HasArea {
#     fn area(&amp;self) -&gt; f64;
# }
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Синтаксис <code>&lt;T: HasArea&gt;</code> означает «любой тип, реализующий типаж <code>HasArea</code>».
Так как типажи определяют сигнатуры типов функций, мы можем быть уверены, что
любой тип, который реализует <code>HasArea</code>, будет иметь метод <code>.area()</code>.</p>
<p>Вот расширенный пример того, как это работает:</p>
<pre><code class="language-rust"># #![feature(core)]
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;Площадь этой фигуры равна {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</code></pre>
<p>Ниже показан вывод программы:</p>
<pre><code class="language-text">Площадь этой фигуры равна 3.141593
Площадь этой фигуры равна 1
</code></pre>
<p>Как вы можете видеть, теперь <code>print_area</code> не только является обобщённой
функцией, но и гарантирует, что будет получен корректный тип. Если же мы
передадим некорректный тип:</p>
<pre><code class="language-rust,ignore">print_area(5);
</code></pre>
<p>Мы получим ошибку времени компиляции:</p>
<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>
<p>До сих пор мы добавляли реализации типажей лишь для структур, но реализовать
типаж можно для любого типа. Технически, мы <em>могли бы</em> реализовать <code>HasArea</code> для
<code>i32</code>:</p>
<pre><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;это нелепо&quot;);

        *self as f64
    }
}

5.area();
</code></pre>
<p>Хотя технически это возможно, реализация методов для примитивных типов считается
плохим стилем программирования.</p>
<p>Может показаться, что такой подход легко приводит к бардаку в коде, однако
есть два ограничения, связанные с реализацией типажей, которые мешают коду выйти
из-под контроля. Во-первых, если типаж не определён в нашей области видимости,
он не применяется. Например, стандартная библиотека предоставляет типаж
[<code>Write</code>]<a href="https://doc.rust-lang.org/stable/std/io/trait.Write.html">write</a>, который добавляет типу <code>File</code> функциональность ввода-вывода.
По умолчанию у <code>File</code> не будет этих методов:</p>
<pre><code class="language-rust,ignore">let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Не могу открыть foo.txt&quot;);
let buf = b&quot;whatever&quot;; // литерал строки байт. buf: &amp;[u8; 8]
let result = f.write(buf);
# result.unwrap(); // игнорируем ошибку
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>Сначала мы должны сделать <code>use</code> для типажа <code>Write</code>:</p>
<pre><code class="language-rust,ignore">use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Не могу открыть foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // игнорируем ошибку
</code></pre>
<p>Это скомпилируется без ошибки.</p>
<p>Благодаря такой логике работы, даже если кто-то сделает что-то страшное —
например, добавит методы <code>i32</code>, это не коснётся вас, пока вы не импортируете
типаж.</p>
<p>Второе ограничение реализации типажей --- это то, что или типаж, или тип, для
которого вы реализуете типаж, должен быть реализован вами. Мы могли бы
определить <code>HasArea</code> для <code>i32</code>, потому что <code>HasArea</code> — это наш код. Но если бы
мы попробовали реализовать для <code>i32</code> <code>ToString</code> — типаж, предоставляемый Rust —
мы бы не смогли сделать это, потому что ни типаж, ни тип не реализован нами.</p>
<p>Последнее, что нужно сказать о типажах: обобщённые функции с ограничением по
типажам используют <em>мономорфизацию</em> (<em>mono</em>: один, <em>morph</em>: форма), поэтому они
диспетчеризуются статически. Что это значит? Посмотрите главу
<a href="trait-objects.html">Типажи-объекты</a>, чтобы получить больше информации.</p>
<h1>Множественные ограничения по типажам</h1>
<p>Вы уже видели, как можно ограничить обобщённый параметр типа определённым
типажом:</p>
<pre><code class="language-rust">fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}
</code></pre>
<p>Если вам нужно больше одного ограничения, вы можете использовать <code>+</code>:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>Теперь тип <code>T</code> должен реализовавать как типаж <code>Clone</code>, так и типаж <code>Debug</code>.</p>
<h1>Утверждение where</h1>
<p>Написание функций с несколькими обобщёнными типами и небольшим количеством
ограничений по типажам выглядит не так уж плохо, но, с увеличением количества
зависимостей, синтаксис получается более неуклюжим:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>Имя функции находится слева, а список параметров — далеко справа. Ограничения
загромождают место.</p>
<p>Есть решение и для этой проблемы, и оно называется «утверждение <code>where</code>»:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Привет&quot;, &quot;мир&quot;);
    bar(&quot;Привет&quot;, &quot;мир&quot;);
}
</code></pre>
<p><code>foo()</code> использует синтаксис, показанный ранее, а <code>bar()</code> использует утверждение
<code>where</code>. Все, что нам нужно сделать, это убрать ограничения при определении
типов параметров, а затем добавить <code>where</code> после списка параметров. В более
длинных списках можно использовать пробелы:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>Такая гибкость может добавить ясности в сложных ситуациях.</p>
<p>На самом деле <code>where</code> не только упрощает написание, это более мощная
возможность. Например:</p>
<pre><code class="language-rust">trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// может быть вызван с T == i32
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// может быть вызван с T == i64
fn inverse&lt;T&gt;() -&gt; T
        // использует ConvertTo как если бы это было «ConvertFrom&lt;i32&gt;»
        where i32: ConvertTo&lt;T&gt; {
    1i32.convert()
}
</code></pre>
<p>Этот код демонстрирует дополнительные преимущества использования утверждения
<code>where</code>: оно позволяет задавать ограничение, где с левой стороны располагается
произвольный тип (в данном случае <code>i32</code>), а не только простой параметр типа
(вроде <code>T</code>).</p>
<h1>Методы по умолчанию</h1>
<p>Есть еще одна особенность типажей, о которой стоит поговорить: методы по
умолчанию. Проще всего показать это на примере:</p>
<pre><code class="language-rust">trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
</code></pre>
<p>В типах, реализующих типаж <code>Foo</code>, нужно реализовать метод <code>is_valid()</code>, а
<code>is_invalid()</code> будет реализован по-умолчанию. Его поведение можно
переопределить:</p>
<pre><code class="language-rust"># trait Foo {
#     fn is_valid(&amp;self) -&gt; bool;
#
#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
# }
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Вызван UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Вызван OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Вызван OverrideDefault.is_invalid!&quot;);
        true // эта реализация противоречит сама себе!
    }
}

let default = UseDefault;
assert!(!default.is_invalid()); // печатает «Вызван UseDefault.is_valid.»

let over = OverrideDefault;
assert!(over.is_invalid()); // печатает «Вызван OverrideDefault.is_invalid!»
</code></pre>
<h1>Наследование</h1>
<p>Иногда чтобы реализовать один типаж, нужно реализовать типажи, от которых он
зависит:</p>
<pre><code class="language-rust">trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}
</code></pre>
<p>Типы, реализующие <code>FooBar</code>, должны реализовывать <code>Foo</code>:</p>
<pre><code class="language-rust"># trait Foo {
#     fn foo(&amp;self);
# }
# trait FooBar : Foo {
#     fn foobar(&amp;self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
</code></pre>
<p>Если мы забудем реализовать <code>Foo</code>, компилятор скажет нам об этом:</p>
<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>
<h1>Типаж <code>Drop</code> (сброс)</h1>
<p>Мы обсудили типажи. Теперь давайте поговорим о конкретном типаже,
предоставляемом стандартной библиотекой Rust. Этот типаж — [<code>Drop</code>]<a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">drop</a>
(сброс) — позволяет выполнить некоторый код, когда значение выходит из области
видимости. Например:</p>
<pre><code class="language-rust">struct HasDrop;

impl Drop for HasDrop {
    fn drop(&amp;mut self) {
        println!(&quot;Сбрасываем!&quot;);
    }
}

fn main() {
    let x = HasDrop;

    // сделаем что-то

} // тут x выходит из области видимости
</code></pre>
<p>Когда <code>x</code> выходит из области видимости в конце <code>main()</code>, исполнится код
реализации типажа <code>Drop</code>. У него один метод, который тоже называется <code>drop()</code>.
Он принимает изменяемую ссылку на себя (<code>self</code>).</p>
<p>Вот и всё! Работа <code>Drop</code> достаточно проста, но есть несколько
тонкостей. Например, значения сбрасываются в порядке, обратном порядку их
объявления. Вот ещё пример:</p>
<pre><code class="language-rust">struct Firework {
    strength: i32,
}

impl Drop for Firework {
    fn drop(&amp;mut self) {
        println!(&quot;БАБАХ силой {}!!!&quot;, self.strength);
    }
}

fn main() {
    let firecracker = Firework { strength: 1 };
    let tnt = Firework { strength: 100 };
}
</code></pre>
<p>Этот код выведет следующее:</p>
<pre><code class="language-text">БАБАХ силой 100!!!
БАБАХ силой 1!!!
</code></pre>
<p>Сначала взрывается тринитротолуоловая бомба (<code>tnt</code>), потому что она была
объявлена последней. За ней взрывается шутиха (<code>firecracker</code>). Первым вошёл,
последним вышел.</p>
<p>Так зачем нужен <code>Drop</code>? Часто <code>Drop</code> используют, чтобы освободить ресурсы,
представленные структурой (<code>struct</code>). Например, счётчик ссылок [<code>Arc&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/std/sync/struct.Arc.html">arc</a>
уменьшает число активных ссылок в <code>drop()</code>, и когда оно достигает нуля,
освобождает хранимое значение.</p>
<h1>Конструкция <code>if let</code></h1>
<p>Иногда хочется сделать определённые вещи менее неуклюже. Например,
скомбинировать <code>if</code> и <code>let</code> чтобы более удобно сделать сопоставление с образцом.
Для этого есть <code>if let</code>.</p>
<p>В качестве примера рассмотрим <code>Option&lt;T&gt;</code>. Если это <code>Some&lt;T&gt;</code>, мы хотим вызвать
функцию на этом значении, а если это <code>None</code> — не делать ничего. Вроде такого:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
match option {
    Some(x) =&gt; { foo(x) },
    None =&gt; {},
}
</code></pre>
<p>Здесь необязательно использовать <code>match</code>. <code>if</code> тоже подойдёт:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}
</code></pre>
<p>Но оба этих варианта выглядят странно. Мы можем исправить это с помощью <code>if let</code>:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
</code></pre>
<p>Если <a href="patterns.html">сопоставление с образцом</a> успешно, имена в образце связываются с
соответствующими частями разбираемого значения, и блок исполняется. Если
значение не соответствует образцу, ничего не происходит.</p>
<p>Если вы хотите делать что-то ещё при несовпадении с образцом, используйте
<code>else</code>:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
# fn bar() { }
if let Some(x) = option {
    foo(x);
} else {
    bar();
}
</code></pre>
<h2><code>while let</code></h2>
<p>Похожим образом, <code>while let</code> можно использовать для перебора значений, пока
они соответствуют образцу. Код вроде такого:</p>
<pre><code class="language-rust"># let option: Option&lt;i32&gt; = None;
loop {
    match option {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        _ =&gt; break,
    }
}
</code></pre>
<p>Превращается в такой:</p>
<pre><code class="language-rust"># let option: Option&lt;i32&gt; = None;
while let Some(x) = option {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<h1>Типажи-объекты</h1>
<p>Когда код включает в себя полиморфизм, то должен быть механизм, чтобы
определить, какая конкретная версия будет фактически вызвана. Это называется
'диспетчеризация.' Есть две основные формы диспетчеризации: статическая и
динамическая. Хотя Rust и отдает предпочтение статической диспетчеризации, он
также поддерживает динамическую диспетчеризацию через механизм, называемый
'типажи-объекты.'</p>
<h2>Подготовка</h2>
<p>Для остальной части этой главы нам потребуется типаж и несколько его реализаций.
Давайте создадим простой типаж <code>Foo</code>. Он содержит один метод, который возвращает
<code>String</code>.</p>
<pre><code class="language-rust">trait Foo {
    fn method(&amp;self) -&gt; String;
}
</code></pre>
<p>Также мы реализуем этот типаж для <code>u8</code> и <code>String</code>:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}
</code></pre>
<h2>Статическая диспетчеризация</h2>
<p>Мы можем использовать этот типаж для выполнения статической диспетчеризации с
помощью ограничения типажом:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something&lt;T: Foo&gt;(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something(x);
    do_something(y);
}
</code></pre>
<p>Здесь Rust использует 'мономорфизацию' для статической диспетчеризации. Это
означает, что Rust создаст специальную версию <code>do_something()</code> для каждого из
типов: <code>u8</code> и <code>String</code>, а затем заменит все места вызовов на вызовы этих
специализированных функций. Другими словами, Rust сгенерирует нечто вроде этого:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something_u8(x);
    do_something_string(y);
}
</code></pre>
<p>Статическая диспетчеризация имеет большой потенциал: она позволяет вызывать
функцию, которая будет встроена, потому что вызываемая версия этой функции
известна на этапе компиляции, а встраивание — это ключ к хорошей оптимизации.
Статическая диспетчеризация быстра, но это достигается путем компромисса:
происходит 'раздувание кода' в связи с большим количеством копий одной и той же
функции, по одной для каждого типа, расположенных в бинарном файле.</p>
<p>Кроме того, компиляторы не совершенны и могут «оптимизировать» код так, что он
станет медленнее. Например, встроенные функции будут слишком охотно раздувать
кэш команд (правила кэширования все вокруг нас). Это одна из причин, по которой
<code>#[inline]</code> и <code>#[inline(always)]</code> следует использовать осторожно, и почему
использование динамической диспетчеризации иногда более эффективно.</p>
<p>Тем не менее, в общем случае более эффективно использовать статическую
диспетчеризацию. Кроме того, всегда можно иметь тонкую статически-
диспетчеризуемую обертку для функции, которая выполняет динамическую
диспетчеризацию, но не наоборот. То есть статические вызовы являются более
гибкими. По этой причине стандартная библиотека старается быть статически
диспетчеризуемой везде, где это возможно.</p>
<h2>Динамическая диспетчеризация</h2>
<p>Rust обеспечивает динамическую диспетчеризацию через механизм под названием
'типажи-объекты'. Типажи-объекты, такие как <code>&amp;Foo</code> или <code>Box&lt;Foo&gt;</code>, это обычные
переменные, хранящие значения <em>любого</em> типа, реализующего данный типаж.
Конкретный тип типажа-объекта может быть определен только на этапе выполнения.</p>
<p>Типаж-объект может быть получен из указателя на конкретный тип, который
реализует этот типаж, путем его <code>явного приведения</code> (например, <code>&amp;x as &amp;Foo</code>) или
<code>неявного приведения</code> (например, используя <code>&amp;x</code> в качестве аргумента функции,
которая принимает <code>&amp;Foo</code>).</p>
<p>Явное и неявное приведение типажа-объекта также работает для таких указателей,
как <code>&amp;mut T</code> в <code>&amp;mut Foo</code> и <code>Box&lt;T&gt;</code> в <code>Box&lt;Foo&gt;</code>, но это все на данный момент.
Явное и неявное приведение идентичны.</p>
<p>Эта операция может рассматриваться как «затирание» знания компилятора о
конкретном типе указателя, поэтому типажи-объекты иногда называют «затиранием
типов».</p>
<p>Возвращаясь к примеру выше, мы можем использовать тот же самый типаж для
выполнения динамической диспетчеризации с типажами-объектами путем явного
приведения типа:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&amp;x as &amp;Foo);
}
</code></pre>
<p>или неявного приведения типа:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
}
</code></pre>
<p>Функция, которая принимает типаж-объект, не обладает специализированными копиями
для каждого из типов, которые реализуют типаж <code>Foo</code>: генерируется только одна
копия. Часто (но не всегда), в результате происходит уменьшение раздувания кода.
Тем не менее, это происходит за счет более медленного вызова виртуальных
функций, и, по существу, блокирования любой возможности встраивания и связанных
с этим оптимизаций.</p>
<h3>Почему указатели?</h3>
<p>В отличие от многих управляемых языков, Rust по умолчанию не размещает значения
по указателю, так как типы могут иметь различные размеры. Знать размер значения
во время компиляции важно прежде всего для выполнения таких задач, как передача
значения в качестве аргумента в функцию, что вызывает помещение переданного
значения в стек, и выделение (и освобождение) места на куче для сохранения
значения там.</p>
<p>Для <code>Foo</code> допускается иметь значение, которое может быть либо <code>String</code> (24
байт), либо <code>u8</code> (1 байт), либо любой другой тип, для которого в соответствующих
крейтах может быть реализован <code>Foo</code> (возможно абсолютно любое число байт). Так
как этот другой тип может быть сколь угодно большими, то нет никакого способа,
гарантирующего, что последний вариант будет работать, если значения сохраняются
без указателя.</p>
<p>Размещение значения по указателю означает, что, когда мы имеем дело с типажом-
объектом, размер самого значения не важен, а важен лишь размер указателя.</p>
<h3>Представление</h3>
<p>Методы типажа можно вызвать для типажа-объекта с помощью специальной записи
указателей на функции, традиционно называемой 'виртуальная таблица' ('vtable')
(создается и управляется компилятором).</p>
<p>Типажи-объекты являются одновременно и простыми и сложными: их основное
представление и устройство довольно прямолинейно, но есть некоторые тонкости
относительно обнаружения сообщений об ошибках и странного поведения.</p>
<p>Давайте начнем с простого, с рантайм представления типажа-объекта. Модуль
<code>std::raw</code> содержит структуры с макетами, которые являются такими же, как и
сложные встроенные типы, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">в том числе типажи-объекты</a>:</p>
<pre><code class="language-rust"># mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
# }
</code></pre>
<p>То есть типаж-объект, такой как <code>&amp;Foo</code>, состоит из указателя на «данные» и
указателя на «виртуальную таблицу».</p>
<p>Указатель <code>data</code> адресует данные (какого-то неизвестного типа <code>T</code>), которые
хранит типаж-объект, а указатель <code>vtable</code> указывает на виртуальную таблицу
(«таблица виртуальных методов»), которая соответствует реализации <code>Foo</code> для <code>T</code>.</p>
<p>По существу, виртуальная таблица — это структура указателей на функции,
указывающих на конкретный кусок машинного кода для каждого метода в реализации.
Вызов метода наподобие <code>trait_object.method()</code> возвращает правильный указатель
из виртуальной таблицы, а затем динамически вызывает метод по этому указателю.
Например:</p>
<pre><code class="language-rust,ignore">struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}

// u8:

fn call_method_on_u8(x: *const ()) -&gt; String {
    // компилятор гарантирует, что эта функция вызывается только
    // с `x`, указывающим на u8
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* магия компилятора */,
    size: 1,
    align: 1,

    // преобразование в указатель на функцию
    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:

fn call_method_on_String(x: *const ()) -&gt; String {
    // компилятор гарантирует, что эта функция вызывается только
    // с `x`, указывающим на String
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* магия компилятора */,
    // значения для 64-битного компьютера, для 32-битного они в 2 раза меньше
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};
</code></pre>
<p>Поле <code>destructor</code> в каждой виртуальной таблице указывает на функцию, которая
будет очищать любые ресурсы типа этой виртуальной таблицы, для <code>u8</code> она
тривиальна, но для <code>String</code> она будет освобождать память. Это необходимо для
владельцев типажей-объектов, таких как <code>Box&lt;Foo&gt;</code>, для которых необходимо
очищать выделенную память как для <code>Box</code>, так и для внутреннего типа, когда они
выходят из области видимости. Поля <code>size</code> и <code>align</code> хранят размер затёртого
типа, и его требования к выравниванию; по существу, они не использовался в
момент, так как информация встроенного в деструктор, но будет использоваться в
будущем, так как объекты отличительным признакам постепенно становится более
гибким.</p>
<p>Предположим, у нас есть несколько значений, которые реализуют <code>Foo</code>, тогда явный
вид создания и использования типажей-объектов <code>Foo</code> может выглядеть примерно как
(игнорируются несоответствия типов: в любом случае, они всего лишь указатели):</p>
<pre><code class="language-rust,ignore">let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
    // store the data
    data: &amp;a,
    // store the methods
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
    // store the data
    data: &amp;x,
    // store the methods
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
</code></pre>
<h1>Замыкания</h1>
<p>Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные
функции, которые имеют связанное окружение, называются 'замыкания'. Они так
называются потому что они замыкают свое окружение. Как мы увидим далее, Rust
имеет реально крутую реализацию замыканий.</p>
<h1>Синтаксис</h1>
<p>Замыкания выглядят следующим образом:</p>
<pre><code class="language-rust">let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
</code></pre>
<p>Мы создаем связывание, <code>plus_one</code>, и присваиваем ему замыкание. Аргументы
замыкания располагаются между двумя символами <code>|</code>, а телом замыкания является
выражение, в данном случае: <code>x + 1</code>. Помните, что <code>{ }</code> также является
выражением, поэтому тело замыкания может содержать много строк:</p>
<pre><code class="language-rust">let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
</code></pre>
<p>Обратите внимание, что есть несколько небольших различий между замыканиями и
обычными функциями, определенными с помощью <code>fn</code>. Первое отличие состоит в том,
что для замыкания мы не должны указывать ни типы аргументов, которые оно
принимает, ни тип возвращаемого им значения. Мы можем:</p>
<pre><code class="language-rust">let plus_one = |x: i32| -&gt; i32 { x + 1 };

assert_eq!(2, plus_one(1));
</code></pre>
<p>Но мы не должны. Почему так? В основном, это было сделано из эргономических
соображений (соображений удобства). В то время как для именованных функций явное
указание типа является полезным для таких аспектов как документация и вывод
типа, типы замыканий редко документируют, поскольку они анонимны. К тому же, они
не вызывают «ошибок на расстоянии» (error-at-a-distance), которые могут вызывать
именованные функции. Такие ошибки могут возникать, когда локальное изменение
(например, в теле одной из функций) вызывает изменение вывода типов. Компилятор
пытается подобрать типы в окружающей программе под уже другие типы в изменённой
функции, и часто оказывается, что имена имеют другие типы, нежели мы ожидали. В
результате происходит ошибка «на расстоянии» — возможно, в другой функции,
использующей изменённую.</p>
<p>Второе отличие — синтаксис очень похож, но все же немного отличается. Мы
добавили пробелы здесь, чтобы было нагляднее:</p>
<pre><code class="language-rust">fn  plus_one_v1   (x: i32 ) -&gt; i32 { x + 1 }
let plus_one_v2 = |x: i32 | -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32 |          x + 1  ;
</code></pre>
<p>Есть небольшие различия, но принцип аналогичен.</p>
<h1>Замыкания и их окружение</h1>
<p>Замыкания называются так потому, что они 'замыкают свое окружение.' Это выглядит
следующим образом:</p>
<pre><code class="language-rust">let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
</code></pre>
<p>Это замыкание, <code>plus_num</code>, ссылается на связанную с помощью оператора <code>let</code>
переменную <code>num</code>, расположенную в своей области видимости. Если говорить более
конкретно, то оно заимствует связывание. Если мы сделаем что-то, что
противоречило бы связыванию, то получим ошибку. Например этот код:</p>
<pre><code class="language-rust,ignore">let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &amp;mut num;
</code></pre>
<p>Который выдаст следующие ошибки:</p>
<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &amp;mut num;
}
^
</code></pre>
<p>Подробное и к тому же полезное сообщение об ошибке! Как говорится в этом
сообщении, мы не можем получить изменяемый заем переменной <code>num</code> потому что
замыкание уже заимствует его. Если же мы обеспечим выход замыкания из области
видимости, то мы сможем:</p>
<pre><code class="language-rust">let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &amp;mut num;
</code></pre>
<p>Однако, Rust также может забирать право владения и перемещать свое окружение,
если этого требует замыкание:</p>
<pre><code class="language-rust,ignore">let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!(&quot;{:?}&quot;, nums);
</code></pre>
<p>Этот код выдаст:</p>
<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
</code></pre>
<p><code>Vec&lt;T&gt;</code> обладает правом владения на свое содержимое, и поэтому, когда мы
ссылаемся на него в нашем замыкании, мы должны забрать право владения на <code>nums</code>.
Это тоже самое, как если бы мы передавали <code>nums</code> в функцию, которая забирала бы
право владения на него.</p>
<h2>Перемещающие замыкания (<code>move</code> closures)</h2>
<p>Мы можем заставить наше замыкание забирать право владения на свое окружение с
помощью ключевого слова <code>move</code>:</p>
<pre><code class="language-rust">let num = 5;

let owns_num = move |x: i32| x + num;
</code></pre>
<p>Теперь, когда указано ключевое слово <code>move</code>, переменные следуют нормальной
семантике перемещения. В данном примере <code>5</code> реализует <code>Copy</code>, поэтому <code>owns_num</code>
становится владельцем копии <code>num</code>. Так в чем же разница?</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
</code></pre>
<p>Итак, в этом примере наше замыкание принимает изменяемую ссылку на <code>num</code>. Затем,
когда мы вызываем замыкание <code>add_num</code>, то, как мы и ожидали, оно изменяет
значение внутри. Нам также необходимо объявить <code>add_num</code> как <code>mut</code>, потому что
оно изменяет свое окружение.</p>
<p>Если же мы будем использовать <code>move</code> замыкание, то получим следующие отличия:</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
</code></pre>
<p>Мы всего лишь получаем <code>5</code>. Вместо того, чтобы получать изменяемый заем на
<code>num</code>, мы получаем право владения на копию.</p>
<p>Вот еще один способ думать о <code>move</code> замыканиях: они предоставляют замыкание со
своим собственным фреймом стека. Без <code>move</code> замыкание может быть связано с
фреймом стека, который его создал, в то время как <code>move</code> замыкание содержит свой
собственный фрейм стека. Это означает, например, что вы не можете вернуть не
<code>move</code> замыкание из функции.</p>
<p>Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания,
мы должны поговорить о том, как реализуются замыкания. Как системный язык
программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и
замыкания не являются исключением.</p>
<h1>Реализация замыканий</h1>
<p>Реализация замыканий в Rust немного отличается от других языков. Фактически, она
представляет из себя просто синтаксический сахар для типажей. Перед тем как
читать дальше, настоятельно рекомендуем изучить главу <a href="traits.html">Типажи</a>, а также
главу <a href="trait-objects.html">Типажи-объекты</a>, в которой говорится о типажах-объектах.</p>
<p>Изучили? Хорошо.</p>
<p>Ключ к пониманию того, как замыкания работают изнутри звучит немного странно:
использование <code>()</code> для вызова функции, как например <code>foo()</code>, представляет собой
перегружаемую операцию. Исходя из этого, все остальное встает на свои места. В
Rust мы используем систему типажей для перегрузки операций. Вызов функций не
является исключением. Существуют три отдельных типажа для их перегрузки:</p>
<pre><code class="language-rust"># mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
# }
</code></pre>
<p>Вы можете заметить некоторые различия между этими типажами, но есть одно главное
различие — <code>self</code>: <code>Fn</code> принимает <code>&amp;self</code>, <code>FnMut</code> принимает <code>&amp;mut self</code>,
<code>FnOnce</code> принимает <code>self</code>. Это покрывает все три вида <code>self</code> с помощью обычного
синтаксиса вызова методов. Мы разделили их на три типажа, вместо того, чтобы
иметь один. Это дает нам большее количество контроля над тем, какого вида
замыкания мы можем принять.</p>
<p>Использование <code>|| {}</code> при создании замыканий является синтаксическим сахаром для
этих трех типажей. Rust будет генерировать структуру для окружения, реализующую
(<code>impl</code>) соответствующий типаж, а затем использовать его.</p>
<h1>Передача замыканий в качестве аргументов</h1>
<p>Теперь, когда мы знаем, что замыкания являются типажами, получается, что мы уже
знаем, как принимать и возвращать замыкания: как и любой другой типаж!</p>
<p>Это также означает, что мы можем выбирать между статической и динамической
диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то
вызываемое, вызывает это что-то и возвращает результат:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>Мы передаем наше замыкание <code>|x| x + 2</code>, в функцию <code>call_with_one</code>. Она же
делает то, о чем говорит ее название: вызывает замыкание, передавая ему <code>1</code> в
качестве аргумента.</p>
<p>Давайте рассмотрим сигнатуру функции <code>call_with_one</code> более подробно:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
#    where F : Fn(i32) -&gt; i32 {
#    some_closure(1) }
</code></pre>
<p>Мы принимаем один параметр, который имеет тип <code>F</code>. Мы также возвращаем <code>i32</code>.
Эта часть не интересна. Следующим важным моментом является:</p>
<pre><code class="language-rust"># fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
#   some_closure(1) }
</code></pre>
<p>Так как <code>Fn</code> является типажом, мы можем связать с ним наш обобщенный параметр. В
этом примере, замыкание принимает <code>i32</code> в качестве аргумента и возвращает <code>i32</code>,
поэтому связывание, которое мы используем, выглядит так: <code>Fn(i32) -&gt; i32</code>.</p>
<p>Здесь есть еще один ключевой момент: так как мы ограничиваем обобщённый параметр
с помощью типажа, то будет применена мономорфизация, и поэтому в замыкании будет
использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно).
Во многих языках для замыканий по существу используется выделение памяти в куче,
и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы
можем выделить память для окружения замыкания в стеке и использовать статическую
диспетчеризацию вызова. Это случается довольно часто с итераторами и их
адаптерами, которые нередко принимают замыкания в качестве аргументов.</p>
<p>Конечно, если нам нужна динамическая диспетчеризация, мы также можем
использовать и ее. Обычно для этого случая используется типаж-объект:</p>
<pre><code class="language-rust">fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

let answer = call_with_one(&amp;|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>Теперь наша функция в качетве аргумента принимает типаж-объект <code>&amp;Fn</code>. Поэтому мы
должны создать ссылку на замыкание а затем передать ее в функцию
<code>call_with_one</code>, для этого мы используем <code>&amp;||</code>.</p>
<h1>Возврат замыканий</h1>
<p>Что очень характерно для кода в функциональном стиле — возвращать замыкания в
различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете
столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим
разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Это выдаст следующие длинные, взаимосвязанные ошибки:</p>
<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>
<p>Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет
тип возвращаемого значения. Но так как <code>Fn</code> является типажом, то в качестве него
могут выступать совершенно разные объекты, с разными размерами: много различных
типов могут реализовать <code>Fn</code>. Самый простой способ передать что-то
неопределенного размера — передать ссылку на это что-то, так как ссылки имеют
известный размер. Таким образом, следовало бы написать так:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но тогда мы получим другую ошибку:</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>
<p>Верно. Так как у нас используется ссылка, то мы должны задать ее время жизни.
Так наша функция <code>factory()</code> не принимает никаких аргументов, то элизия
(сокрытие) здесь не уместна. Какое время жизни мы должны выбрать? <code>'static</code>:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но мы получим еще ошибку:</p>
<pre><code class="language-text">error: mismatched types:
 expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
    found `[closure &lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>
<p>Эта ошибка сообщает нам, что ожидается использование <code>&amp;'static Fn(i32) -&gt; i32</code>,
а используется <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Подождите, что?</p>
<p>Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою
собственную <code>struct</code> для окружения и реализует <code>Fn</code> и компанию, то эти типы
являются анонимными. Они существуют исключительно для этого замыкания. Поэтому
Rust показывает их как <code>closure &lt;anon&gt;</code>, а не в виде какого-то автоматически
сгенерированного имени.</p>
<p>Но почему же наше замыкание не реализует <code>&amp;'static Fn</code>? Как мы обсуждали ранее,
замыкание заимствует свое окружение. И в этом случае наше окружение представляет
собой выделеную в стеке память, содержащую значение связанной переменной <code>num</code> -
<code>5</code>. Из-за этого заем имеет срок жизни фрейма стека. Так что, когда мы вернем
это замыкание, то вызов функции будет завершен, а фрейм стека уйдет, и наше
замыкание захватит окружение, содержащее в памяти мусор!</p>
<p>Так что же делать? Этот код <em>почти</em> работает:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>Мы используем типаж-объект, полученный в результате упаковки (<code>Box</code>) типажа
<code>Fn</code>. И остаётся только одна, последняя проблема:</p>
<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>
<p>Мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этим последним
исправлением мы сможем наконец выполнить нашу задачу:</p>
<pre><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>Благодаря изменению внутреннего замыкания на <code>move Fn</code> будет создаваться новый
фрейм стека для нашего замыкания. А благодаря упаковке (<code>Box</code>) замыкания,
получается известный размер возвращаемого значения, и позволяет ему избежать
(быть независимым от) нашего фрейма стека.</p>
<h1>Универсальный синтаксис вызова функций (universal function call syntax)</h1>
<p>Иногда, функции могут иметь одинаковые имена. Рассмотрим этот код:</p>
<pre><code class="language-rust">trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

let b = Baz;
</code></pre>
<p>Если мы попытаемся вызвать <code>b.f()</code>, то получим ошибку:</p>
<pre><code class="language-text">error: multiple applicable methods in scope [E0034]
b.f();
  ^~~
note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</code></pre>
<p>Нам нужен способ указать, какой конкретно метод нужен, чтобы устранить
неоднозначность. Эта возможность называется «универсальный синтаксис вызова
функций», и выглядит это так:</p>
<pre><code class="language-rust"># trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# let b = Baz;
Foo::f(&amp;b);
Bar::f(&amp;b);
</code></pre>
<p>Давайте разберемся.</p>
<pre><code class="language-rust,ignore">Foo::
Bar::
</code></pre>
<p>Эти части вызова задают один из двух видов типажей: <code>Foo</code> и <code>Bar</code>. Это то, что
на самом деле устраняет неоднозначность между двумя методами: Rust вызывает
метод того типажа, имя которого вы используете.</p>
<pre><code class="language-rust,ignore">f(&amp;b)
</code></pre>
<p>Когда мы вызываем метод, используя <a href="method-syntax.html">синтаксис вызова метода</a>, как
например <code>b.f()</code>, Rust автоматически заимствует <code>b</code>, если <code>f()</code> принимает в
качестве аргумента <code>&amp;self</code>. В этом же случае, Rust не будет использовать
автоматическое заимствование, и поэтому мы должны явно передать <code>&amp;b</code>.</p>
<h1>Форма с угловыми скобками</h1>
<p>Форма UFCS, о которой мы только что говорили:</p>
<pre><code class="language-rust,ignore">Trait::method(args);
</code></pre>
<p>Это сокращенная форма записи. Ниже представлена расширенная форма записи,
которая требуется в некоторых ситуациях:</p>
<pre><code class="language-rust,ignore">&lt;Type as Trait&gt;::method(args);
</code></pre>
<p>Синтаксис <code>&lt;&gt;::</code> является средством предоставления подсказки типа. Тип
располагается внутри <code>&lt;&gt;</code>. В этом случае типом является <code>Type as Trait</code>,
указывающий, что мы хотим здесь вызвать <code>Trait</code> версию метода. Часть <code>as Trait</code>
является необязательной, если вызов не является неоднозначным. То же самое что с
угловыми скобками, отсюда и короткая форма.</p>
<p>Вот пример использования длинной формы записи.</p>
<pre><code class="language-rust">trait Foo {
    fn clone(&amp;self);
}

#[derive(Clone)]
struct Bar;

impl Foo for Bar {
    fn clone(&amp;self) {
        println!(&quot;Making a clone of Bar&quot;);

        &lt;Bar as Clone&gt;::clone(self);
    }
}
</code></pre>
<p>Этот код вызывает метод <code>clone()</code> типажа <code>Clone</code>, а не типажа <code>Foo</code>.</p>
<h1>Контейнеры (crates) и модули (modules)</h1>
<p>Когда проект начинает разрастаться, то хорошей практикой разработки программного
обеспечения считается: разбить его на небольшие кусочки, а затем собрать их
вместе. Также важно иметь четко определенный интерфейс, так как часть вашей
функциональности является приватной, а часть — публичной. Для облегчения такого
рода вещей Rust обладает модульной системой.</p>
<h1>Основные термины: контейнеры и модули</h1>
<p>Rust имеет два различных термина, которые относятся к модульной системе:
<em>контейнер</em> и <em>модуль</em>. Контейнер — это синоним <em>библиотеки</em> или <em>пакета</em> на
других языках. Именно поэтому инструмент управления пакетами в Rust называется
Cargo: вы пересылаете ваши контейнеры другим с помощью Cargo. Контейнеры могут
производить исполняемый файл или библиотеку, в зависимости от проекта.</p>
<p>Каждый контейнер имеет неявный <em>корневой модуль</em>, содержащий код для этого
контейнера. В рамках этого базового модуля можно определить дерево суб-модулей.
Модули позволяют разделить ваш код внутри контейнера.</p>
<p>В качестве примера, давайте сделаем контейнер <em>phrases</em>, который выдает нам
различные фразы на разных языках. Чтобы не усложнять пример, мы будем
использовать два вида фраз: «greetings» и «farewells», и два языка для этих
фраз: английский и японский (日本語). Мы будем использовать следующий шаблон
модуля:</p>
<pre><code class="language-text">                                    +-----------+
                                +---| greetings |
                                |   +-----------+
                  +---------+   |
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |
                                |   +-----------+
                                +---| farewells |
                                    +-----------+
</code></pre>
<p>В этом примере, <code>phrases</code> — это название нашего контейнера. Все остальное -
модули. Вы можете видеть, что они образуют дерево, в основании которого
располагается <em>корень</em> контейнера — <code>phrases</code>.</p>
<p>Теперь, когда у нас есть схема, давайте определим модули в коде. Для начала
создайте новый контейнер с помощью Cargo:</p>
<pre><code class="language-bash">$ cargo new phrases
$ cd phrases
</code></pre>
<p>Если вы помните, то эта команда создает простой проект:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>
<p><code>src/lib.rs</code> — корень нашего контейнера, соответствующий <code>phrases</code> в нашей
диаграмме выше.</p>
<h1>Объявление модулей</h1>
<p>Для объявления каждого из наших модулей, мы используем ключевое слово <code>mod</code>.
Давайте сделаем, чтобы наш <code>src/lib.rs</code> выглядел следующим образом:</p>
<pre><code class="language-rust">mod english {
    mod greetings {
    }

    mod farewells {
    }
}

mod japanese {
    mod greetings {
    }

    mod farewells {
    }
}
</code></pre>
<p>После ключевого слова <code>mod</code>, вы задаете имя модуля. Имена модулей следуют
соглашениям, как и другие идентификаторы Rust: <code>lower_snake_case</code>. Содержание
каждого модуля обрамляется в фигурные скобки (<code>{}</code>).</p>
<p>Внутри <code>mod</code> вы можете объявить суб-<code>mod</code>. Мы можем обращаться к суб-модулям с
помощью нотации (<code>::</code>). Так выглядят обращения к нашим четырем вложенным
модулям: <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code> и
<code>japanese::farewells</code>. Так как суб-модули располагаются в пространстве имен
своих родительских модулей, то суб-модули <code>english::greetings</code> и
<code>japanese::greetings</code> не конфликтуют, несмотря на то, что они имеют одинаковые
имена, <code>greetings</code>.</p>
<p>Так как в этом контейнере нет функции <code>main()</code>, и называется он <code>lib.rs</code>, Cargo
соберет этот контейнер в виде библиотеки:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</code></pre>
<p><code>libphrase-hash.rlib</code> — это скомпилированный контейнер. Прежде чем мы
рассмотрим, как его можно использовать из другого контейнера, давайте
разобьем его на несколько файлов.</p>
<h1>Контейнеры с несколькими файлами</h1>
<p>Если бы каждый контейнер мог состоять только из одного файла, тогда этот файл
был бы очень большими. Зачастую легче разделить контейнер на несколько файлов, и
Rust поддерживает это двумя способами.</p>
<p>Вместо объявления модуля наподобие:</p>
<pre><code class="language-rust,ignore">mod english {
    // contents of our module go here
}
</code></pre>
<p>Мы можем объявить наш модуль в виде:</p>
<pre><code class="language-rust,ignore">mod english;
</code></pre>
<p>Если мы это сделаем, то Rust будет ожидать, что найдет либо файл <code>english.rs</code>,
либо файл <code>english/mod.rs</code> с содержимым нашего модуля.</p>
<p>Обратите внимание, что в этих файлах вам не требуется заново объявлять модуль:
это уже сделано при изначальном объявлении <code>mod</code>.</p>
<p>С помощью этих двух приемов мы можем разбить наш контейнер на две директории и
семь файлов:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>
<p><code>src/lib.rs</code> — корень нашего контейнера, и выглядит он следующим образом:</p>
<pre><code class="language-rust,ignore">mod english;
mod japanese;
</code></pre>
<p>Эти два объявления информируют Rust, что следует искать: <code>src/english.rs</code> или
<code>src/english/mod.rs</code>, <code>src/japanese.rs</code> или <code>src/japanese/mod.rs</code>, в зависимости
от нашей структуры. В данном примере мы выбрали второй вариант из-за того, что
наши модули содержат суб-модули. И <code>src/english/mod.rs</code> и <code>src/japanese/mod.rs</code>
выглядят следующим образом:</p>
<pre><code class="language-rust,ignore">mod greetings;
mod farewells;
</code></pre>
<p>В свою очередь, эти объявления информируют Rust, что следует искать:
<code>src/english/greetings.rs</code>, <code>src/japanese/greetings.rs</code>,
<code>src/english/farewells.rs</code>, <code>src/japanese/farewells.rs</code> или
<code>src/english/greetings/mod.rs</code>, <code>src/japanese/greetings/mod.rs</code>,
<code>src/english/farewells/mod.rs</code>, <code>src/japanese/farewells/mod.rs</code>. Так как эти
суб-модули не содержат свои собственные суб-модули, то мы выбрали
<code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code>. Вот так!</p>
<p>Содержание <code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code> являются
пустыми на данный момент. Давайте добавим несколько функций.</p>
<p>Поместите следующий код в <code>src/english/greetings.rs</code>:</p>
<pre><code class="language-rust">fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
</code></pre>
<p>Следующий код в <code>src/english/farewells.rs</code>:</p>
<pre><code class="language-rust">fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
</code></pre>
<p>Следующий код в <code>src/japanese/greetings.rs</code>:</p>
<pre><code class="language-rust">fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
</code></pre>
<p>Конечно, вы можете скопировать и вставить этот код с этой страницы, или просто
напечатать что-нибудь еще. Вам совершенно не обязательно знать, что на японском
языке написано «Konnichiwa», чтобы понять как работает модульная система.</p>
<p>Поместите следующий код в <code>src/japanese/farewells.rs</code>:</p>
<pre><code class="language-rust">fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
</code></pre>
<p>(Это «Sayonara», если вам интересно.)</p>
<p>Теперь у нас есть некоторая функциональность в нашем контейнере, давайте
попробуем использовать его из другого контейнера.</p>
<h1>Импорт внешних контейнеров</h1>
<p>У нас есть библиотечный контейнер. Давайте создадим исполняемый контейнер,
который импортирует и использует нашу библиотеку.</p>
<p>Создайте файл <code>src/main.rs</code> и положите в него следующее: (при этом он не будет
компилироваться)</p>
<pre><code class="language-rust,ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, phrases::japanese::greetings::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, phrases::japanese::farewells::goodbye());
}
</code></pre>
<p>Объявление <code>extern crate</code> информирует Rust о том, что для компиляции и компоновки
кода нам нужен контейнер <code>phrases</code>. После этого объявление мы можем использовать
модули контейнера <code>phrases</code>. Как мы уже упоминали ранее, вы можете использовать
два подряд идущих символа двоеточия для обращения к суб-модулям и функциям
внутри них.</p>
<p>Кроме того, Cargo предполагает, что <code>src/main.rs</code> — это корень бинарного, а не
библиотечного контейнера. Теперь наш пакет содержит два контейнера: <code>src/lib.rs</code>
и <code>src/main.rs</code>. Этот шаблон является довольно распространенным для исполняемых
контейнеров: основная функциональность сосредоточена в библиотечном контейнере,
а исполняемый контейнер использует эту библиотеку. Таким образом, другие
программы также могут использовать библиотечный контейнер, к тому же такой
подход обеспечивает отделение интереса (разделение функциональности).</p>
<p>Хотя этот код все еще не работает. Мы получаем четыре ошибки, которые выглядят
примерно так:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>
<p>По умолчанию все элементы в Rust являются приватными. Давайте поговорим об этом
более подробно.</p>
<h1>Экспорт публичных интерфейсов</h1>
<p>Rust позволяет точно контролировать, какие элементы вашего интерфейса являются
публичными, и поэтому по умолчанию все элементы являются приватными. Чтобы
сделать элементы публичными, вы используете ключевое слово <code>pub</code>. Давайте
сначала сосредоточимся на модуле <code>english</code>, для чего сократим файл <code>src/main.rs</code>
до этого:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());
}
</code></pre>
<p>В файле <code>src/lib.rs</code> в объявлении модуля <code>english</code> давайте добавим модификатор
<code>pub</code>:</p>
<pre><code class="language-rust,ignore">pub mod english;
mod japanese;
</code></pre>
<p>В файле <code>src/english/mod.rs</code> давайте сделаем оба модуля с модификатором <code>pub</code>:</p>
<pre><code class="language-rust,ignore">pub mod greetings;
pub mod farewells;
</code></pre>
<p>В файле <code>src/english/greetings.rs</code> давайте добавим модификатор <code>pub</code> к
объявлению нашей функции <code>fn</code>:</p>
<pre><code class="language-rust,ignore">pub fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
</code></pre>
<p>А также в файле <code>src/english/farewells.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
</code></pre>
<p>Теперь наши контейнеры компилируются, хотя и с предупреждениями о том, что
функции в модуле <code>japanese</code> не используются:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
src/japanese/greetings.rs:1 fn hello() -&gt; String {
src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</code></pre>
<p>Теперь, когда функции являются публичными, мы можем их использовать. Отлично!
Тем не менее, написание <code>phrases::english::greetings::hello()</code> является очень
длинным и неудобным. Rust предоставляет другое ключевое слово, для импорта имен
в текущую область, чтобы для обращения можно было использовать короткие имена.
Давайте поговорим об этом ключевом слове, <code>use</code>.</p>
<h1>Импорт модулей с помощью <code>use</code></h1>
<p>Rust предоставляет ключевое слово <code>use</code>, которое позволяет импортировать имена в
нашу локальную область видимости. Давайте изменим файл <code>src/main.rs</code>, чтобы он
выглядел следующим образом:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings;
use phrases::english::farewells;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());
}
</code></pre>
<p>Две строки, начинающиеся с <code>use</code>, импортируют соответствующие модули в локальную
область видимости, поэтому мы можем обратиться к функциям по гораздо более
коротким именам. По соглашению, при импорте функции, лучшей практикой считается
импортировать модуль, а не функцию непосредственно. Другими словами, вы <em>могли
бы</em> сделать следующее:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::english::farewells::goodbye;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Goodbye in English: {}&quot;, goodbye());
}
</code></pre>
<p>Но такой подход не является идиоматическим. Он значительно чаще приводит к
конфликту имен. Для нашей короткой программы это не так важно, но, как только
программа разрастается, это становится проблемой. Если у нас возникает конфликт
имен, то Rust выдает ошибку компиляции. Например, если мы сделаем функции
<code>japanese</code> публичными, и пытаемся скомпилировать этот код:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::japanese::greetings::hello;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Hello in Japanese: {}&quot;, hello());
}
</code></pre>
<p>Rust выдаст нам сообщение об ошибке во время компиляции:</p>
<pre><code class="language-text">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</code></pre>
<p>Если мы импортируем несколько имен из одного модуля, то нам совсем не
обязательно писать одно и то же много раз. Вместо этого кода:</p>
<pre><code class="language-rust,ignore">use phrases::english::greetings;
use phrases::english::farewells;
</code></pre>
<p>Вы можете использовать сокращение:</p>
<pre><code class="language-rust,ignore">use phrases::english::{greetings, farewells};
</code></pre>
<h2>Реэкспорт с помощью <code>pub use</code></h2>
<p>Вы можете использовать <code>use</code> не просто для сокращения идентификаторов. Вы также
можете использовать его внутри вашего контейнера, чтобы реэкспортировать функцию
из другого модуля. Это позволяет представить внешний интерфейс, который может не
напрямую отображать внутреннюю организацию кода.</p>
<p>Давайте посмотрим на примере. Измените файл <code>src/main.rs</code> следующим образом:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::{greetings,farewells};
use phrases::japanese;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, japanese::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, japanese::goodbye());
}
</code></pre>
<p>Затем измените файл <code>src/lib.rs</code>, чтобы сделать модуль <code>japanese</code> с публичным:</p>
<pre><code class="language-rust,ignore">pub mod english;
pub mod japanese;
</code></pre>
<p>Далее, убедитесь, что обе функции публичные, сперва в
<code>src/japanese/greetings.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
</code></pre>
<p>А затем в <code>src/japanese/farewells.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
</code></pre>
<p>Наконец, измените файл <code>src/japanese/mod.rs</code> вот так:</p>
<pre><code class="language-rust,ignore">pub use self::greetings::hello;
pub use self::farewells::goodbye;

mod greetings;
mod farewells;
</code></pre>
<p>Объявление <code>pub use</code> привносит указанную функцию в эту часть области видимости
нашей модулной иерархии. Так как мы использовали <code>pub use</code> внутри нашего модуля
<code>japanese</code>, то теперь мы можем вызывать функцию <code>phrases::japanese::hello()</code> и
функцию <code>phrases::japanese::goodbye()</code>, хотя код для них расположен в
<code>phrases::japanese::greetings::hello()</code> и
<code>phrases::japanese::farewells::goodbye()</code> соответственно. Наша внутренняя
организация не определяет наш внешний интерфейс.</p>
<p>В этом примере мы используем <code>pub use</code> отдельно для каждой функции, которую
хотим привнести в область <code>japanese</code>. В качестве альтернативы, мы могли бы
использовать шаблонный синтаксис, чтобы включать в себя все элементы из модуля
<code>greetings</code> в текущую область: <code>pub use self::greetings::*</code>.</p>
<p>Что можно сказать о <code>self</code>? По умолчанию объявления <code>use</code> используют абсолютные
пути, начинающиеся с корня контейнера. <code>self</code>, напротив, формирует эти пути
относительно текущего места в иерархии. У <code>use</code> есть еще одна особая форма: вы
можете использовать <code>use super::</code>, чтобы подняться по дереву на один уровень
вверх от вашего текущего местоположения. Некоторые предпочитают думать о <code>self</code>
как о <code>.</code>, а о <code>super</code> как о <code>..</code>, что для многих командных оболочек является
представлением для текущей директории и для родительской директории
соответственно.</p>
<p>Вне <code>use</code>, пути относительны: <code>foo::bar()</code> ссылаться на функцию внутри <code>foo</code>
относительно того, где мы находимся. Если же используется префикс <code>::</code>, то
<code>::foo::bar()</code> будет ссылаться на другой <code>foo</code>, абсолютный путь относительно
корня контейнера.</p>
<p>Кроме того, обратите внимание, что мы использовали <code>pub use</code> прежде, чем
объявили наши модули с помощью <code>mod</code>. Rust требует, чтобы объявления <code>use</code> шли в
первую очередь.</p>
<p>Следующий код собирается и работает:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</code></pre>
<h1><code>const</code> и <code>static</code></h1>
<p>В Rust можно определить постоянную с помощью ключевого слова <code>const</code>:</p>
<pre><code class="language-rust">const N: i32 = 5;
</code></pre>
<p>В отличие от обычных имён, объявляемых с помощью [<code>let</code>]<a href="variable-bindings.html">let</a>, тип постоянной
надо указывать всегда.</p>
<p>Постоянные живут в течение всего времени работы программы. А именно, у них
вообще нет определённого адреса в памяти. Это потому, что они встраиваются
(inline) в каждое место, где есть их использование. По этой причине ссылки на
одну и ту же постоянную не обязаны указывать на один и тот же адрес в памяти.</p>
<h1><code>static</code></h1>
<p>В Rust также можно объявить что-то вроде «глобальной переменной», используя
статические значения. Они похожи на постоянные, но статические значения
не встраиваются в место их использования. Это значит, что каждое значение
существует в единственном экземпляре, и у него есть определённый адрес.</p>
<p>Вот пример:</p>
<pre><code class="language-rust">static N: i32 = 5;
</code></pre>
<p>Так же, как и в случае с постоянными, тип статического значения надо указывать
всегда.</p>
<p>Статические значения живут в течение всего времени работы программы, и любая
ссылка на постоянную имеет <a href="lifetimes.html">статическое время жизни</a> (<code>static</code>
lifetime):</p>
<pre><code class="language-rust">static NAME: &amp;'static str = &quot;Steve&quot;;
</code></pre>
<h2>Изменяемость</h2>
<p>Вы можете сделать статическое значение изменяемым с помощью ключевого слова
<code>mut</code>:</p>
<pre><code class="language-rust">static mut N: i32 = 5;
</code></pre>
<p>Поскольку <code>N</code> изменяемо, один поток может изменить его во время того, как другой
читает его значение. Это ситуация «гонки» по данным, и она считается
небезопасным поведением в Rust. Поэтому и чтение, и изменение статического
изменяемого значения (<code>static mut</code>) является <a href="unsafe.html">небезопасным</a> (unsafe), и
обе эти операции должны выполняться в небезопасных блоках (<code>unsafe</code> block):</p>
<pre><code class="language-rust"># static mut N: i32 = 5;

unsafe {
    N += 1;

    println!(&quot;N: {}&quot;, N);
}
</code></pre>
<p>Более того, любой тип, хранимый в статической переменной, должен быть ограничен
<code>Sync</code> и не может иметь реализации [<code>Drop</code>]<a href="drop.html">drop</a>.</p>
<h1>Инициализация</h1>
<p>И постоянные, и статические значения имеют определённые требования к тому, что
можно хранить в них. Они могут быть проинициализированы только выражением,
значение которого постоянно. Другими словами, вы не можете использовать вызов
функции или что-то, вычисляемое во время исполнения.</p>
<h1>Какую конструкцию стоит использовать?</h1>
<p>Почти всегда стоит предпочитать постоянные. Ситуация, когда вам нужно реальное
место в памяти и соответствующий ему адрес довольно редка. А использование
постоянных позволяет компилятору провести оптимизации вроде распространения
постоянных (constant propagation) не только в вашем контейнере, но и в тех,
которые зависят от него.</p>
<h1>Атрибуты</h1>
<p>В Rust объявления могут быть аннотированы с помощью «атрибутов». Они выглядят
так:</p>
<pre><code class="language-rust">#[test]
# fn foo() {}
</code></pre>
<p>или так:</p>
<pre><code class="language-rust"># mod foo {
#![test]
# }
</code></pre>
<p>Разница между ними состоит в символе <code>!</code>, который изменяет его поведение,
определяющее к какому элементу применяется атрибут:</p>
<pre><code class="language-rust,ignore">#[foo]
struct Foo;

mod bar {
    #![bar]
}
</code></pre>
<p>Атрибут <code>#[foo]</code> относится к следующему за ним элементу, который является
объявлением <code>struct</code>. Атрибут <code>#![bar]</code> относится к элементу охватывающему его,
который является объявлением <code>mod</code>. В остальном они одинаковы. Оба каким-то
образом изменяют значение элемента, к которому они прикреплены.</p>
<p>Например, рассмотрим такую функцию:</p>
<pre><code class="language-rust">#[test]
fn check() {
    assert_eq!(2, 1 + 1);
}
</code></pre>
<p>Функция помечена как <code>#[test]</code>. Это означает, что она особенная: эта функция
будет выполняться при запуске <a href="testing.html">тестов</a>. При компиляции, как правило, она
не будет включена. Теперь эта функция является функцией тестирования.</p>
<p>Атрибуты также могут иметь дополнительные данные:</p>
<pre><code class="language-rust">#[inline(always)]
fn super_fast_fn() {
# }
</code></pre>
<p>Или даже ключи и значения:</p>
<pre><code class="language-rust">#[cfg(target_os = &quot;macos&quot;)]
mod macos_only {
# }
</code></pre>
<p>Атрибуты в Rust используются для ряда различных вещей. Вот <a href="https://doc.rust-lang.org/stable/reference.html#attributes">ссылка</a>
на полный список атрибутов. В настоящее время вы не можете создавать свои
собственные атрибуты, компилятор Rust определяет их.</p>
<h1>Псевдонимы типов</h1>
<p>Ключевое слово <code>type</code> позволяет объявить псевдоним другого типа:</p>
<pre><code class="language-rust">type Name = String;
</code></pre>
<p>Затем вы можете использовать этот псевдоним вместо реального типа:</p>
<pre><code class="language-rust">type Name = String;

let x: Name = &quot;Hello&quot;.to_string();
</code></pre>
<p>Однако, обратите внимание на то что <em>псевдоним</em> не объявляет новый тип. Rust
строго типизированный язык, например у вас не получится сравнить значения двух
различных типов:</p>
<pre><code class="language-rust,ignore">let x: i32 = 5;
let y: i64 = 5;

if x == y {
   // ...
}
</code></pre>
<p>Вы получите ошибку при компиляции:</p>
<pre><code class="language-text">error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
</code></pre>
<p>Но если мы используем псевдоним:</p>
<pre><code class="language-rust">type Num = i32;

let x: i32 = 5;
let y: Num = 5;

if x == y {
   // ...
}
</code></pre>
<p>То этот пример скомпилируется без ошибок. Значения типа <code>Num</code> всегда будут такие
же как и у типа <code>i32</code>.</p>
<p>Вы также можете использовать псевдонимы типов с обобщённым кодом:</p>
<pre><code class="language-rust">use std::result;

enum ConcreteError {
    Foo,
    Bar,
}

type Result&lt;T&gt; = result::Result&lt;T, ConcreteError&gt;;
</code></pre>
<p>В этом примере мы создаем свою версию типа <code>Result</code>, который всегда будет
использовать перечисление <code>ConcreteError</code> в <code>Result&lt;T, E&gt;</code> вместо типа <code>E</code>.
Псевдонимы типов часто используются в модулях стандартной библиотеки для
создания своих псевдонимов для <code>Result&lt;T, E&gt;</code>. Например, <a href="http://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
<h1>Приведение типов</h1>
<p>Rust, со своим акцентом на безопасность, обеспечивает два различных способа
преобразования различных типов между собой. Первый — <code>as</code>, для безопасного
приведения. Второй — <code>transmute</code>, в отличие от первого, позволяет произвольное
приведение типов и является одной из самых опасных возможностей Rust!</p>
<h1><code>as</code></h1>
<p>Ключевое слово <code>as</code> выполняет обычное приведение типов:</p>
<pre><code class="language-rust">let x: i32 = 5;

let y = x as i64;
</code></pre>
<p>Оно допускает только определенные виды приведения типов:</p>
<pre><code class="language-rust,ignore">let a = [0u8, 0u8, 0u8, 0u8];

let b = a as u32; // four eights makes 32
</code></pre>
<p>Это приведет к ошибке:</p>
<pre><code class="language-text">error: non-scalar cast: `[u8; 4]` as `u32`
let b = a as u32; // four eights makes 32
        ^~~~~~~~
</code></pre>
<p>Это «нескалярное преобразование», потому что у нас здесь преобразуются
множественные значения: четыре элемента массива. Такие виды преобразований очень
опасны, потому что они делают предположения о том, как реализованы множественные
нижележащие структуры. Поэтому нам нужно что-то более опасное.</p>
<h1><code>transmute</code></h1>
<p>Функция <code>transmute</code> предоставляется <a href="intrinsics.html">внутренними средствами компилятора</a>, и то, что она делает, является очень простым, но в то же время
очень опасным. Она сообщает Rust, чтобы он воспринимал значение одного типа, как
будто это значение другого типа. Это делается независимо от системы проверки
типов, и поэтому полностью на ваш страх и риск.</p>
<p>В предыдущем примере, мы знаем, что массив из четырех <code>u8</code> отображается в массив
<code>u32</code> должным образом, и поэтому мы хотим выполнить приведение. Если вместо <code>as</code>
использовать <code>transmute</code>, то Rust позволит это сделать:</p>
<pre><code class="language-rust">use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);
}
</code></pre>
<p>Для того чтобы компиляция прошла успешно, мы должны обернуть эту операцию в
<code>unsafe</code> блок. Технически, только вызов <code>mem::transmute</code> должен быть выполнен в
небезопасном блоке, но в данном случае хорошо было бы поместить в этот блок все
необходимое, связаное с этим вызовом, чтобы было удобнее искать. В данном
примере связаной необходимой переменной является <code>a</code>, и поэтому она находится в
блоке. Код может быть в любом стиле, иногда контекст расположен слишком далеко,
и тогда упаковка всего кода в <code>unsafe</code> не будет такой уж хорошей идеей.</p>
<p>Хотя при использовании <code>transmute</code> и выполняется очень мало проверок, но как
минимум будет проверяться, что типы имеют одинаковый размер. Нижеприведенный код
завершится ошибкой:</p>
<pre><code class="language-rust,ignore">use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u64&gt;(a);
}
</code></pre>
<p>со следующим описанием:</p>
<pre><code class="language-text">error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
(64 bits)
</code></pre>
<p>Все, кроме этой одной проверки, на ваш страх и риск!</p>
<h1>Ассоциированные типы</h1>
<p>Ассоциированные (связанные) типы — это мощная часть системы типов в Rust. Они
связаны с идеей 'семейства типа', другими словами, группировки различных типов
вместе. Это описание немного абстрактно, так что давайте разберем на примере.
Если вы хотите написать типаж <code>Graph</code>, то нужны два обобщенных параметра типа:
тип узел и тип ребро. Исходя из этого, вы можете написать типаж <code>Graph&lt;N, E&gt;</code>,
который выглядит следующим образом:</p>
<pre><code class="language-rust">trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;
    // etc
}
</code></pre>
<p>Такое решение вроде бы достигает своей цели, но, в конечном счете, является
неудобным. Например, любая функция, которая принимает <code>Graph</code> в качестве
параметра, <em>также</em> должна быть обобщённой с параметрами <code>N</code> и <code>E</code>:</p>
<pre><code class="language-rust,ignore">fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 { ... }
</code></pre>
<p>Наша функция расчета расстояния работает независимо от типа <code>Edge</code>, поэтому
параметр <code>E</code> в этой сигнатуре является лишним и только отвлекает.</p>
<p>Что действительно нужно заявить, это чтобы сформировать какого-либо вида
<code>Graph</code>, нужны соответствующие типы <code>E</code> и <code>N</code>, собранные вместе. Мы можем
сделать это с помощью ассоциированных типов:</p>
<pre><code class="language-rust">trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
    // etc
}
</code></pre>
<p>Теперь наши клиенты могут абстрагироваться от определенного <code>Graph</code>:</p>
<pre><code class="language-rust,ignore">fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; u32 { ... }
</code></pre>
<p>Больше нет необходимости иметь дело с типом <code>E</code>!</p>
<p>Давайте поговорим обо всем этом более подробно.</p>
<h2>Определение ассоциированных типов</h2>
<p>Давайте построим наш типаж <code>Graph</code>. Вот его определение:</p>
<pre><code class="language-rust">trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
</code></pre>
<p>Достаточно просто. Ассоциированные типы используют ключевое слово <code>type</code>, и
расположены внутри тела типажа, наряду с функциями.</p>
<p>Эти объявления <code>type</code> могут иметь все то же самое, как и при работе с функциями.
Например, если бы мы хотели, чтобы тип <code>N</code> реализовывал <code>Display</code>, чтобы была
возможность печатать узлы, мы могли бы сделать следующее:</p>
<pre><code class="language-rust">use std::fmt;

trait Graph {
    type N: fmt::Display;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
</code></pre>
<h2>Реализация ассоциированных типов</h2>
<p>Типаж, который включает ассоциированные типы, как и любой другой типаж, для
реализации использует ключевое слово <code>impl</code>. Вот простая реализация <code>Graph</code>:</p>
<pre><code class="language-rust"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
struct Node;

struct Edge;

struct MyGraph;

impl Graph for MyGraph {
    type N = Node;
    type E = Edge;

    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
        true
    }

    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
        Vec::new()
    }
}
</code></pre>
<p>Это глупая реализация, которая всегда возвращает <code>true</code> и пустой <code>Vec&lt;Edge&gt;</code>, но
она дает вам общее представление о том, как реализуются такие ​​вещи. Для начала
нужны три <code>struct</code>, одна для графа, одна для узла и одна для ребра. В этой
реализации используются <code>struct</code> для всех трех сущностей, но вполне могли бы
использоваться и другие типы, которые работали бы так же хорошо, если бы
реализация была более продвинутой.</p>
<p>Затем идет строка с <code>impl</code>, которая является такой же, как и при реализации
любого другого типажа.</p>
<p>Далее мы используем знак <code>=</code>, чтобы определить наши ассоциированные типы. Имя
типажа идет слева от знака <code>=</code>, а конкретный тип, для которого мы <code>impl</code> этот
типаж, идет справа. Наконец, мы используем конкретные типы при объявлении
функций.</p>
<h2>Типажи-объекты и ассоциированные типы</h2>
<p>Вот еще немного синтаксиса, о котором следует упомянуть: типажи-объекты. Если вы
попытаетесь создать типаж-объект из ассоциированного типа, как в этом примере:</p>
<pre><code class="language-rust,ignore"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&gt;;
</code></pre>
<p>Вы получите две ошибки:</p>
<pre><code class="language-text">error: the value of the associated type `E` (from the trait `main::Graph`) must
be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Graph`) must be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Мы не сможем создать типаж-объект, подобный этому, потому что у него нет
информации об ассоциированных типах. Вместо этого, мы можем написать так:</p>
<pre><code class="language-rust"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;
</code></pre>
<p>Синтаксис <code>N=Node</code> позволяет нам предоставлять конкретный тип, <code>Node</code>, для
параметра типа <code>N</code>. То же самое и для <code>E=Edge</code>. Если бы мы не предоставляли это
ограничение, то не могли бы знать наверняка, какая <code>impl</code> соответствует этому
типажу-объекту.</p>
<h1>Безразмерные типы</h1>
<p>Большинство типов имеют определённый размер в байтах. Этот размер обычно
известен во время компиляции. Например, <code>i32</code> — это 32 бита, или 4 байта.
Однако, существуют некоторые полезные типы, которые не имеют определённого
размера. Они называются «безразмерными» или «типами динамического размера». Один
из примеров таких типов — это <code>[T]</code>. Этот тип представляет собой
последовательность из определённого числа элементов <code>T</code>. Но мы не знаем, как
много этих элементов, поэтому размер неизвестен.</p>
<p>Rust понимает несколько таких типов, но их использование несколько ограничено.
Есть три ограничения:</p>
<ol>
<li>Мы можем работать с экземпляром безразмерного типа только с помощью
указателя. <code>&amp;[T]</code> будет работать, а <code>[T]</code> — нет.</li>
<li>Переменные и аргументы не могут иметь тип динамического размера.</li>
<li>Только последнее поле структуры может быть безразмерного типа; другие — нет.
Варианты перечислений не могут содержать типы динамического размера в
качестве данных.</li>
</ol>
<p>А зачем это всё? Поскольку мы можем использовать <code>[T]</code> только через указатель,
если бы язык не поддерживал безразмерные типы, мы бы не смогли написать такой
код:</p>
<pre><code class="language-rust,ignore">impl Foo for str {
</code></pre>
<p>или</p>
<pre><code class="language-rust,ignore">impl&lt;T&gt; Foo for [T] {
</code></pre>
<p>Вместо этого, вам бы пришлось написать:</p>
<pre><code class="language-rust,ignore">impl Foo for &amp;str {
</code></pre>
<p>Таким образом, данная реализация работала бы только для <a href="references-and-borrowing.html">ссылок</a>, и не
поддерживала бы другие типы указателей. А реализацию для безразмерного типа
смогут использовать любые указатели, включая определённые пользователем умные
указатели (позже, когда будут исправлены некоторые ошибки).</p>
<h1>?Sized</h1>
<p>Если вы пишете функцию, принимающую тип динамического размера, вы можете
использовать специальное ограничение <code>?Sized</code>:</p>
<pre><code class="language-rust">struct Foo&lt;T: ?Sized&gt; {
    f: T,
}
</code></pre>
<p>Этот <code>?</code> читается как «Т может быть размерным (<code>Sized</code>)». Он означает, что это
ограничение особенное: оно разрешает использование некоторых типов, которые не
могли бы быть использованы в его отсутствие. Таким образом, оно <em>расширяет</em>
множество подходящих типов, а не сужает его. Это можно представить себе как если
бы все типы <code>T</code> неявно были размерными (<code>T: Sized</code>), а <code>?</code> отменял это
ограничение по-умолчанию.</p>
<h1>Перегрузка операций</h1>
<p>Rust позволяет ограниченную форму перегрузки операций. Есть определенные
операции, которые могут быть перегружены. Есть специальные типажи, которые вы
можете реализовать для поддержки конкретной операции между типами. В результате
чего перегружается операция.</p>
<p>Например, операция <code>+</code> может быть перегружена с помощью типажа <code>Add</code>:</p>
<pre><code class="language-rust">use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    let p3 = p1 + p2;

    println!(&quot;{:?}&quot;, p3);
}
</code></pre>
<p>В <code>main</code> мы можем использовать операцию <code>+</code> для двух <code>Point</code>, так как мы
реализовали типаж <code>Add&lt;Output=Point&gt;</code> для <code>Point</code>.</p>
<p>Есть целый ряд операций, которые могут быть перегружены таким образом, и все
связанные с этим типажи расположены в модуле [<code>std::ops</code>]<a href="http://doc.rust-lang.org/std/ops/index.html">stdops</a>. Проверьте эту
часть документации для получения полного списка.</p>
<p>Реализация этих типажей следует паттерну. Давайте посмотрим на типаж
[<code>Add</code>]<a href="http://doc.rust-lang.org/std/ops/trait.Add.html">add</a> более детально:</p>
<pre><code class="language-rust"># mod foo {
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
# }
</code></pre>
<p>В общей сложности здесь присутствуют три типа: тип <code>impl Add</code>, который мы
реализуем, тип <code>RHS</code>, который по умолчанию равен <code>Self</code> и тип <code>Output</code>. Для
выражения <code>let z = x + y</code>: <code>x</code> — это тип <code>Self</code>, <code>y</code> — это тип <code>RHS</code>, а <code>z</code> -
это тип <code>Self::Output</code>.</p>
<pre><code class="language-rust"># struct Point;
# use std::ops::Add;
impl Add&lt;i32&gt; for Point {
    type Output = f64;

    fn add(self, rhs: i32) -&gt; f64 {
        // add an i32 to a Point and get an f64
# 1.0
    }
}
</code></pre>
<p>позволит вам сделать следующее:</p>
<pre><code class="language-rust,ignore">let p: Point = // ...
let x: f64 = p + 2i32;
</code></pre>
<h1>Использование типажей операций в обобщённых структурах</h1>
<p>Теперь, когда мы знаем, как реализованы типажи операций, мы можем реализовать
наш типаж <code>HasArea</code> и структуру <code>Square</code> из <a href="traits.html">главы о типажах</a> более
общим образом:</p>
<pre><code class="language-rust">use std::ops::Mul;

trait HasArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.side * self.side
    }
}

fn main() {
    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 12.0f64,
    };

    println!(&quot;Площадь s: {}&quot;, s.area());
}
</code></pre>
<p>Мы просто объявляем тип-параметр <code>T</code> и используем его вместо <code>f64</code> в определении
<code>HasArea</code> и <code>Square</code>. В реализации нужно сделать более хитрые изменения:</p>
<pre><code class="language-ignore">impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy { ... }
</code></pre>
<p>Чтобы реализовать <code>area</code>, мы должны мочь умножить операнды друг на друга,
поэтому мы объявляем <code>T</code> как реализующий <code>std::ops::Mul</code>. Как и <code>Add</code>, <code>Mul</code>
принимает параметр <code>Output</code>: т.к. мы знаем, что числа не меняют своего типа,
когда их умножают, <code>Output</code> также объявлен как <code>T</code>. <code>T</code> также должен
поддерживать копирование, чтобы Rust не пытался переместить <code>self.side</code> в
возвращаемое значение.</p>
<h1>Преобразования при разыменовании (deref coercions)</h1>
<p>Стандартная библиотека Rust реализует особый типаж, [<code>Deref</code>]<a href="http://doc.rust-lang.org/std/ops/trait.Deref.html">deref</a>. Обычно его
используют, чтобы перегрузить <code>*</code>, операцию разыменования:</p>
<pre><code class="language-rust">use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T,
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: 'a' };
    assert_eq!('a', *x);
}
</code></pre>
<p>Это полезно при написании своих указательных типов. Однако, в языке есть
возможность, связанная с <code>Deref</code>: преобразования при разыменовании. Вот правило:
если есть тип <code>U</code>, и он реализует <code>Deref&lt;Target=T&gt;</code>, значения <code>&amp;U</code> будут
автоматически преобразованы в <code>&amp;T</code>, когда это необходимо. Вот пример:</p>
<pre><code class="language-rust">fn foo(s: &amp;str) {
    // позаимствуем строку на секунду
}

// String реализует Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();

// Поэтому, такой код работает:
foo(&amp;owned);
</code></pre>
<p>Амперсанд перед значением означает, что мы берём ссылку на него. Поэтому <code>owned</code></p>
<ul>
<li>это <code>String</code>, а <code>&amp;owned</code> — <code>&amp;String</code>. Поскольку у нас есть реализация типажа
<code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> разыменуется в <code>&amp;str</code>, что
устраивает <code>foo()</code>.</li>
</ul>
<p>Вот и всё. Это правило — одно из немногих мест в Rust, где типы преобразуются
автоматически. Оно позволяет писать гораздо более гибкий код. Например, тип
<code>Rc&lt;T&gt;</code> реализует <code>Deref&lt;Target=T&gt;</code>, поэтому такой код работает:</p>
<pre><code class="language-rust">use std::rc::Rc;

fn foo(s: &amp;str) {
    // позаимствуем строку на секунду
}

// String реализует Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();
let counted = Rc::new(owned);

// Поэтому, такой код работает:
foo(&amp;counted);
</code></pre>
<p>Мы всего лишь обернули наш <code>String</code> в <code>Rc&lt;T&gt;</code>. Но теперь мы можем передать
<code>Rc&lt;String&gt;</code> везде, куда мы могли передать <code>String</code>. Сигнатура <code>foo</code> не
поменялась, и работает как с одним, так и с другим типом. Этот пример делает два
преобразования: сначала <code>Rc&lt;String</code> преобразуется в <code>String</code>, а потом <code>String</code> в
<code>&amp;str</code>. Rust сделает столько преобразований, сколько возможно, пока типы не
совпадут.</p>
<p>Другая известная реализация, предоставляемая стандартной библиотекой, это
<code>impl Deref&lt;Target=[T]&gt; for Vec&lt;T&gt;</code>:</p>
<pre><code class="language-rust">fn foo(s: &amp;[i32]) {
    // позаимствуем срез на секунду
}

// Vec&lt;T&gt; реализует Deref&lt;Target=[T]&gt;
let owned = vec![1, 2, 3];

foo(&amp;owned);
</code></pre>
<p>Вектора могут разыменовываться в срезы.</p>
<h2>Разыменование и вызов методов</h2>
<p><code>Deref</code> также будет работать при вызове метода. Другими словами, возможен такой
код:</p>
<pre><code class="language-rust">struct Foo;

impl Foo {
    fn foo(&amp;self) { println!(&quot;Foo&quot;); }
}

let f = Foo;

f.foo();
</code></pre>
<p>Несмотря на то, что <code>f</code> — это не ссылка, а <code>foo</code> принимает <code>&amp;self</code>, это будет
работать. Более того, все примеры ниже делают одно и то же:</p>
<pre><code class="language-rust,ignore">f.foo();
(&amp;f).foo();
(&amp;&amp;f).foo();
(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
</code></pre>
<p>Методы <code>Foo</code> можно вызывать и на значении типа <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code>, потому что
компилятор сделает столько разыменований, сколько нужно для совпадения типов.
А разыменование использует <code>Deref</code>.</p>
<h1>Макросы</h1>
<p>К этому моменту вы узнали о многих инструментах Rust, которые нацелены на
абстрагирование и повторное использование кода. Эти единицы повторно
использованного кода имеют богатую смысловую структуру. Например, функции имеют
сигнатуры типа, типы параметров могут имеют ограничения по типажам,
перегруженные функции также могут принадлежать к определенному типажу.</p>
<p>Эта структура означает, что ключевые абстракции Rust имеют мощный механизм
проверки времени компиляции. Но это достигается за счет снижения гибкости. Если
вы визуально определите структуру повторно используемого кода, то вы можете
найти трудным или громоздким выражение этой схемы в виде обобщённой функции,
типажа, или чего-то еще в семантике Rust.</p>
<p>Макросы позволяют абстрагироваться на <em>синтаксическом</em> уровне. Вызов макроса
является сокращением для «расширенной» синтаксической формы. Это расширение
происходит в начале компиляции, до начала статической проверки. В результате,
макросы могут охватить много шаблонов повторного использования кода, которые
невозможны при использовании лишь ключевых абстракций Rust.</p>
<p>Недостатком является то, что код, основанный на макросах, может быть трудным для
понимания, потому что к нему применяется меньше встроенных правил. Подобно
обычной функции, качественный макрос может быть использован без понимания его
реализации. Тем не менее, может быть трудно разработать качественный макрос!
Кроме того, ошибки компилятора в макро коде сложнее интерпретировать, потому что
они описывают проблемы в расширенной форме кода, а не в исходной сокращенной
форме кода, которую используют разработчики.</p>
<p>Эти недостатки делают макросы чем-то вроде «возможности последней инстанции».
Это не означает, что макросы это плохо; они являются частью Rust, потому что
иногда они все же нужны для по-настоящему краткой записи хорошо абстрагированной
части кода. Просто имейте этот компромисс в виду.</p>
<h1>Определение макросов (Макроопределения)</h1>
<p>Вы, возможно, видели макрос <code>vec!</code>, который используется для инициализации
<a href="vectors.html">вектора</a> с произвольным количеством элементов.</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>Его нельзя реализовать в виде обычной функции, так как он принимает любое
количество аргументов. Но мы можем представить его в виде синтаксического
сокращения для следующего кода</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>Мы можем реализовать это сокращение, используя макрос: [^actual]</p>
<p>[^actual]: Фактическое определение <code>vec!</code> в libcollections отличается от
представленного здесь по соображениям эффективности и повторного
использования.</p>
<pre><code class="language-rust">macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
</code></pre>
<p>Ого, тут много нового синтаксиса! Давайте разберем его.</p>
<pre><code class="language-ignore">macro_rules! vec { ... }
</code></pre>
<p>Тут мы определяем макрос с именем <code>vec</code>, аналогично тому, как <code>fn vec</code>
определяло бы функцию с именем <code>vec</code>. При вызове мы неформально пишем имя
макроса с восклицательным знаком, например, <code>vec!</code>. Восклицательный знак
является частью синтаксиса вызова и служит для того, чтобы отличать макрос от
обычной функции.</p>
<h2>Сопоставление (Matching) (Синтаксис вызова макрокоманды)</h2>
<p>Макрос определяется с помощью ряда <em>правил</em>, которые представляют собой варианты
сопоставления с образцом. Выше у нас было</p>
<pre><code class="language-ignore">( $( $x:expr ),* ) =&gt; { ... };
</code></pre>
<p>Это очень похоже на конструкцию <code>match</code>, но сопоставление происходит на уровне
синтаксических деревьев Rust, на этапе компиляции. Точка с запятой не является
обязательной для последнего (только здесь) варианта. «Образец» слева от <code>=&gt;</code>
известен как <em>шаблон совпадений</em> (<em>образец</em>) (<em>обнаружитель совпадений</em>)
(<em>matcher</em>). Он имеет <a href="https://doc.rust-lang.org/stable/reference.html#macros">свою собственную грамматику</a> в
рамках языка.</p>
<p>Образец <code>$x:expr</code> будет соответствовать любому выражению Rust, связывая его
дерево синтаксиса с <em>метапеременной</em> <code>$x</code>. Идентификатор <code>expr</code> является
<em>спецификатором фрагмента</em>; полные возможности перечислены далее в этой главе.
Образец, окруженный <code>$(...),*</code>, будет соответствовать нулю или более выражениям,
разделенным запятыми.</p>
<p>За исключением специального синтаксиса сопоставления с образцом, любые другие
элементы Rust, которые появляются в образце, должны в точности совпадать.
Например,</p>
<pre><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</code></pre>
<p>выведет</p>
<pre><code class="language-text">mode Y: 3
</code></pre>
<p>А с</p>
<pre><code class="language-rust,ignore">foo!(z =&gt; 3);
</code></pre>
<p>мы получим ошибку компиляции</p>
<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>
<h2>Развертывание (Expansion) (Синтаксис преобразования макрокоманды)</h2>
<p>С правой стороны макро правил используется, по большей части, обычный синтаксис
Rust. Но мы можем соединить кусочки раздробленного синтаксиса, захваченные при
сопоставлении с соответствующим образцом. Из предыдущего примера:</p>
<pre><code class="language-ignore">$(
    temp_vec.push($x);
)*
</code></pre>
<p>Каждое соответствующее выражение <code>$x</code> будет генерировать одиночный оператор
<code>push</code> в развернутой форме макроса. Повторение в развернутой форме происходит
синхронно с повторением в форме образца (более подробно об этом чуть позже).</p>
<p>Поскольку <code>$x</code> уже объявлен в образце как выражение, мы не повторяем <code>:expr</code> с
правой стороны. Кроме того, мы не включаем разделителяющую запятую в качестве
части оператора повторения. Вместо этого, у нас есть точка с запятой в пределах
повторяемого блока.</p>
<p>Еще одна деталь: макрос <code>vec!</code> имеет <em>две</em> пары фигурных скобках правой части.
Они часто сочетаются таким образом:</p>
<pre><code class="language-ignore">macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
</code></pre>
<p>Внешние скобки являются частью синтаксиса <code>macro_rules!</code>. На самом деле, вы
можете использовать <code>()</code> или <code>[]</code> вместо них. Они просто разграничивают правую
часть в целом.</p>
<p>Внутренние скобки являются частью расширенного синтаксиса. Помните, что макрос
<code>vec!</code> используется в контексте выражения. Мы используем блок, для записи
выражения с множественными операторами, в том числе включающее <code>let</code> привязки.
Если ваш макрос раскрывается в одно единственное выражение, то дополнительной
слой скобок не нужен.</p>
<p>Обратите внимание, что мы никогда не <em>говорили</em>, что макрос создает выражения.
На самом деле, это не определяется, пока мы не используем макрос в качестве
выражения. Если соблюдать осторожность, то можно написать макрос, развернутая
форма которого будет валидна сразу в нескольких контекстах. Например,
сокращенная форма для типа данных может быть валидной и как выражение, и как
шаблон.</p>
<h2>Повторение (Repetition) (Многовариантность)</h2>
<p>Операции повтора всегда сопутствуют два основных правила:</p>
<ol>
<li><code>$(...)*</code> проходит через один «слой» повторений, для всех <code>$name</code>, которые он
содержит, в ногу, и</li>
<li>каждое <code>$name</code> должно быть под, по крайней мере, стольким количеством
<code>$(...)*</code>, сколько было использовано при сопоставлении. Если оно под большим
числом <code>$(...)*</code>, <code>$name</code> будет дублироваться, при необходимости.</li>
</ol>
<p>Этот причудливый макрос иллюстрирует дублирования переменных из внешних уровней
повторения.</p>
<pre><code class="language-rust">macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</code></pre>
<p>Это наибольшая синтаксиса совпадений. Эти примеры используют конструкцию
<code>$(...)*</code>, которая означает «ноль или более» совпадений. Также вы можете
написать <code>$(...)+</code>, что будет означать «одно или более» совпадений. Обе формы
записи включают необязательный разделитель, располагающийся сразу за закрывающей
скобкой, который может быть любым символом, за исключением <code>+</code> или <code>*</code>.</p>
<p>Эта система повторений основана на
«<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>» (PDF
ссылка).</p>
<h1>Гигиена (Hygiene)</h1>
<p>Некоторые языки реализуют макросы с помощью простой текстовой замены, что
приводит к различным проблемам. Например, нижеприведенная C программа напечатает
<code>13</code> вместо ожидаемого <code>25</code>.</p>
<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>
<p>После развертывания мы получаем <code>5 * 2 + 3</code>, но умножение имеет больший
приоритет чем сложение. Если вы часто использовали C макросы, вы, наверное,
знаете стандартные идиомы для устранения этой проблемы, а также пять или шесть
других проблем. В Rust мы можем не беспокоиться об этом.</p>
<pre><code class="language-rust">macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</code></pre>
<p>Метапеременная <code>$x</code> обрабатывается как единый узел выражения, и сохраняет свое
место в дереве синтаксиса даже после замены.</p>
<p>Другой распространенной проблемой в системе макросов является <em>захват
переменной</em> (<em>variable capture</em>). Вот C макрос, использующий <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C расширение</a>,
который эмулирует блоки выражениий в Rust.</p>
<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>
<p>Вот простой случай использования, применение которого может плохо кончиться:</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>
<p>Он раскрывается в</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
int state = get_log_state();
if (state &gt; 0) {
    printf(&quot;log(%d): %s\n&quot;, state, state);
}
</code></pre>
<p>Вторая переменная с именем <code>state</code> затеняет первую. Это проблема, потому что
команде печати требуется обращаться к ним обоим.</p>
<p>Эквивалентный макрос в Rust обладает требуемым поведением.</p>
<pre><code class="language-rust"># fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</code></pre>
<p>Это работает, потому что Rust имеет <a href="http://en.wikipedia.org/wiki/Hygienic_macro">систему макросов с соблюдением
гигиены</a>. Раскрытие каждого макроса происходит в
отдельном <em>контексте синтаксиса</em>, и каждая переменная обладает меткой контекста
синтаксиса, где она была введена. Это как если бы переменная <code>state</code> внутри
<code>main</code> была бы окрашена в другой «цвет» в отличае от переменной <code>state</code> внутри
макроса, из-за чего они бы не конфликтовали.</p>
<p>Это также ограничивает возможности макросов для внедрения новых связываний
переменных на месте вызова. Код, приведенный ниже, не будет работать:</p>
<pre><code class="language-rust,ignore">macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Вместо этого вы должны передавать имя переменной при вызове, тогда она будет
обладать меткой правильного контекста синтаксиса.</p>
<pre><code class="language-rust">macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Это справедливо для <code>let</code> привязок и меток loop, но не для <a href="https://doc.rust-lang.org/stable/reference.html#items">элементов</a>.
Код, приведенный ниже, компилируется:</p>
<pre><code class="language-rust">macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</code></pre>
<h1>Рекурсия макросов</h1>
<p>Раскрытие макроса также может включать в себя вызовы макросов, в том числе
вызовы того макроса, который раскрывается. Эти рекурсивные макросы могут быть
использованы для обработки древовидного ввода, как показано на этом (упрощенном)
HTML сокращение:</p>
<pre><code class="language-rust"># #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#   // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</code></pre>
<p><a name="debugging-macro-code"></a></p>
<h1>Отладка макросов</h1>
<p>Чтобы увидеть результаты расширения макросов, выполните команду <code>rustc --pretty expanded</code>. Вывод представляет собой целый контейнер, так что вы можете подать
его обратно в <code>rustc</code>, что иногда выдает лучшие сообщения об ошибках, чем при
обычной компиляции. Обратите внимание, что вывод <code>--pretty expanded</code> может иметь
разное значение, если несколько переменных, имеющих одно и то же имя (но разные
контексты синтаксиса), находятся в той же области видимости. В этом случае
<code>--pretty expanded,hygiene</code> расскажет вам о контекстах синтаксиса.</p>
<p><code>rustc</code>, поддерживает два синтаксических расширения, которые помогают с отладкой
макросов. В настоящее время, они неустойчивы и требуют feature gates.</p>
<ul>
<li>
<p><code>log_syntax!(...)</code> будет печатать свои аргументы в стандартный вывод во время
компиляции, и «развертываться» в ничто.</p>
</li>
<li>
<p><code>trace_macros!(true)</code> будет выдавать сообщение компилятора каждый раз, когда
макрос развертывается. Используйте <code>trace_macros!(false)</code> в конце развертывания,
чтобы выключить его.</p>
</li>
</ul>
<h1>Требования синтаксиса</h1>
<p>Код на Rust может быть разобран в <a href="glossary.html#abstract-syntax-tree">синтаксическое дерево</a>, даже когда он
содержит неразвёрнутые макросы. Это свойство очень полезно для редакторов и
других инструментов, обрабатывающих исходный код. Оно также влияет на вид
системы макросов Rust.</p>
<p>Как следствие, когда компилятор разбирает вызов макроса, ему необходимо знать,
во что развернётся данный макрос. Макрос может разворачиваться в следующее:</p>
<ul>
<li>ноль или больше элементов;</li>
<li>ноль или больше методов;</li>
<li>выражение;</li>
<li>оператор;</li>
<li>образец.</li>
</ul>
<p>Вызов макроса в блоке может представлять собой элементы, выражение, или
оператор. Rust использует простое правило для разрешения этой
неоднозначности. Вызов макроса, производящего элементы, должен либо</p>
<ul>
<li>ограничиваться фигурными скобками, т.е. <code>foo! { ... }</code>;</li>
<li>завершаться точкой с запятой, т.е. <code>foo!(...);</code>.</li>
</ul>
<p>Другое следствие разбора перед раскрытием макросов — это то, что вызов макроса
должен состоять из допустимых лексем. Более того, скобки всех видов должны быть
сбалансированы в месте вызова. Например, <code>foo!([)</code> не является разрешённым
кодом. Такое поведение позволяет компилятору понимать где заканчивается вызов
макроса.</p>
<p>Говоря более формально, тело вызова макроса должно представлять собой
последовательность <em>деревьев лексем</em>. Дерево лексем определяется рекурсивно и
представляет собой либо:</p>
<ul>
<li>последовательность деревьев лексем, окружённую согласованными круглыми,
квадратными или фигурными скобками (<code>()</code>, <code>[]</code>, <code>{}</code>);</li>
<li>любую другую одиночную лексему.</li>
</ul>
<p>Внутри сопоставления каждая метапеременная имеет <em>указатель фрагмента</em>,
определяющий синтаксическую форму, с которой она совпадает. Вот список этих
указателей:</p>
<ul>
<li><code>ident</code>: идентификатор. Например: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: квалифицированное имя. Например: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: выражение. Например: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>;
<code>f(42)</code>.</li>
<li><code>ty</code>: тип. Например: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: образец. Например: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
<li><code>stmt</code>: единственный оператор. Например: <code>let x = 3</code>.</li>
<li><code>block</code>: последовательность операторов, ограниченная фигурными
скобками. Например: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: <a href="http://doc.rust-lang.org/reference.html#items">элемент</a>. Например: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: «мета-элемент», как в атрибутах. Например: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: единственное дерево лексем.</li>
</ul>
<p>Есть дополнительные правила относительно лексем, следующих за метапеременной:</p>
<ul>
<li>за <code>expr</code> должно быть что-то из этого: <code>=&gt; , ;</code>;</li>
<li>за <code>ty</code> и <code>path</code> должно быть что-то из этого: <code>=&gt; , : = &gt; as</code>;</li>
<li>за <code>pat</code> должно быть что-то из этого : <code>=&gt; , =</code>;</li>
<li>за другими лексемами могут следовать любые символы.</li>
</ul>
<p>Приведённые правила обеспечивают развитие синтаксиса Rust без необходимости
менять существующие макросы.</p>
<p>И ещё: система макросов никак не обрабатывет неоднозначность разбора. Например,
грамматика <code>$($t:ty)* $e:expr</code> всегда будет выдавать ошибку, потому что
синтаксическому анализатору пришлось бы выбирать между разбором <code>$t</code> и разбором
<code>$e</code>. Можно изменить синтаксис вызова так, чтобы грамматика отличалась в начале.
В данном случае можно написать <code>$(T $t:ty)* E $e:exp</code>.</p>
<h1>Области видимости, импорт и экспорт макросов</h1>
<p>Макросы разворачиваются на ранней стадии компиляции, перед разрешением имён.
Один из недостатков такого подхода в том, что правила видимости для макросов
отличны от правил для других конструкций языка.</p>
<p>Компилятор определяет и разворачивает макросы при обходе графа исходного кода
контейнера в глубину. При этом определения макросов включаются в граф в порядке
их встречи компилятором. Поэтому макрос, определённый на уровне модуля, виден во
всём последующем коде модуля, включая тела всех вложенных модулей (<code>mod</code>).</p>
<p>Макрос, определённый в теле функции, или где-то ещё не на уровне модуля, виден
только внутри этого элемента (например, внутри одной функции).</p>
<p>Если модуль имеет атрибут <code>macro_use</code>, то его макросы также видны в его
родительском модуле после элемента <code>mod</code> данного модуля. Если родитель тоже
имеет атрибут <code>macro_use</code>, макросы также будут видны в модуле-родителе родителя,
после элемента <code>mod</code> родителя. Это распространяется на любое число уровней.</p>
<p>Атрибут <code>macro_use</code> также можно поставить на подключение контейнера <code>extern crate</code>. В этом контексте оно управляет тем, какие макросы будут загружены из
внешнего контейнера, т.е.</p>
<pre><code class="language-rust,ignore">#[macro_use(foo, bar)]
extern crate baz;
</code></pre>
<p>Если атрибут записан просто как <code>#[macro_use]</code>, будут загружены все
макросы. Если атрибута нет, никакие макросы не будут загружены. Загружены могут
быть только макросы, объявленные с атрибутом <code>#[macro_export]</code>.</p>
<p>Чтобы загрузить макросы из контейнера <em>без</em> компоновки контейнера в выходной
артефакт, можно использовать атрибут <code>#[no_link]</code>.</p>
<p>Например:</p>
<pre><code class="language-rust">macro_rules! m1 { () =&gt; (()) }

// здесь видны: m1

mod foo {
    // здесь видны: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // здесь видны: m1, m2
}

// здесь видны: m1

macro_rules! m3 { () =&gt; (()) }

// здесь видны: m1, m3

#[macro_use]
mod bar {
    // здесь видны: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // здесь видны: m1, m3, m4
}

// здесь видны: m1, m3, m4
# fn main() { }
</code></pre>
<p>Когда эта библиотека загружается с помощью <code>#[macro_use] extern crate</code>, виден
только макрос <code>m2</code>.</p>
<p>Атрибуты, относящиеся к макросам,
<a href="https://doc.rust-lang.org/stable/reference.html#macro--and-plugin-related-attributes">перечислены в справочнике Rust</a>.</p>
<h1>Переменная <code>$crate</code></h1>
<p>Если макрос используется в нескольких контейнерах, всё становится ещё
сложнее. Допустим, <code>mylib</code> определяет</p>
<pre><code class="language-rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
# fn main() { }
</code></pre>
<p><code>inc_a</code> работает только внутри <code>mylib</code>, а <code>inc_b</code> — только снаружи. Более того,
<code>inc_b</code> сломается, если пользователь импортирует <code>mylib</code> под другим именем.</p>
<p>В Rust пока нет гигиеничных ссылок на контейнеры, но есть простой способ обойти
эту проблему. Особая макро-переменная <code>$crate</code> раскроется в <code>::foo</code> внутри
макроса, импортированного из контейнера <code>foo</code>. А когда макрос определён и
используется в одном и том же контейнере, <code>$crate</code> станет пустой. Это означает,
что мы можем написать</p>
<pre><code class="language-rust">#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
# fn main() { }
</code></pre>
<p>чтобы определить один макрос, который будет работать и внутри, и снаружи
библиотеки. Имя функции раскроется или в <code>::increment</code>, или в
<code>::mylib::increment</code>.</p>
<p>Чтобы эта система работала просто и правильно, <code>#[macro_use] extern crate ...</code>
может быть написано только в корне вашего контейнера, но не внутри <code>mod</code>. Это
обеспечивает, что <code>$crate</code> раскроется в единственный идентификатор.</p>
<h1>Во тьме глубин</h1>
<p>Вводная глава упоминала рекурсивные макросы, но она не рассказывала всей
истории. Рекурсивные макросы полезны ещё по одной причине: каждый рекурсивный
вызов даёт нам ещё одну возможность сопоставить с образцом аргументы макроса.</p>
<p>Приведём такой радикальный пример использования данной возможности. С помощью
рекурсивных макросов можно реализовать конечный автомат типа
<a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a>. Стоит
заметить, что мы не рекомендуем такой подход, а просто иллюстрируем возможности
макросов.</p>
<pre><code class="language-rust">macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

    // halt on empty data string
    ( $($ps:tt),* ; )
        =&gt; (());
}
</code></pre>
<p>В качестве упражнения предлагаем читателю определить ещё один макрос, чтобы
уменьшить степень дублирования кода в определении выше.</p>
<h1>Распространённые макросы</h1>
<p>Вот некоторые распространённые макросы, которые вы увидите в коде на Rust.</p>
<h2>panic!</h2>
<p>Этот макрос вызывает панику текущего потока. Вы можете указать сообщение, с
которым поток завершится:</p>
<pre><code class="language-rust,no_run">panic!(&quot;о нет!&quot;);
</code></pre>
<h2>vec!</h2>
<p>Макрос <code>vec!</code> используется по всей книге, поэтому вы наверняка уже видели его.
Он упрощает создание <code>Vec&lt;T&gt;</code>:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];
</code></pre>
<p>Он также позволяет вам создавать векторы с повторяющимися значениями. Например,
вот сто нолей:</p>
<pre><code class="language-rust">let v = vec![0; 100];
</code></pre>
<h2>assert! and assert_eq!</h2>
<p>Эти два макроса используются в тестах. <code>assert!</code> принимает логическое значение.
<code>assert_eq!</code> принимает два значения и проверяет, что они равны. <code>true</code>
засчитывается как успех, а <code>false</code> вызывает панику и проваливает тест. Вот так:</p>
<pre><code class="language-rust,no_run">// Работает!

assert!(true);
assert_eq!(5, 3 + 2);

// а это нет :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
</code></pre>
<h2>try!</h2>
<p><code>try!</code> используется для обработки ошибок. Он принимает нечто возвращающее
<code>Result&lt;T, E&gt;</code> и возвращает <code>T</code> если было возвращено <code>Ok&lt;T&gt;</code>; иначе он делает
возврат из функции со значением <code>Err(E)</code>. Вроде такого:</p>
<pre><code class="language-rust,no_run">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create(&quot;foo.txt&quot;));

    Ok(())
}
</code></pre>
<p>Такой код читается легче, чем этот:</p>
<pre><code class="language-rust,no_run">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = File::create(&quot;foo.txt&quot;);

    let f = match f {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
</code></pre>
<h2>unreachable!</h2>
<p>Этот макрос применяется, когда вы хотите пометить какой-то код, который никогда
не должен исполняться:</p>
<pre><code class="language-rust">if false {
    unreachable!();
}
</code></pre>
<p>Иногда вам придётся определять ветви условных конструкций, которые точно никогда
не исполнятся. В таком случае, используйте этот макрос, чтобы в случае ошибки
программа запаниковала:</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!(&quot;Я знаю, что x — это None!&quot;),
}
</code></pre>
<h2>unimplemented!</h2>
<p>Макрос <code>unimplemented!</code> можно использовать, когда вы хотите, чтобы ваш код
прошёл проверку типов, но пока не хотите реализовывать его настоящую логику.
Один из примеров — это реализация типажа с несколькими требуемыми методами.
Возможно, вы хотите разбираться с типажом постепенно — по одному методу за раз.
В таком случае, определите остальные методы как <code>unimplemented!</code>, пока не
захотите наконец реализовать их.</p>
<h1>Процедурные макросы</h1>
<p>Если система макросов не может сделать того, что вам нужно, вы можете написать
<a href="compiler-plugins.html">плагин к компилятору</a>. По сравнению с макросами, это гораздо
труднее, там ещё более нестабильные интерфейсы, и ещё сложнее найти ошибки. Зато
вы получаете гибкость — внутри плагина может исполняться произвольный код на
Rust. Иногда плагины расширения синтаксиса называются <em>процедурными макросами</em>.</p>
<h1>Сырые указатели</h1>
<p>Стандартная библиотека Rust содержит ряд различных типов умных указателей, но
среди них есть два типа, которые экстра-специальные. Большая часть безопасности
в Rust является следствием проверок во время компиляции, но сырье указатели не
имеют конкретных гарантий и являются <a href="unsafe.html">небезопасными</a> для использования.</p>
<p><code>*const T</code> и <code>*mut T</code> в Rust называются «сырыми указателями» (raw pointers).
Иногда, при написании определенных видов библиотек, вам по какой-то причине
нужно обойти гарантии безопасности Rust. В этом случае, вы можете использовать
сырые указатели в реализации вашей библиотеки, вместе с тем предоставляя
безопасный интерфейс для пользователей. Например, <code>*</code> указатели допускают
псевдонимы, позволяя им быть использованными для записи типов с разделяемой
собственности, и даже поточно-безопасные типы памяти (<code>Rc&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code> типы и
реализован полностью в Rust).</p>
<p>Вот некоторые факты о сырых указателях, которые следует помнить и которые
отличают их от других типов указателей. Они:</p>
<ul>
<li>не гарантируют, что они указывают на действительную область памяти, и не
гарантируют, что они является ненулевыми указателями (в отличие от <code>Box</code> и <code>&amp;</code>);</li>
<li>не имеют никакой автоматической очистки, в отличие от <code>Box</code>, и поэтому требуют
ручного управления ресурсами;</li>
<li>это простые структуры данных (plain-old-data), то есть они не перемещают право
собственности, опять же в отличие от <code>Box</code>, следовательно, компилятор Rust не
может защитить от ошибок, таких как использование освобождённой памяти (use-
after-free);</li>
<li>лишены сроков жизни в какой-либо форме, в отличие от <code>&amp;</code>, и поэтому компилятор
не может делать выводы о висячих указателях; и</li>
<li>не имеют никаких гарантий относительно псевдонимизации или изменяемости, за
исключением изменений, недопустимых непосредственно для <code>*const T</code>.</li>
</ul>
<h1>Основы</h1>
<p>Создание сырого указателя совершенно безопасно:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let mut y = 10;
let raw_mut = &amp;mut y as *mut i32;
</code></pre>
<p>А вот его разыменование не является. Следующий код не будет работать:</p>
<pre><code class="language-rust,ignore">let x = 5;
let raw = &amp;x as *const i32;

println!(&quot;raw points at {}&quot;, *raw);
</code></pre>
<p>Он выдает такую ошибку:</p>
<pre><code class="language-text">error: dereference of unsafe pointer requires unsafe function or block [E0133]
     println!(&quot;raw points at{}&quot;, *raw);
                                 ^~~~
</code></pre>
<p>Когда вы разыменовываете сырой указатель, вы принимаете на себя ответственность,
что он не указывает на что-то, что может быть некорректным. Таким образом, вы
должны использовать <code>unsafe</code>:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let points_at = unsafe { *raw };

println!(&quot;raw points at {}&quot;, points_at);
</code></pre>
<p>Для более подробной информации по операциям с сырыми указателями, обратитесь к
<a href="http://doc.rust-lang.org/std/primitive.pointer.html">API документации</a> о них.</p>
<h1>FFI</h1>
<p>Сырые указатели полезны для FFI: <code>*const T</code> и <code>*mut T</code> в Rust приблизительно
соответствуют <code>const T*</code> и <code>T*</code> в C. Для более подробной информации об этом
обратитесь к главе <a href="ffi.html">FFI</a>.</p>
<h1>Ссылки и сырые указатели</h1>
<p>Во время выполнения и сырой указатель, <code>*</code>, и ссылка, указывающая на тот же
кусок данных, имеют одинаковое представление. По факту, ссылка <code>&amp;T</code> будет неявно
приведена к сырому указателю <code>*const T</code> в безопасном коде, аналогично и для
вариантов <code>mut</code> (оба приведения могут быть выполнены явно, с помощью,
соответственно, <code>value as *const T</code> и <code>value as *mut T</code>).</p>
<p>Переход в обратном направлении, от <code>*const</code> к ссылке <code>&amp;</code>, не является безопасным.
Ссылка <code>&amp;T</code> всегда валидна, и поэтому, как минимум, сырой указатель <code>*const T</code>
должен указывать на правильный экземпляр типа <code>T</code>. Кроме того, в результате
указатель должен удовлетворять правилам псевдонимизации и изменяемости ссылок.
Компилятор предполагает, что эти свойства верны для любых ссылок, независимо от
того, как они были созданы, и поэтому любое преобразование из сырых указателей
равносильно утверждению, что они соответствуют этим правилам. Программист
<em>должен</em> гарантировать это.</p>
<p>Рекомендуемым методом преобразования является</p>
<pre><code class="language-rust">let i: u32 = 1;

// explicit cast
let p_imm: *const u32 = &amp;i as *const u32;
let mut m: u32 = 2;

// implicit coercion
let p_mut: *mut u32 = &amp;mut m;

unsafe {
    let ref_imm: &amp;u32 = &amp;*p_imm;
    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
}
</code></pre>
<p>Разыменование с помощью конструкции <code>&amp;*x</code> является более предпочтительным, чем с
использованием <code>transmute</code>. Последнее является гораздо более мощным
инструментом, чем необходимо, а более ограниченное поведение сложнее
использовать неправильно. Например, она требует, чтобы <code>x</code> представляет собой
указатель (в отличие от <code>transmute</code>).</p>
<h1>Небезопасный код</h1>
<p>Главная сила Rust — в мощных статических гарантиях правильности поведения
программы во время исполнения. Но проверки безопасности очень осторожны: на
самом деле, существуют безопасные программы, правильность которых компилятор
доказать не в силах. Чтобы писать такие программы, нужен способ немного ослабить
ограничения. Для этого в Rust есть ключевое слово <code>unsafe</code>. Код, использующий
<code>unsafe</code>, ограничен меньше, чем обычный код.</p>
<p>Давайте рассмотрим синтаксис, а затем поговорим о семантике. <code>unsafe</code>
используется в четырёх контекстах. Первый — это объявление того, что функция
небезопасна:</p>
<pre><code class="language-rust">unsafe fn beregis_avtomobilya() {
    // страшные вещи
}
</code></pre>
<p>Например, все функции, вызываемые через <a href="ffi.html">FFI</a>, должны быть помечены как
небезопасные. Другое использование <code>unsafe</code> — это отметка небезопасного блока:</p>
<pre><code class="language-rust">unsafe {
    // страшные вещи
}
</code></pre>
<p>Третье — небезопасные типажи:</p>
<pre><code class="language-rust">unsafe trait Scary { }
</code></pre>
<p>И четвёртое — реализация (<code>impl</code>) таких типажей:</p>
<pre><code class="language-rust"># unsafe trait Scary { }
unsafe impl Scary for i32 {}
</code></pre>
<p>Важно явно выделить код, ошибки в котором могут вызвать большие проблемы. Если
программа на Rust падает с &quot;segmentation fault&quot;, можете быть уверены —
проблема в участке, помеченном как небезопасный.</p>
<h1>Что значит &quot;безопасный&quot;?</h1>
<p>В контексте Rust &quot;безопасный&quot; значит &quot;не делает ничего небезопасного&quot;. Также
важно знать, что некоторое поведение скорее всего нежелательно, но явно
<em>не</em> считается небезопасным:</p>
<ul>
<li>Deadlock'и</li>
<li>Утечка памяти или других ресурсов</li>
<li>Выход без вызова деструкторов</li>
<li>Целочисленное переполнение</li>
</ul>
<p>Rust не может предотвратить все виды проблем в программах. Код с ошибками может
и будет написан на Rust. Вышеперечисленные вещи неприятны, но они не считаются
именно что небезопасными.</p>
<p>В дополнение к этому, ниже представлен список неопределённого поведения
(undefined behavior) в Rust. Избегайте этих вещей, даже когда пишете
небезопасный код:</p>
<ul>
<li>Гонка данных</li>
<li>Разыменование нулевого или висячего указателя</li>
<li>Чтение <a href="http://llvm.org/docs/LangRef.html#undefined-values">неинициализированной</a> памяти</li>
<li>Нарушение <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">правил о совпадении указателей</a> с помощью сырых
указателей</li>
<li><code>&amp;mut T</code> и <code>&amp;T</code> следуют модели LLVM <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a>, кроме случаев, когда
<code>&amp;T</code> содержит <code>UnsafeCell&lt;U&gt;</code>. Небезопасный код не должен нарушать эти
гарантии совпадения указателей.</li>
<li>Изменение неизменяемого значения или ссылки без использования <code>UnsafeCell&lt;U&gt;</code></li>
<li>Получение неопределённого поведения с помощью intrinsic-операций компилятора:
<ul>
<li>Индексация вне границ объекта с помощью <code>std::ptr::offset</code> (<code>offset</code>
intrinsic), кроме разрешённого случая &quot;один байт за концом объекта&quot;.</li>
<li>Использование <code>std::ptr::copy_nonoverlapping_memory</code> (intrinsic-операции
<code>memcpy32</code>/<code>memcpy64</code>) с пересекающимися буферами</li>
</ul>
</li>
<li>Неправильные значения примитивных типов, даже в скрытых полях:
<ul>
<li>Нулевые или висячие ссылки или упаковки (boxes)</li>
<li>Любое значение логического типа, кроме <code>false</code> (0) или <code>true</code> (1)</li>
<li>Вариант перечисления, не включённый в его определение</li>
<li>Суррогатное значение <code>char</code> или значение <code>char</code>, превыщающее <code>char::MAX</code></li>
<li>Последовательности байт, не являющиеся UTF-8, в <code>str</code></li>
</ul>
</li>
<li>Размотка стека в код на Rust из чужого кода (через границы FFI), или размотка
из кода на Rust в чужой код</li>
</ul>
<h1>Сверхспособности небезопасного кода</h1>
<p>В небезопасном блоке или функции, Rust разрешает три ситуации, которые обычно
запрещены. Всего три. Вот они:</p>
<ol>
<li>Доступ к или изменение <a href="const-and-static.html#static">статической изменяемой переменной</a>.</li>
<li>Разыменование сырого указателя.</li>
<li>Вызов небезопасных функций. Это самая мощная возможность.</li>
</ol>
<p>Это всё. Важно отметить, что <code>unsafe</code>, например, не &quot;выключает проверку
заимствования&quot;. Объявление какого-то кода небезопасным не изменяет его
семантику; небезопасность не означает принятие компилятором любого кода. Но она
позволяет писать вещи, которые <em>нарушают</em> некоторые из правил.</p>
<p>Вы также встретите ключевое слово <code>unsafe</code>, когда будете реализовывать интерфейс
к чужому коду не на Rust. Идиоматичным считается написание безопасных обёрток
вокруг небезопасных библиотек.</p>
<p>Давайте поговорим о трёх упомянутых возможностях, доступных в небезопасном коде.</p>
<h2>Доступ или изменение <code>static mut</code></h2>
<p>Rust позволяет пользоваться глобальным изменяемым состоянием с помощью <code>static mut</code>. Это может вызвать гонку по данным, и в сущности небезопасно. Подробнее
смотрите раздел о <a href="const-and-static.html#static">static</a>.</p>
<h2>Разыменование сырого указателя</h2>
<p>Сырые указатели поддерживают произвольную арифметику указетелей, и могут вызвать
целый ряд проблем безопасности памяти и безопасности в целом. В каком-то смысле,
возможность разыменовать произвольный указатель — одна из самых опасных вещей,
которые вы можете сделать. Подробнее смотрите раздел о
<a href="raw-pointers.html">сырых указателях</a>.</p>
<h2>Вызов небезопасных функций</h2>
<p>Эта возможность затрагивает то, откуда можно делать вызов небезопасного кода:
небезопасные функции могут вызываться только из небезопасных блоков.</p>
<p>Мощь и полезность этой возможности сложно переоценить. Rust предоставляет
некоторые <a href="intrinsics.html">intrinsic-операции</a> компилятора в виде небезопасных
функций, а некоторые небезопасные функции обходят проверки безопасности для
достижения большей скорости исполнения.</p>
<p>В заключение, повторимся: хотя вы и <em>можете</em> делать в небезопасных участках
почти что угодно, это не значит, что стоит это делать. Компилятор будет
предполагать выполнение оговоренных инвариантов, так что будьте осторожны!</p>
<h1>Нестабильные возможности Rust</h1>
<p>Rust обеспечивает три канала распространения для Rust: nightly, beta и stable.
Нестабильные функции доступны только в nightly Rust. Для более подробной
информации об этом процессе смотрите «<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Стабильность как результат</a>».</p>
<p>Чтобы установить nightly Rust, вы можете использовать <code>rustup.sh</code>:</p>
<pre><code class="language-bash">$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly
</code></pre>
<p>Если вы беспокоитесь о <a href="http://curlpipesh.tumblr.com">потенциальной безопасности</a> использования
данной команды <code>curl | sh</code>, то продолжайте читать далее. Вы также можете
использовать двухступенчатый вариант установки и изучить наш установочный
скрипт:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh --channel=nightly
</code></pre>
<p>Если же вы используете Windows, то, пожалуйста, скачайте один из установочных
пакетов: <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32-битный</a> или <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-битный</a> и запустите его.</p>
<h2>Удаление</h2>
<p>Если вы решили, что Rust вам больше не нужен, то мы будем чуть-чуть огорчены, но
это нормально. Не каждый язык программирования отлично подходит для всех. Просто
запустите скрипт деинсталляции:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>
<p>Некоторые люди, причём не безосновательно, насторожились, когда мы сказали
использовать <code>curl | sh</code>. Когда вы делаете так, вы должны доверять тем хорошим
людям, которые поддерживают Rust, и не бояться, что они попытаются взломать ваш
компьютер и сделать какие-либо плохие вещи. Озабоченность своей безопасностью -
это очень хорошо. Если вы один из таких людей, пожалуйста посмотрите в
документации как <a href="https://github.com/rust-lang/rust#building-from-source">собрать Rust из исходных кодов</a> или скачайте уже
<a href="http://www.rust-lang.org/install.html">скомпилированный Rust</a>. Мы обещаем, что данный способ не будет
использоваться для установки Rust всегда: скрипт был сделан для быстрого
обновления пока Rust находится в стадии alpha.</p>
<p>Мы так же должны упомянуть официально поддерживаемые платформы:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 и более новые, разные дистрибутивы), x86 и x86-64</li>
<li>OSX 10.7 (Lion) и более новые, x86 и x86-64</li>
</ul>
<p>Rust активно тестируется на всех этих платформах, а также на некоторых других,
например на Android. Но мы указали те, на которых Rust точно должен работать,
ибо для этих платформ он тестируется больше всего.</p>
<p>Напоследок, замечание о Windows. Rust считает, что Windows — это первоклассная
платформа для релиза, но если быть честными, то опыт разработки для Windows не
на столько хорош, как для Linux/OS X. Мы работаем над этим! Если что-то не
работает, то это ошибка. Пожалуйста, дайте нам знать, если такое произойдёт.
Каждый коммит тестируется на Windows, впрочем так же, как и на любой другой
платформе.</p>
<p>Если вы уже установили Rust, то откройте терминал и введите это:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Вы должны увидеть версию, хэш коммита, дату коммита и дату сборки:</p>
<pre><code class="language-bash">rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)
</code></pre>
<p>Итак, теперь у вас есть установленный Rust! Поздравляем!</p>
<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в каталоге <code>/usr/local/share/doc/rust</code>.
В Windows — в директории <code>share/doc</code>, относительно того куда вы установили Rust.</p>
<p>Также есть ещё ряд мест, где можно получить помощь. <a href="irc://irc.mozilla.org/#rust">Канал #rust на
irc.mozilla.org</a>, к которому вы можете подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>.
Нажмите на эту ссылку, и вы будете общаться в чате с другими Rustaceans (это
дурашливое прозвище, которым мы себя называем), и мы поможем вам. Другие
полезные ресурсы, посвящённые Rust: <a href="http://users.rust-lang.org/">форум пользователей</a>, <a href="http://www.reddit.com/r/rust">/r/rust
subreddit</a>, <a href="http://stackoverflow.com/questions/tagged/rust">stack overflow</a>. Русскоязычные ресурсы:
<a href="irc://irc.mozilla.org/#rust-ru">канал #rust-ru на irc.mozilla.org</a>, <a href="https://groups.google.com/forum/#!forum/rust-russian">google groups</a>.</p>
<h1>Плагины к компилятору</h1>
<h1>Введение</h1>
<p><code>rustc</code>, компилятор Rust, поддерживает плагины. Плагины — это разработанные
пользователями библиотеки, которые добавляют новые возможности в компилятор: это
могут быть расширения синтаксиса, дополнительные статические проверки (lints), и
другое.</p>
<p>Плагин — это контейнер, собираемый в динамическую библиотеку, и имеющий
отдельную функцию для регистрации расширения в <code>rustc</code>. Другие контейнеры могут
загружать эти расширения с помощью атрибута <code>#![plugin(...)]</code>. Также смотрите
раздел [<code>rustc::plugin</code>](http://doc.rust-lang.org/rustc/plugin/index.html) с
подробным описанием механизма определения и загрузки плагина.</p>
<p>Передаваемые в <code>#![plugin(foo(... args ...))]</code> аргументы не обрабатываются самим
<code>rustc</code>. Они передаются плагину с помощью
[метода <code>args</code>](http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args)
структуры <code>Registry</code>.</p>
<p>В подавляющем большинстве случаев плагин должен использоваться <em>только</em> через
конструкцию <code>#![plugin]</code>, а не через <code>extern crate</code>. Компоновка потянула бы
внутренние библиотеки <code>libsyntax</code> и <code>librustc</code> как зависимости для вашего
контейнера. Обычно это нежелательно, и может потребоваться только если вы
собираете ещё один, другой, плагин. Статический анализ <code>plugin_as_library</code>
проверяет выполнение этой рекомендации.</p>
<p>Обычная практика — помещать плагины в отдельный контейнер, не содержащий
определений макросов (<code>macro_rules!</code>) и обычного кода на Rust, предназначенного
для непосредственно конечных пользователей библиотеки.</p>
<h1>Расширения синтаксиса</h1>
<p>Плагины могут по-разному расширять синтаксис Rust. Один из видов расширения
синтаксиса — это процедурные макросы. Они вызываются так же, как и
<a href="macros.html">обычные макросы</a>, но их раскрытие производится произвольным кодом
на Rust, который оперирует
<a href="http://doc.rust-lang.org/syntax/ast/index.html">синтаксическими деревьями</a> во
время компиляции.</p>
<p>Давайте напишем плагин
[<code>roman_numerals.rs</code>](https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs),
который реализует целочисленные литералы с римскими цифрами.</p>
<pre><code class="language-ignore">#![crate_type=&quot;dylib&quot;]
#![feature(plugin_registrar, rustc_private)]

extern crate syntax;
extern crate rustc;

use syntax::codemap::Span;
use syntax::parse::token;
use syntax::ast::{TokenTree, TtToken};
use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
use syntax::ext::build::AstBuilder;  // типаж для expr_usize
use rustc::plugin::Registry;

fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult + 'static&gt; {

    static NUMERALS: &amp;'static [(&amp;'static str, u32)] = &amp;[
        (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
        (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
        (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
        (&quot;I&quot;,    1)];

    let text = match args {
        [TtToken(_, token::Ident(s, _))] =&gt; token::get_ident(s).to_string(),
        _ =&gt; {
            cx.span_err(sp, &quot;аргумент должен быть единственным идентификатором&quot;);
            return DummyResult::any(sp);
        }
    };

    let mut text = &amp;*text;
    let mut total = 0;
    while !text.is_empty() {
        match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
            Some(&amp;(rn, val)) =&gt; {
                total += val;
                text = &amp;text[rn.len()..];
            }
            None =&gt; {
                cx.span_err(sp, &quot;неправильное римское число&quot;);
                return DummyResult::any(sp);
            }
        }
    }

    MacEager::expr(cx.expr_u32(sp, total))
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_macro(&quot;rn&quot;, expand_rn);
}
</code></pre>
<p>Теперь мы можем использовать <code>rn!()</code> как любой другой макрос:</p>
<pre><code class="language-ignore">#![feature(plugin)]
#![plugin(roman_numerals)]

fn main() {
    assert_eq!(rn!(MMXV), 2015);
}
</code></pre>
<p>У этого подхода есть преимущества относительно простой функции <code>fn(&amp;str) -&gt; u32</code>:</p>
<ul>
<li>Преобразование (в общем случае, произвольной сложности) выполняется во время
компиляции;</li>
<li>Проверка правильности записи литерала также производится во время компиляции;</li>
<li>Можно добавить возможность использования литерала в образцах (patterns), что
по сути позволяет создавать литералы для любого типа данных.</li>
</ul>
<p>В дополнение к процедурным макросам, вы можете определять новые атрибуты
[<code>derive</code>](http://doc.rust-lang.org/reference.html#derive) и другие виды
расширений. Смотрите раздел
[<code>Registry::register_syntax_extension</code>](http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)
и документацию
[перечисления <code>SyntaxExtension</code>](http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).
В качестве более продвинутого примера с макросами, можно ознакомиться с
макросами регулярных выражений
[<code>regex_macros</code>](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).</p>
<h2>Советы и хитрости</h2>
<p>Некоторые <a href="macros.html#debugging-macro-code">советы по отладке макросов</a>
применимы и в случае плагинов.</p>
<p>Можно использовать
[<code>syntax::parse</code>](http://doc.rust-lang.org/syntax/parse/index.html), чтобы
преобразовать деревья токенов в высокоуровневые элементы синтаксиса, вроде
выражений:</p>
<pre><code class="language-ignore">fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult+'static&gt; {

    let mut parser = cx.new_parser_from_tts(args);

    let expr: P&lt;Expr&gt; = parser.parse_expr();
</code></pre>
<p>Можно просмотреть код
[парсера <code>libsyntax</code>](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs),
чтобы получить представление о работе инфраструктуры разбора.</p>
<p>Сохраняйте <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>ы</a>
всего, что вы разбираете, чтобы лучше сообщать об ошибках. Вы можете обернуть
ваши структуры данных в
[<code>Spanned</code>](http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html).</p>
<p>Вызов
[<code>ExtCtxt::span_fatal</code>](http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)
сразу прервёт компиляцию. Вместо этого, лучше вызвать
[<code>ExtCtxt::span_err</code>](http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err)
и вернуть
[<code>DummyResult</code>](http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html),
чтобы компилятор мог продолжить работу и обнаружить дальнейшие ошибки.</p>
<p>Вы можете использовать
[<code>span_note</code>](http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note)
и
[<code>syntax::print::pprust::*_to_string</code>](http://doc.rust-lang.org/syntax/print/pprust/index.html#functions)
чтобы напечатать синтаксический фрагмент для отладки.</p>
<p>Пример выше создавал целочисленный литерал с помощью
[<code>AstBuilder::expr_usize</code>](http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize).
В качестве альтернативы типажу <code>AstBuilder</code>, <code>libsyntax</code> предоставляет набор
<a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">макросов квазицитирования</a>.
Они не документированы и совсем не отполированы. Однако, эта реализация может
стать неплохой основой для улучшенной библиотеки квазицитирования, которая
работала бы как обычный плагин.</p>
<h1>Плагины статических проверок</h1>
<p>Плагины могут расширять
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">инфраструктуру статических проверок Rust</a>,
предоставляя новые проверки стиля кодирования, безопасности, и т.д. Полный
пример можно найти в
[<code>src/test/auxiliary/lint_plugin_test.rs</code>](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs).
Здесь мы приводим его суть:</p>
<pre><code class="language-ignore">declare_lint!(TEST_LINT, Warn,
              &quot;Предупреждать об элементах, названных 'lintme'&quot;);

struct Pass;

impl LintPass for Pass {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(TEST_LINT)
    }

    fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
        let name = token::get_ident(it.ident);
        if name.get() == &quot;lintme&quot; {
            cx.span_lint(TEST_LINT, it.span, &quot;элемент называется 'lintme'&quot;);
        }
    }
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_lint_pass(box Pass as LintPassObject);
}
</code></pre>
<p>Тогда код вроде</p>
<pre><code class="language-ignore">#![plugin(lint_plugin_test)]

fn lintme() { }
</code></pre>
<p>выдаст предупреждение компилятора:</p>
<pre><code class="language-txt">foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
</code></pre>
<p>Плагин статического анализа состоит из следующих частей:</p>
<ul>
<li>
<p>один или больше вызовов <code>declare_lint!</code>, которые определяют статические
структуры [<code>Lint</code>](http://doc.rust-lang.org/rustc/lint/struct.Lint.html);</p>
</li>
<li>
<p>структура, содержащая состояние, необходимое анализатору (в данном случае, его
нет);</p>
</li>
<li>
<p>реализация типажа
[<code>LintPass</code>](http://doc.rust-lang.org/rustc/lint/trait.LintPass.html),
определяющая, как проверять каждый элемент синтаксиса. Один <code>LintPass</code> может
вызывать <code>span_lint</code> для нескольких различных <code>Lint</code>, но он должен
зарегистрировать их все через метод <code>get_lints</code>.</p>
</li>
</ul>
<p>Проходы статического анализатора — это обходы синтаксического дерева, но они
выполняются на поздних стадиях компиляции, когда уже доступа информация о типах.
Встроенные в <code>rustc</code>
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">анализы</a>
в основном используют ту же инфрастуктуру, что и плагины статического анализа.
Смотрите их исходный код, чтобы понять, как получать информацию о типах.</p>
<p>Статические проверки, определяемые плагинами, управляются обычными
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">атрибутами и флагами компилятора</a>,
т.е. <code>#[allow(test_lint)]</code> или <code>-A test-lint</code>. Эти идентификаторы выводятся из
первого аргумента <code>declare_lint!</code>, с учётом соответствующих преобразований
регистра букв и пунктуации.</p>
<p>Вы можете выполнить команду <code>rustc -W help foo.rs</code>, чтобы увидеть весь список
статических проверок, известных <code>rustc</code>, включая те, что загружаются
из<code>foo.rs</code>.</p>
<h1>Встроенный ассемблерный код</h1>
<p>Если вам нужно работать на самом низком уровне или повысить производительность
программы, то у вас может возникнуть необходимость управлять процессором
напрямую. Rust поддерживает использование встроенного ассемблера и делает это с
помощью с помощью макроса <code>asm!</code>. Синтаксис примерно соответствует синтаксису
GCC и Clang:</p>
<pre><code class="language-ignore">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>
<p>Использование <code>asm</code> является закрытой возможностью (требуется указать
<code>#![feature(asm)]</code> для контейнера, чтобы разрешить ее использование) и, конечно
же, требует <code>unsafe</code> блока.</p>
<blockquote>
<p><strong>Примечание</strong>: здесь примеры приведены для x86/x86-64 ассемблера, но
поддерживаются все платформы.</p>
</blockquote>
<h2>Шаблон инструкции ассемблера</h2>
<p>Шаблон инструкции ассемблера (assembly template) является единственным
обязательным параметром, и он должен быть представлен строкой символов (т.е.
<code>&quot;&quot;</code>)</p>
<pre><code class="language-rust">#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// other platforms
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</code></pre>
<p>(Далее атрибуты <code>feature(asm)</code> и <code>#[cfg]</code> будут опущены.)</p>
<p>Выходные операнды (output operands), входные операнды (input operands),
затираемое (clobbers) и опции (options) не являются обязательными, но вы должны
будете добавить соответствующее количество <code>:</code> если хотите пропустить их:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;{eax}&quot;
   );
# } }
</code></pre>
<p>Пробелы и отступы также не имеют значения:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;{eax}&quot;);
# } }
</code></pre>
<h2>Операнды</h2>
<p>Входные и выходные операнды имеют одинаковый формат:
<code>:&quot;ограничение1&quot;(выражение1), &quot;ограничение2&quot;(выражение2), ...&quot;</code>. Выражения для
выходных операндов должны быть либо изменяемыми, либо неизменяемыми, но еще не
иницилиализированными, L-значениями:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</code></pre>
<p>Однако, если вы захотите использовать реальные операнды (регистры) в этой
позиции, то вам потребуется заключить используемый регистр в фигурные скобки
<code>{}</code>, и вы должны будете указать конкретный размер операнда. Это полезно для
очень низкоуровневого программирования, когда важны регистры, которые вы
используете:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
result
# }
</code></pre>
<h2>Затираемое (Clobbers)</h2>
<p>Некоторые инструкции могут изменять значения регистров, поэтому мы используем
список затираемого. Он указывает компилятору, что тот не должен допускать
какого-либо изменение значений этих регистров, чтобы они оставались корректными.</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
// Put the value 0x200 in eax
asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;{eax}&quot;);
# } }
</code></pre>
<p>Если входные и выходные регистры уже заданы в ограничениях, то их не нужно
перечислять здесь. В противном случае, любые другие регистры, используемые явно
или неявно, должны быть перечислены.</p>
<p>Если ассемблер изменяет регистр кода условия <code>cc</code>, то он должен быть указан в
качестве одного из затираемых. Точно так же, если ассемблер модифицирует память,
то должно быть указано <code>memory</code>.</p>
<h2>Опции</h2>
<p>Последний раздел, <code>options</code>, специфичен для Rust. Формат представляет собой
разделенные запятыми текстовые строки (т.е. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). Он
используется для того, чтобы задать некоторые дополнительные данные для
встроенного ассемблера:</p>
<p>На текущий момент разрешены следующие опции:</p>
<ol>
<li>
<p><em>volatile</em> — эта опция аналогична <code>__asm__ __volatile__ (...)</code> в gcc/clang;</p>
</li>
<li>
<p><em>alignstack</em> — некоторые инструкции ожидают, что стек был выровнен
определенным образом (т.е. SSE), и эта опция указывает компилятору вставить
свой обычный код выравнивания стека;</p>
</li>
<li>
<p><em>intel</em> — эта опция указывает использовать синтаксис Intel вместо
используемого по умолчанию синтаксиса AT&amp;T.</p>
</li>
</ol>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() {
let result: i32;
unsafe {
   asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
}
println!(&quot;eax is currently {}&quot;, result);
# }
</code></pre>
<h2>Больше информации</h2>
<p>Текущая реализация макроса <code>asm!</code> --- это прямое связывание с
<a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">встроенным ассемблером LLVM</a>, поэтому изучите и их
<a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">документацию</a>, чтобы лучше понять список затираемого, ограничения и
др.</p>
<h1>Без stdlib</h1>
<p>По умолчанию, <code>std</code> компонуется с каждым контейнером Rust. В некоторых случаях это
нежелательно, и этого можно избежать с помощью атрибута <code>#![no_std]</code>,
примененного (привязанного) к контейнеру.</p>
<pre><code class="language-ignore">// a minimal library
#![crate_type=&quot;lib&quot;]
#![feature(no_std)]
#![no_std]
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>Очевидно, должно быть нечто большее, чем просто библиотеки: <code>#[no_std]</code> можно
использовать с исполняемыми контейнерами, а управлять точкой входа можно двумя
способами: с помощью атрибута <code>#[start]</code>, или с помощью переопределения
прокладки (shim) для C функции <code>main</code> по умолчанию на вашу собственную.</p>
<p>В функцию, помеченную атрибутом <code>#[start]</code>, передаются параметры командной
строки в том же формате, что и в C:</p>
<pre><code class="language-rust">#![feature(lang_items, start, no_std, libc)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>Чтобы переопределить вставленную компилятором прокладку <code>main</code>, нужно сначала
отключить ее с помощью <code>#![no_main]</code>, а затем создать соответствующий символ с
правильным ABI и правильным именем, что также потребует переопределение
искажения (коверкания) имен компилятором (<code>#[no_mangle]</code>):</p>
<pre><code class="language-ignore">#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // для уверенности в том, что этот символ будет называться `main` на выходе
pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>В настоящее время компилятор делает определенные предположения о символах,
которые доступны для вызова в исполняемом контейнере. Как правило, эти функции
предоставляются стандартной библиотекой, но если она не используется, то вы
должны определить их самостоятельно.</p>
<p>Первая из этих трех функций, <code>stack_exhausted</code>, вызывается тогда, когда
обнаруживается (происходит) переполнение стека. Эта функция имеет ряд
ограничений, касающихся того, как она может быть вызвана и того, что она должна
делать, но если регистр предела стека не поддерживается, то поток всегда имеет
«бесконечный стек» и эта функция не должна быть вызвана (получить управление,
срабатывать).</p>
<p>Вторая из этих трех функций, <code>eh_personality</code>, используется в механизме
обработки ошибок компилятора. Она часто отображается на функцию personality
(специализации) GCC (для получения дополнительной информации смотри <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">реализацию
libstd</a>), но можно с
уверенностью сказать, что для контейнеров, которые не вызывают панику, эта
функция никогда не будет вызвана. Последняя функция, <code>panic_fmt</code>, также
используются в механизме обработки ошибок компилятора.</p>
<h2>Использование основной библиотеки (libcore)</h2>
<blockquote>
<p><strong>Примечание</strong>: структура основной библиотеки (core) является нестабильной, и
поэтому рекомендуется использовать стандартную библиотеку (std) там, где это
возможно.</p>
</blockquote>
<p>С учетом указанных выше методов, у нас есть чисто-металлический исполняемый код
работает Rust. Стандартная библиотека предоставляет немало функциональных
возможностей, однако, для Rust также важна производительность. Если стандартная
библиотека не соответствует этим требованиям, то вместо нее может быть
использована <a href="http://doc.rust-lang.org/core/index.html">libcore</a>.</p>
<p>Основная библиотека имеет очень мало зависимостей и гораздо более компактна, чем
стандартная библиотека. Кроме того, основная библиотека имеет большую часть
необходимой функциональности для написания идиоматического и эффективного кода
на Rust.</p>
<p>В качестве примера приведем программу, которая вычисляет скалярное произведение
двух векторов, предоставленных из кода C, и использует идиоматические практики
Rust.</p>
<pre><code class="language-ignore">#![feature(lang_items, start, no_std, core, libc)]
#![no_std]

# extern crate libc;
extern crate core;

use core::prelude::*;

use core::mem;

#[no_mangle]
pub extern fn dot_product(a: *const u32, a_len: u32,
                          b: *const u32, b_len: u32) -&gt; u32 {
    use core::raw::Slice;

    // Convert the provided arrays into Rust slices.
    // The core::raw module guarantees that the Slice
    // structure has the same memory layout as a &amp;[T]
    // slice.
    //
    // This is an unsafe operation because the compiler
    // cannot tell the pointers are valid.
    let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
        mem::transmute((
            Slice { data: a, len: a_len as usize },
            Slice { data: b, len: b_len as usize },
        ))
    };

    // Iterate over the slices, collecting the result
    let mut ret = 0;
    for (i, j) in a_slice.iter().zip(b_slice.iter()) {
        ret += (*i) * (*j);
    }
    return ret;
}

#[lang = &quot;panic_fmt&quot;]
extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                    file: &amp;str,
                    line: u32) -&gt; ! {
    loop {}
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
# #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
# fn main() {}
</code></pre>
<p>Обратите внимание, что здесь, в отличае от примеров, рассмотренных выше, есть
один дополнительный lang элемент <code>panic_fmt</code>. Он должен быть определён
потребителями libcore, потому что основная библиотека объявляет панику, но не
определяет её. lang элемент <code>panic_fmt</code> определяет панику для этого
контейнера, и необходимо гарантировать, что он никогда не возвращает значение.</p>
<p>Как видно в этом примере, основная библиотека предназначена для предоставления
всей мощи Rust при любых обстоятельствах, независимо от требований платформы.
Дополнительные библиотеки, такие как liballoc, добавляют функциональность для
libcore, для работы которой нужно сделать некоторые платформо-зависимые
предположения; но эти библиотеки всё равно более переносимы, чем стандартная
библиотека в целом.</p>
<h1>Внутренние средства (intrinsics)</h1>
<blockquote>
<p><strong>Примечание</strong>: внутренние средства всегда будут иметь нестабильный интерфейс,
рекомендуется использовать стабильные интерфейсы libcore, а не внутренние
напрямую.</p>
</blockquote>
<p>Они импортируются как если бы они были FFI функциями, со специальным <code>rust- intrinsic</code> ABI. Например, если, находясь в отдельном (автономном) контексте,
хочется иметь возможность <code>transmute</code> между типами, а также использовать
эффективную арифметику указателей, то можно импортировать эти функции через
объявление, такое как</p>
<pre><code class="language-rust"># #![feature(intrinsics)]
# fn main() {}

extern &quot;rust-intrinsic&quot; {
    fn transmute&lt;T, U&gt;(x: T) -&gt; U;

    fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
}
</code></pre>
<p>Как и с любыми другими FFI функциями, их вызов всегда небезопасен и помечен как
<code>unsafe</code>.</p>
<h1>Элементы языка (lang items)</h1>
<blockquote>
<p><strong>Замечание</strong>: многие элементы языка предоставляются контейнерами в
стандартной поставке Rust, а у самих элементов языка нестабильный
интерфейс. Рекомендуется использовать официально распространяемые контейнеры,
вместо того, чтобы определять свои собственные элементы языка.</p>
</blockquote>
<p>У компилятора <code>rustc</code> есть некоторые подключаемые операции, т.е. функционал, не
встроенный жёстко в язык, а реализованный в библиотеках и специально помеченный
как элемент языка. Метка — это атрибут <code>#[lang=&quot;...&quot;]</code>. Есть различные значения
<code>...</code>, т.е.  разные «элементы языка».</p>
<p>Например, для указателей <code>Box</code> нужны два элемента языка — для выделения памяти и
для освобождения. Вот программа, не использующая стандартную библиотеку, и
реализующая <code>Box</code> через <code>malloc</code> и <code>free</code>:</p>
<pre><code class="language-rust">#![feature(lang_items, box_syntax, start, no_std, libc)]
#![no_std]

extern crate libc;

extern {
    fn abort() -&gt; !;
}

#[lang = &quot;owned_box&quot;]
pub struct Box&lt;T&gt;(*mut T);

#[lang=&quot;exchange_malloc&quot;]
unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
    let p = libc::malloc(size as libc::size_t) as *mut u8;

    // malloc завершился ошибкой
    if p as usize == 0 {
        abort();
    }

    p
}
#[lang=&quot;exchange_free&quot;]
unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
    libc::free(ptr as *mut libc::c_void)
}

#[start]
fn main(argc: isize, argv: *const *const u8) -&gt; isize {
    let x = box 1;

    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
</code></pre>
<p>Заметьте, что <code>exchange_malloc</code> должен возвращать допустимый указатель, поэтому
он производит проверку внутри и делает <code>abort</code>, если она не прошла.</p>
<p>Ниже перечислены другие возможности, предоставляемые элементами языка:</p>
<ul>
<li>перегружаемые операторы через типажи: типажи, соответствующие <code>==</code>, <code>&lt;</code>,
разыменованию (<code>*</code>), <code>+</code> и другим операторам, помечены как элементы языка;
конкретно эти типажи помечены как <code>eq</code>, <code>ord</code>, <code>deref</code> и <code>add</code>;</li>
<li>раскрутка стека и общая ошибка; это элементы <code>eh_personality</code>, <code>fail</code> и
<code>fail_bounds_check</code>;</li>
<li>типажи в модуле <code>std::marker</code>, используемые чтобы помечать различные типы;
элементы <code>send</code>, <code>sync</code> и <code>copy</code>;</li>
<li>типы-метки и индикаторы вариантности из <code>std::marker</code>; это элементы
<code>covariant_type</code>, <code>contravariant_lifetime</code> и другие.</li>
</ul>
<p>Элементы языка загружаются компилятором лениво, т.е. если программа не
использует <code>Box</code>, вам не нужно определять элементы <code>exchange_malloc</code> и
<code>exchange_free</code>. <code>rustc</code> выдаст ошибку, если элемент языка необходим, но не
найден ни в текущем контейнере, ни в его зависимостях.</p>
<h1>Продвинутое руководстве по компоновке (advanced linking)</h1>
<p>Распространённые ситуации, в которых требовалась компоновка с кодом на Rust, уже
были рассмотрены в предыдущих главах книги. Однако для поддержки прозрачного
взаимодействия с нативными библиотеками требуется более широкая поддержка разных
вариантов компоновки.</p>
<h1>Аргументы компоновки (link args)</h1>
<p>Есть только один способ тонкой настройки компоновки — атрибут <code>link_args</code>.
Этот атрибут применяется к блокам <code>extern</code>, и указывает сырые аргументы, которые
должны быть переданы компоновщику при создании артефакта. Например:</p>
<pre><code class="language-no_run">#![feature(link_args)]

#[link_args = &quot;-foo -bar -baz&quot;]
extern {}
# fn main() {}
</code></pre>
<p>Обратите внимание, что эта возможность скрыта за <code>feature(link_args)</code>, так как
это нештатный способ компоновки. В данный момент <code>rustc</code> вызывает системный
компоновщик (на большинстве систем это <code>gcc</code>, на Windows — <code>link.exe</code>),
поэтому передача аргументов командной строки имеет смысл. Но реализация не
всегда будет такой — в будущем <code>rustc</code> может напрямую использовать LLVM для
связывания с нативными библиотеками, и тогда <code>link_args</code> станет бессмысленным.
Того же эффекта можно достигнуть с пощощью передачи <code>rustc</code> аргумента <code>-C link-args</code>.</p>
<p>Крайне рекомендуется <em>не</em> использовать этот атрибут, и пользоваться вместо него
более точно определённым атрибутом <code>#link(...)</code> для блоков <code>extern</code>.</p>
<h1>Статическое связывание</h1>
<p>Статическое связывание — это процесс создания артефакта, который содержит все
нужные библиотеки, и потому не потребует установленных библиотек на целевой
системе. Библиотеки на Rust по умолчанию связываются статически, поэтому
приложения и библиотеки на Rust можно использовать без установки Rust повсюду.
Напротив, нативные библиотеки (например, <code>libc</code> и <code>libm</code>) обычно связываются
динамически, но это можно изменить, и сделать чтобы они также связывались
статически.</p>
<p>Компоновка — это процесс, который реализуется по-разному на разных платформах.
На некоторых из них статическое связывание вообще не возможно! Этот раздел
предполагает знакомство с процессом компоновки на вашей платформе.</p>
<h2>Linux</h2>
<p>По умолчанию, программы на Rust для Linux компонуются с системной <code>libc</code> и ещё
некоторыми библиотеками. Давайте посмотрим на пример на 64-битной машине с
Linux, GCC и <code>glibc</code> (самой популярной <code>libc</code> на Linux):</p>
<pre><code class="language-text">$ cat example.rs
fn main() {}
$ rustc example.rs
$ ldd example
        linux-vdso.so.1 =&gt;  (0x00007ffd565fd000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)
</code></pre>
<p>Иногда динамическое связывание на Linux нежелательно: например, если вы хотите
использовать возможности из новых библиотек на старых системах или на целевых
системах нет таких библиотек.</p>
<p>Статическое связывание возможно с альтернативной <code>libc</code>, <code>musl</code>. Вы можете
скомпилировать свою версию Rust, которая будет использовать <code>musl</code>, и установить
её в отдельную директорию, с помощью инструкции, приведённой ниже:</p>
<pre><code class="language-text">$ mkdir musldist
$ PREFIX=$(pwd)/musldist
$
$ # Build musl
$ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
[...]
$ tar xf musl-1.1.10.tar.gz
$ cd musl-1.1.10/
musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
[...]
musl-1.1.10 $ make
[...]
musl-1.1.10 $ make install
[...]
musl-1.1.10 $ cd ..
$ du -h musldist/lib/libc.a
2.2M    musldist/lib/libc.a
$
$ # Build libunwind.a
$ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz
$ tar xf llvm-3.6.1.src.tar.xz
$ cd llvm-3.6.1.src/projects/
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ libcxxabi
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ libunwind
llvm-3.6.1.src/projects $ sed -i 's#^\(include_directories\).*$#\0\n\1(../libcxxabi/include)#' libunwind/CMakeLists.txt
llvm-3.6.1.src/projects $ mkdir libunwind/build
llvm-3.6.1.src/projects $ cd libunwind/build
llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABLE_SHARED=0 ..
llvm-3.6.1.src/projects/libunwind/build $ make
llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../
$ du -h musldist/lib/libunwind.a
164K    musldist/lib/libunwind.a
$
$ # Build musl-enabled rust
$ git clone https://github.com/rust-lang/rust.git muslrust
$ cd muslrust
muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix=$PREFIX
muslrust $ make
muslrust $ make install
muslrust $ cd ..
$ du -h musldist/bin/rustc
12K     musldist/bin/rustc
</code></pre>
<p>Теперь у вас есть сборка Rust с <code>musl</code>! Поскольку мы установили её в отдельную
корневую директорию, надо удостовериться в том, что система может найти
исполняемые файлы и библиотеки:</p>
<pre><code class="language-text">$ export PATH=$PREFIX/bin:$PATH
$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH
</code></pre>
<p>Давайте попробуем!</p>
<pre><code class="language-text">$ echo 'fn main() { println!(&quot;hi!&quot;); panic!(&quot;failed&quot;); }' &gt; example.rs
$ rustc --target=x86_64-unknown-linux-musl example.rs
$ ldd example
        not a dynamic executable
$ ./example
hi!
thread '&lt;main&gt;' panicked at 'failed', example.rs:1
</code></pre>
<p>Успех! Эта программа может быть скопирована на почти любую машину с Linux с той
же архитектурой процессора и будет работать без проблем.</p>
<p><code>cargo build</code> также принимает опцию <code>--target</code>, так что вы можете собирать
контейнеры как обычно. Однако, возможно вам придётся пересобрать нативные
библиотеки с <code>musl</code>, чтобы иметь возможность скомпоноваться с ними.</p>
<h1>Тесты производительности</h1>
<p>Rust поддерживает тесты производительности, которые помогают измерить
производительность вашего кода. Давайте изменим наш <code>src/lib.rs</code>, чтобы он
выглядел следующим образом (комментарии опущены):</p>
<pre><code class="language-rust,ignore">#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на включение возможности (feature gate) <code>test</code>, что включает
эту нестабильную возможность.</p>
<p>Мы импортировали контейнер <code>test</code>, который включает поддержку измерения
производительности. У нас есть новая функция, аннотированная с помощью атрибута
<code>bench</code>. В отличие от обычных тестов, которые не принимают никаких аргументов,
тесты производительности в качестве аргумента принимают <code>&amp;mut Bencher</code>.
<code>Bencher</code> предоставляет метод <code>iter</code>, который в качестве аргумента принимает
замыкание. Это замыкание содержит код, производительность которого мы хотели бы
протестировать.</p>
<p>Запуск тестов производительности осуществляется командой <code>cargo bench</code>:</p>
<pre><code class="language-bash">$ cargo bench
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/release/adder-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>Все тесты, не относящиеся к тестам производительности, были проигнорированы. Вы,
наверное, заметили, что выполнение <code>cargo bench</code> занимает немного больше времени
чем <code>cargo test</code>. Это происходит потому, что Rust запускает наш тест несколько
раз, а затем выдает среднее значение. Так как мы выполняем слишком мало полезной
работы в этом примере, у нас получается <code>1 ns/iter (+/- 0)</code>, но была бы выведена
дисперсия, если бы был один.</p>
<p>Советы по написанию тестов производительности:</p>
<ul>
<li>Внутри <code>iter</code> цикла пишите только тот код, производительность которого вы
хотите измерить; инициализацию выполняйте за пределами <code>iter</code> цикла</li>
<li>Внутри <code>iter</code> цикла пишите код, который будет идемпотентным (будет делать «то
же самое» на каждой итерации); не накапливайте и не изменяйте состояние</li>
<li>Вне <code>iter</code> цикла пишите код который также будет идемпотентным; скорее всего,
он будет запущен много раз во время теста</li>
<li>Внутри <code>iter</code> цикла пишите код, который будет коротким и быстрым, так чтобы
запуски тестов происходили быстро и калибратор мог настроить длину пробега с
точным разрешением</li>
<li>Внутри <code>iter</code> цикла пишите код, делающий что-то простое, чтобы помочь в
выявлении улучшения (или уменьшения) производительности</li>
</ul>
<h2>Особенности оптимизации</h2>
<p>А вот другой сложный момент, относящийся к написанию тестов производительности:
тесты, скомпилированные с оптимизацией, могут быть значительно изменены
оптимизатором, после чего тест будет мерить производительность не так, как мы
этого ожидаем. Например, компилятор может определить, что некоторые выражения не
оказывают каких-либо внешних эффектов и просто удалит их полностью.</p>
<pre><code class="language-rust,ignore">#![feature(test)]

extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
</code></pre>
<p>выведет следующие результаты</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>Движок для запуска тестов производительности оставляет две возможности,
позволяющие этого избежать. Либо использовать замыкание, передаваемое в метод
<code>iter</code>, которое возвращает какое-либо значение; тогда это заставит оптимизатор
думать, что возвращаемое значение будет использовано, из-за чего удалить
вычисления полностью будет не возможно. Для примера выше этого можно достигнуть,
изменив вызова <code>b.iter</code></p>
<pre><code class="language-rust"># struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    // note lack of `;` (could also use an explicit `return`).
    (0..1000).fold(0, |old, new| old ^ new)
});
</code></pre>
<p>Либо использовать вызов функции <code>test::black_box</code>, которая представляет собой
«черный ящик», непрозрачный для оптимизатора, тем самым заставляя его
рассматривать любой аргумент как используемый.</p>
<pre><code class="language-rust">#![feature(test)]

extern crate test;

# fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
# }
</code></pre>
<p>В этом примере не происходит ни чтения, ни изменения значения, что очень дешево
для малых значений. Большие значения могут быть переданы косвенно для уменьшения
издержек (например, <code>black_box(&amp;huge_struct)</code>).</p>
<p>Выполнение одного из вышеперечисленных изменений дает следующие результаты
измерения производительности</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>Тем не менее, оптимизатор все еще может вносить нежелательные изменения в
определенных случаях, даже при использовании любого из вышеописанных приемов.</p>
<h1>Синтаксис упаковки и шаблоны <code>match</code></h1>
<p>В настоящее время единственный стабильный способ создания <code>Box</code> — это создание с
помощью метода <code>Box::new</code>. В стабильной сборке Rust также невозможно
деструктурировать <code>Box</code> при использовании сопоставления с шаблоном. В
нестабильной сборке может быть использовано ключевое слово <code>box</code>, как для
создания, так и для деструктуризации <code>Box</code>. Ниже представлен пример
использования:</p>
<pre><code class="language-rust">#![feature(box_syntax, box_patterns)]

fn main() {
    let b = Some(box 5);
    match b {
        Some(box n) if n &lt; 0 =&gt; {
            println!(&quot;Box contains negative number {}&quot;, n);
        },
        Some(box n) if n &gt;= 0 =&gt; {
            println!(&quot;Box contains non-negative number {}&quot;, n);
        },
        None =&gt; {
            println!(&quot;No box&quot;);
        },
        _ =&gt; unreachable!()
    }
}
</code></pre>
<p>Обратите внимание, что эти возможности в настоящее время являются скрытыми:
<code>box_syntax</code> (создание упаковки) и <code>box_patterns</code> (деструктурирование и
сопоставление с образцом), потому что синтаксис все еще может измениться в
будущем.</p>
<h1>Возврат указателей</h1>
<p>Во многих языках с указателями, вы можете вернуть указатель из функции, чтобы
таким образом избежать копирования большой структуры данных. Например:</p>
<pre><code class="language-rust">struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; Box&lt;BigStruct&gt; {
    Box::new(*x)
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y = foo(x);
}
</code></pre>
<p>Идея состоит в том, что, при передаче упаковки, происходит копирование только
указателя, а не всех <code>int</code>, из которых состоит <code>BigStruct</code>.</p>
<p>Это антипаттерн в Rust. Вместо этого следует написать так:</p>
<pre><code class="language-rust">#![feature(box_syntax)]

struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; BigStruct {
    *x
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y: Box&lt;BigStruct&gt; = box foo(x);
}
</code></pre>
<p>Это дает вам гибкость без ущерба для производительности.</p>
<p>Вы можете подумать, что такое использование даст нам ужасную производительность:
возвращается значение, а затем оно сразу упаковывается?! Разве это не паттерн
худшего из двух миров? Rust намного умнее. В этом коде не происходит
копирование. <code>main</code> выделяет достаточно места для <code>box</code>, передает указатель на
эту память в <code>foo</code> в виде <code>x</code>, а затем <code>foo</code> записывает значение прямо в
<code>Box&lt;T&gt;</code>.</p>
<p>Это достаточно важно, поэтому стоит повторить: указатели не для оптимизации
возвращаемых значений в коде. Позвольте вызывающей стороне самой выбрать, как
она хочет использовать выход.</p>
<h1>Шаблоны <code>match</code> для срезов</h1>
<p>Если вы хотите в качестве шаблона для сопоставления использовать срез или
массив, то вы можете использовать <code>&amp;</code> и активировать возможность
<code>slice_patterns</code>:</p>
<pre><code class="language-rust">#![feature(slice_patterns)]

fn main() {
    let v = vec![&quot;match_this&quot;, &quot;1&quot;];

    match &amp;v[..] {
        [&quot;match_this&quot;, second] =&gt; println!(&quot;The second element is {}&quot;, second),
        _ =&gt; {},
    }
}
</code></pre>
<p>Отключаемая возможность <code>advanced_slice_patterns</code> позволяет использовать <code>..</code>,
чтобы обозначить любое число элементов в шаблоне. Этот символ подстановки можно
использовать в массиве один раз. Если перед <code>..</code> есть идентификатор, результат
среза будет связан с этим именем. Например:</p>
<pre><code class="language-rust">#![feature(advanced_slice_patterns, slice_patterns)]

fn is_symmetric(list: &amp;[u32]) -&gt; bool {
    match list {
        [] | [_] =&gt; true,
        [x, inside.., y] if x == y =&gt; is_symmetric(inside),
        _ =&gt; false
    }
}

fn main() {
    let sym = &amp;[0, 1, 4, 2, 4, 1, 0];
    assert!(is_symmetric(sym));

    let not_sym = &amp;[0, 1, 7, 2, 4, 1, 0];
    assert!(!is_symmetric(not_sym));
}
</code></pre>
<h1>Ассоциированные константы</h1>
<p>С включенной возможностью <code>associated_consts</code> вы можете определить константы
вроде этой:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, i32::ID);
}
</code></pre>
<p>Любая реализация <code>Foo</code> должна будет определить <code>ID</code>. Без этого определения:</p>
<pre><code class="language-rust,ignore">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
}
</code></pre>
<p>выдаст ошибку</p>
<pre><code class="language-text">error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
</code></pre>
<p>Также может быть реализовано значение по умолчанию:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32 = 1;
}

impl Foo for i32 {
}

impl Foo for i64 {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, i32::ID);
    assert_eq!(5, i64::ID);
}
</code></pre>
<p>Как вы можете видеть, при реализации <code>Foo</code>, можно оставить константу
неопределенной, как в случае для <code>i32</code>. Тогда будет использовано значение по
умолчанию. Но также можно и добавить собственное определение, как в случае для
<code>i64</code>.</p>
<p>Ассоциированные константы могут быть ассоциированы не только с типажом. Это
также прекрасно работает и с блоком <code>impl</code> для <code>struct</code>:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

struct Foo;

impl Foo {
    pub const FOO: u32 = 3;
}
</code></pre>
<h1>Пользовательские менеджеры памяти</h1>
<p>Выделение памяти — это не самая простая задача, и Rust обычно заботится об этом
сам, но часто нужно тонко управлять выделением памяти. Компилятор и стандартная
библиотека в настоящее время позволяют глобально переключить используемый
менеджер во время компиляции. Описание сейчас находится в <a href="https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md">RFC 1183</a>, но
здесь мы рассмотрим как сделать ваш собственный менеджер.</p>
<h1>Стандартный менеджер памяти</h1>
<p>В настоящее время компилятор содержит два стандартных менеджера: <code>alloc_system</code>
и <code>alloc_jemalloc</code> (однако у некоторых платформ отсутствует jemalloc).
Эти менеджеры стандартны для контейнеров Rust и содержат реализацию подпрограмм
для выделения и освобождения памяти. Стандартная библиотека не компилируется
специально для использования только одного из них. Компилятор будет решать какой
менеджер использовать во время компиляции в зависимости от типа производимых
выходных артефактов.</p>
<p>По умолчанию исполняемые файлы сгенерированные компилятором будут использовать
<code>alloc_jemalloc</code> (там где возможно). В таком случае компилятор &quot;контролирует
весь мир&quot;, в том смысле что у него есть власть над окончательной компоновкой.</p>
<p>Однако динамические и статические библиотеки по умолчанию будут использовать
<code>alloc_system</code>. Здесь Rust обычно в роли гостя в другом приложении или вообще в
другом мире, где он не может авторитетно решать какой менеджер использовать.
В результате он возвращается назад к стандартным API (таких как <code>malloc</code> и
<code>free</code>), для получения и освобождения памяти.</p>
<h1>Переключение менеджеров памяти</h1>
<p>Несмотря на то что в большинстве случаев нам подойдёт то, что компилятор выбирает
по умолчанию, часто бывает необходимо настроить определенные аспекты. Для того,
чтобы переопределить решение компилятора о том, какой именно менеджер
использовать, достаточно просто скомпоновать с желаемым менеджером:</p>
<pre><code class="language-rust,no_run">#![feature(alloc_system)]

extern crate alloc_system;

fn main() {
    let a = Box::new(4); // выделение памяти с помощью системного менеджера
    println!(&quot;{}&quot;, a);
}
</code></pre>
<p>В этом примере сгенерированный исполняемый файл будет скомпонован с системным
менеджером, вместо менеджера по умолчанию — jemalloc. И наоборот, чтобы
сгенерировать динамическую библиотеку, которая использует jemalloc по умолчанию
нужно написать:</p>
<pre><code class="language-rust,ignore">#![feature(alloc_jemalloc)]
#![crate_type = &quot;dylib&quot;]

extern crate alloc_jemalloc;

pub fn foo() {
    let a = Box::new(4); // выделение памяти с помощью jemalloc
    println!(&quot;{}&quot;, a);
}
# fn main() {}
</code></pre>
<h1>Написание своего менеджера памяти</h1>
<p>Иногда даже выбора между jemalloc и системным менеджером недостаточно и
необходим совершенно новый менеджер памяти. В этом случае мы напишем наш
собственный контейнер, который будет предоставлять API менеджера памяти (также
как и <code>alloc_system</code> или <code>alloc_jemalloc</code>). Для примера давайте рассмотрим
упрощенную и аннотированную версию <code>alloc_system</code>:</p>
<pre><code class="language-rust,no_run"># // only needed for rustdoc --test down below
# #![feature(lang_items)]
// Компилятору нужно указать, что этот контейнер является менеджером памяти, для
// того что бы при компоновке он не использовал другой менеджер.
#![feature(allocator)]
#![allocator]

// Менеджерам памяти не позволяют зависеть от стандартной библиотеки, которая в
// свою очередь зависит от менеджера, чтобы избежать циклической зависимости.
// Однако этот контейнер может использовать все из libcore.
#![feature(no_std)]
#![no_std]

// Давайте дадим какое-нибудь уникальное имя нашему менеджеру.
#![crate_name = &quot;my_allocator&quot;]
#![crate_type = &quot;rlib&quot;]

// Наш системный менеджер будет использовать поставляемый вместе с компилятором
// контейнер libc для связи с FFI. Имейте ввиду, что на данный момент внешний
// (crates.io) libc не может быть использован, поскольку он компонуется со
// стандартной библиотекой (`#![no_std]` все еще нестабилен).
#![feature(libc)]
extern crate libc;

// Ниже перечислены пять функций, необходимые пользовательскому менеджеру памяти.
// Их сигнатуры и имена на данный момент не проверяются компилятором, но это
// вскоре будет реализовано, так что они должны соответствовать тому, что
// находится ниже.
//
// Имейте ввиду, что стандартные `malloc` и `realloc` не предоставляют опций для
// выравнивания, так что эта реализация должна быть улучшена и поддерживать
// выравнивание.
#[no_mangle]
pub extern fn __rust_allocate(size: usize, _align: usize) -&gt; *mut u8 {
    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }
}

#[no_mangle]
pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {
    unsafe { libc::free(ptr as *mut libc::c_void) }
}

#[no_mangle]
pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,
                                _align: usize) -&gt; *mut u8 {
    unsafe {
        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8
    }
}

#[no_mangle]
pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,
                                        _size: usize, _align: usize) -&gt; usize {
    old_size // libc не поддерживает этот API
}

#[no_mangle]
pub extern fn __rust_usable_size(size: usize, _align: usize) -&gt; usize {
    size
}

# // just needed to get rustdoc to test this
# fn main() {}
# #[lang = &quot;panic_fmt&quot;] fn panic_fmt() {}
# #[lang = &quot;eh_personality&quot;] fn eh_personality() {}
# #[lang = &quot;eh_unwind_resume&quot;] extern fn eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre>
<p>После того как мы скомпилировали этот контейнер, мы можем использовать его
следующим образом:</p>
<pre><code class="language-rust,ignore">extern crate my_allocator;

fn main() {
    let a = Box::new(8); // выделение памяти с помощью нашего контейнера
    println!(&quot;{}&quot;, a);
}
</code></pre>
<h1>Ограничения пользовательских менеджеров памяти</h1>
<p>Несколько ограничений при работе с пользовательским менеджером памяти, которые
могут быть причиной ошибок компиляции:</p>
<ul>
<li>
<p>Любой артефакт может быть скомпонован только с одним менеджером. Исполняемые
файлы, динамические библиотеки и статические библиотеки должны быть
скомпонованы с одним менеджером, и если не один не был указан, то компилятор
сам выберет один. В то же время Rust библиотеки (rlibs) не нуждаются в
компоновке с  менеджером (но это возможно).</p>
</li>
<li>
<p>Потребитель какого-либо менеджера памяти имеет пометку <code>#![needs_allocator]</code>
(в данном случае контейнер <code>liballoc</code>) и какой-либо контейнер <code>#[allocator]</code>
не может транзитивно зависеть от контейнера, которому нужен менеджер (т.е.
циклическая зависимость не допускается). Это означает, что менеджеры памяти в
данный момент должны ограничить себя только libcore.</p>
</li>
</ul>
<h1>Глоссарий</h1>
<p>Не каждый пользователь Rust имеет опыт работы с системами программирования, или
необходимые знания в области компьютерной науки, поэтому мы добавили разъяснения
терминов, которые могут быть незнакомы.</p>
<p><a name="abstract-syntax-tree"></a></p>
<h3>Абстрактное синтаксическое дерево</h3>
<p>Когда компилятор компилирует программу, он делает целый ряд различных вещей.
Одна из вещей, которые он делает, это преобразует текст вашей программы в
'Абстрактное синтаксическое дерево,' или 'AST.' Это дерево является
представлением структуры вашей программы. Например, <code>2 + 3</code> может быть
преобразовано в дерево:</p>
<pre><code class="language-text">  +
 / \
2   3
</code></pre>
<p>А <code>2 + (3 * 4)</code> будет выглядеть следующим образом:</p>
<pre><code class="language-text">  +
 / \
2   *
   / \
  3   4
</code></pre>
<p><a name="arity"></a></p>
<h3>Арность</h3>
<p>Арность означает число аргументов, которые принимает функция или операция.</p>
<pre><code class="language-rust">let x = (2, 3);
let y = (4, 6);
let z = (8, 2, 6);
</code></pre>
<p>В приведенном выше примере <code>x</code> и <code>y</code> имеют арность 2. <code>z</code> имеет арность 3.</p>
<p><a name="expression"></a></p>
<h3>Выражение</h3>
<p>В программировании, выражение — это комбинация значений, постоянных,
переменных и функций, которая вычисляется в одно значение. Например, <code>2 + (3 *</code> — выражение, вычисляющееся в значение <code>14</code>. Стоит заметить, что у
выражений могут быть побочные эффекты. Например, функция, участвующая в
выражении, может делать что-то ещё помимо непосредственно возврата значения.</p>
<h3>Язык, ориентированный на выражения</h3>
<p>В ранних языках программирования <a href="glossary.html#expression">выражения</a> и
<a href="glossary.html#statement">операторы</a> были двумя отдельными видами синтаксиса: выражения
вычислялись в выражение, а операторы производили действия с побочными эффектами.
Однако поздние языки уже не имели такого чёткого разделения по этому критерию. В
языке, ориентированном на выражения, почти любой оператор — это выражение, а
значит, оно возвращает значение. Следовательно, эти выражения могут сами
являться частью ещё больших выражений.</p>
<p><a name="statement"></a></p>
<h3>Оператор</h3>
<p>В программировании, оператор — это наименьший отдельный элемент языка, который
обозначает выполнение компьютером законченного действия. Например, в языке C
<code>printf(&quot;42&quot;);</code> — это оператор.</p>
<h1>Академические исследования</h1>
<p>Неполный перечень работ, которые оказали какое-то влияние на Rust.</p>
<p>Рекомендуется для вдохновения и лучшего понимания предпосылок Rust.</p>
<h3>Система типов</h3>
<ul>
<li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
<li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href="http://www.cs.ucla.edu/%7Epalsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h3>Многозадачность</h3>
<ul>
<li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href="http://www.stanford.edu/%7Eouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href="http://www.mpi-sws.org/%7Eturon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
</ul>
<h3>Другое</h3>
<ul>
<li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h3>Статьи <em>о</em> Rust</h3>
<ul>
<li><a href="http://www.cs.indiana.edu/%7Eeholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a
Systems Level
Language</a>. Early GPU work by Eric Holk.</li>
<li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old
idea</a>
<ul>
<li>not exactly about rust, but by nmatsakis</li>
</ul>
</li>
<li><a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming
Language</a>. Early
formalization of a subset of the type system, by Eric Reed.</li>
<li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using
Rust</a>. By Lars Bergstrom.</li>
<li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in
Rust</a>. Undergrad
paper by Michael Sproul.</li>
<li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in
Rust</a>. Undergrad paper by Alex
Light.</li>
<li><a href="">Evaluation of performance and productivity metrics of potential
programming languages in the HPC environment</a>. Bachelor's thesis by
Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library
in Rust</a>. By
Geoffroy Couprie, research for VLC.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate
Representation</a>. An
experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil
Codes</a>. Another
paper using Impala.</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
