<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Время жизни</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a href='getting-started.html'><b>3.</b> C чего начать</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>3.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>3.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>3.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a href='learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a href='guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
</ul>
</li>
<li><a href='effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a href='the-stack-and-the-heap.html'><b>5.1.</b> Стек и Куча</a>
</li>
<li><a href='testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a href='conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a href='documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a href='iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a href='concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a href='ffi.html'><b>5.8.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='release-channels.html'><b>5.9.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a href='syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a href='variable-bindings.html'><b>6.1.</b> Связывание переменных</a>
</li>
<li><a href='functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a href='primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a href='comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a href='if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a href='for-loops.html'><b>6.6.</b> Циклы `for`</a>
</li>
<li><a href='while-loops.html'><b>6.7.</b> Циклы `while`</a>
</li>
<li><a href='ownership.html'><b>6.8.</b> Владение</a>
</li>
<li><a href='references-and-borrowing.html'><b>6.9.</b> Ссылки и Заимствование</a>
</li>
<li><a href='lifetimes.html'><b>6.10.</b> Время жизни</a>
</li>
<li><a href='mutability.html'><b>6.11.</b> Изменяемость (Мутабельность)</a>
</li>
<li><a href='enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a href='match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a href='structs.html'><b>6.14.</b> Структуры</a>
</li>
<li><a href='patterns.html'><b>6.15.</b> Шаблоны `match`</a>
</li>
<li><a href='method-syntax.html'><b>6.16.</b> Синтаксис методов</a>
</li>
<li><a href='vectors.html'><b>6.17.</b> Вектора</a>
</li>
<li><a href='strings.html'><b>6.18.</b> Строки</a>
</li>
<li><a href='generics.html'><b>6.19.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>6.20.</b> Трейты</a>
</li>
<li><a href='drop.html'><b>6.21.</b> Трейт `Drop`</a>
</li>
<li><a href='if-let.html'><b>6.22.</b> Конструкция `if let`</a>
</li>
<li><a href='trait-objects.html'><b>6.23.</b> Трейт объекты</a>
</li>
<li><a href='closures.html'><b>6.24.</b> Замыкания</a>
</li>
<li><a href='ufcs.html'><b>6.25.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a href='crates-and-modules.html'><b>6.26.</b> Контейнеры и Модули</a>
</li>
<li><a href='const-and-static.html'><b>6.27.</b> `const` и `static`</a>
</li>
<li><a href='tuple-structs.html'><b>6.28.</b> Кортежные структуры</a>
</li>
<li><a href='attributes.html'><b>6.29.</b> Атрибуты</a>
</li>
<li><a href='type-aliases.html'><b>6.30.</b> Псевдонимы типов</a>
</li>
<li><a href='casting-between-types.html'><b>6.31.</b> Преобразование типов</a>
</li>
<li><a href='associated-types.html'><b>6.32.</b> Ассоциированные типы</a>
</li>
<li><a href='unsized-types.html'><b>6.33.</b> Безразмерные типы</a>
</li>
<li><a href='operators-and-overloading.html'><b>6.34.</b> Operators and Overloading</a>
</li>
<li><a href='deref-coercions.html'><b>6.35.</b> Трейт `Deref`</a>
</li>
<li><a href='macros.html'><b>6.36.</b> Макросы</a>
</li>
<li><a href='raw-pointers.html'><b>6.37.</b> Сырые указатели</a>
</li>
<li><a href='unsafe.html'><b>6.38.</b> `unsafe` код</a>
</li>
</ul>
</li>
<li><a href='nightly-rust.html'><b>7.</b> Нестабильные фичи Rust</a>
<ul class='section'>
<li><a href='compiler-plugins.html'><b>7.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a href='lang-items.html'><b>7.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>7.6.</b> Аргументы линковки</a>
</li>
<li><a href='benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a href='box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a href='slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a href='associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
</ul>
</li>
<li><a href='glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a href='academic-research.html'><b>9.</b> Академические исследования</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Время жизни</h1>
    <p>Эта глава является одной из трех, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную фичу Rust,
о которой разработчики на Rust должны иметь полное представление. Владение - это
то, как Rust достигает своей главной цели - безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>

<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li><a href="references-and-borrowing.html">заимствование</a>, и ассоциированная с ним фича ‘ссылки’</li>
<li>время жизни, ее вы сейчас читаете</li>
</ul>

<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>

<h1 id="Мета" class='section-header'><a
                           href="#Мета">Мета</a></h1>
<p>Прежде чем перейти к деталям, отметитм два важных нюанса о системе владения.</p>

<p>Rust сфокусирован на безопасности и скорости. Это достигается за счет
‘абстракций с нулевой стоимостью‘ (‘zero-cost abstractions‘), что означает, что
в Rust стоимость абстракций должна быть настолько минимальной, насколько это
возможно, без ущерба для работоспособности. Система владения ресурсами - это
яркий пример абстракции с нулевой стоимостью. Весь анализ, о котором мы будем
говорить в этом руководстве, выполняется <em>во время компиляции</em>. Вы не платите
хоть сколько-нибудь времени рантайма за какую-либо из фич.</p>

<p>Тем не менее, эта система все же имеет определенную стоимость: кривая обучения.
Многие новые пользователи Rust испытыват то, что мы называем ‘борьба с проверкой
заимствования‘, когда компилятор Rust отказывается компилировать программу,
которая по мнению автора является абсолютно правильной. Это часто происходит
потому, что мысленное представление программиста о том, как должно работать
владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы,
наверное, также будете испытывать подобные трудности поначалу. Однако существует
и хорошая новость: более опытные разработчики на Rust сообщают, что чем больше
они работают с правилами системы владения, тем меньше они борются с проверкой
заимствования.</p>

<p>Имея это в виду, давайте перейдем к изучению систему владения.</p>

<h1 id="Время-жизни" class='section-header'><a
                           href="#Время-жизни">Время жизни</a></h1>
<p>Одалживание ссылки на ресурс, которым кто-то владеет может быть довольно
сложным. Например, представьте себе следующую последовательность операций:</p>

<ul>
<li>Я получаю ручку на какой-то ресурс.</li>
<li>Я одалживаю вам ссылку на это ресурс.</li>
<li>Я решаю, что ресурс мне больше не требуется, и освобождаю его, в то время как
у вас все еще есть на него ссылка.</li>
<li>Вы решаете использовать этот ресурс.</li>
</ul>

<p>Ой-ой! Ваша ссылка указывает на недопустимый ресурс. Это называется висячий
указатель или ‘использование после освобождения‘, когда ресурсом является
память.</p>

<p>Чтобы исправить это, мы должны убедиться, что четвертый шаг никогда не
произойдет после третьего. Система владения в Rust делает это через концепцию
под названием время жизни, которая описывает область видимости, на протяжении
которой ссылка будет действительна.</p>

<p>Когда у нас есть функция, которая принимает ссылку в качестве аргумента, мы
можем явно или неявно указать время жизни ссылки:</p>
<span class='rusttest'>fn main() {
    // implicit
    fn foo(x: &amp;i32) {
    }
    
    // explicit
    fn bar&lt;&#39;a&gt;(x: &amp;&#39;a i32) {
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='comment'>// implicit</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>) {
}

<span class='comment'>// explicit</span>
<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>) {
}
</pre>

<p>Читается <code>&#39;a</code> как ‘время жизни a‘. Технически, все ссылки имеет некоторое время
жизни, связанное с ними, но компилятор позволяет опускать его в общих случаях.
Прежде чем мы перейдем к этому, давайте разберем пример ниже, с явным указанием
времени жизни:</p>
<span class='rusttest'>fn main() {
    fn bar&lt;&#39;a&gt;(...)
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(...)
</pre>

<p>Эта часть объявляет параметры времени жизни. Она говорит, что <code>bar</code> имеет один
параметр времени жизни, <code>&#39;a</code>. Если бы в качестве параметров функции у нас было
две ссылки, то это выглядело бы так:</p>
<span class='rusttest'>fn main() {
    fn bar&lt;&#39;a, &#39;b&gt;(...)
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(...)
</pre>

<p>Затем в списке параметров функции, мы используем заданные параметры времени
жизни:</p>
<span class='rusttest'>fn main() {
    ...(x: &amp;&#39;a i32)
    
}</span><pre id='rust-example-rendered' class='rust '>
...(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>)
</pre>

<p>Если бы мы хотели <code>&amp;mut</code> ссылку, то сделали бы так:</p>
<span class='rusttest'>fn main() {
    ...(x: &amp;&#39;a mut i32)
    
}</span><pre id='rust-example-rendered' class='rust '>
...(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>i32</span>)
</pre>

<p>Если вы сравните <code>&amp;mut i32</code> с <code>&amp;&#39;a mut i32</code>, то увидите, что они отличаются
только определением времени жизни <code>&#39;a</code>, написанным между <code>&amp;</code> и <code>mut i32</code>. <code>&amp;mut i32</code> читается как ‘изменяемая ссылка на i32‘, а <code>&amp;&#39;a mut i32</code> - как ‘изменяемая
ссылка на i32 со временем жизни &#39;a‘.</p>

<p>Вы также должны будете явно указать время жизни при работе с
[<code>struct</code>][structs]:</p>
<span class='rusttest'>struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>; <span class='comment'>// this is the same as `let _y = 5; let y = &amp;_y;`</span>
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>y</span> };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>f</span>.<span class='ident'>x</span>);
}
</pre>

<p>Как вы можете заметить, <code>struct</code> также могут иметь время жизни. Так же как и
функции</p>
<span class='rusttest'>fn main() {
    struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
</pre>

<p>определяют время жизни и</p>
<span class='rusttest'>fn main() {
    struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
</pre>

<p>используют его. Почему же мы должны определять время жизни здесь? Мы должны
убедиться, что ссылка на <code>Foo</code> не может жить дольше, чем ссылка на <code>i32</code>,
содержащаяся в нем.</p>

<h2 id="Осмысливаем-области-видимости-(thinking-in-scopes)" class='section-header'><a
                           href="#Осмысливаем-области-видимости-(thinking-in-scopes)">Осмысливаем области видимости (Thinking in scopes)</a></h2>
<p>Один из способов понять, что же такое время жизни, это визуализировать область,
в которой ссылка является действительной. Например:</p>
<span class='rusttest'>fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>;     <span class='comment'>// -+ y goes into scope</span>
                    <span class='comment'>//  |</span>
    <span class='comment'>// stuff        //  |</span>
                    <span class='comment'>//  |</span>
}                   <span class='comment'>// -+ y goes out of scope</span>
</pre>

<p>Добавим нашу структуру <code>Foo</code>:</p>
<span class='rusttest'>struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>;           <span class='comment'>// -+ y goes into scope</span>
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>y</span> }; <span class='comment'>// -+ f goes into scope</span>
    <span class='comment'>// stuff              //  |</span>
                          <span class='comment'>//  |</span>
}                         <span class='comment'>// -+ f and y go out of scope</span>
</pre>

<p>Наша <code>f</code> живет в области видимости <code>y</code>, поэтому все работает. Что же произойдет,
если это будет не так? Этот код не будет работать:</p>
<span class='rusttest'>struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x goes out of scope
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>;                    <span class='comment'>// -+ x goes into scope</span>
                              <span class='comment'>//  |</span>
    {                         <span class='comment'>//  |</span>
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>;           <span class='comment'>// ---+ y goes into scope</span>
        <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>y</span> }; <span class='comment'>// ---+ f goes into scope</span>
        <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>f</span>.<span class='ident'>x</span>;             <span class='comment'>//  | | error here</span>
    }                         <span class='comment'>// ---+ f and y go out of scope</span>
                              <span class='comment'>//  |</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);        <span class='comment'>//  |</span>
}                             <span class='comment'>// -+ x goes out of scope</span>
</pre>

<p>Уф! Как вы можете видеть здесь, области видимости <code>f</code> и <code>y</code> меньше, чем область
видимости <code>x</code>. Но когда мы выполняем <code>x = &amp;f.x</code>, мы присваиваем <code>x</code> ссылку на
что-то, что вот-вот выйдет из области видимости.</p>

<p>Присвоение имени времени жизни - это способ задать имя его области видимости.
Задание имени является первым шагом, который дает возможность оперировать этим
именованным понятием.</p>

<h2 id="&#39;static" class='section-header'><a
                           href="#&#39;static">&#39;static</a></h2>
<p>Время жизни с именем ‘static‘ является специальным. Он обозначает, что что-то
имеет время жизни, равное времени жизни всей программы. Большинство Rust
программистов впервые столкиваются с <code>&#39;static</code>, когда имеют дело со строками:</p>
<span class='rusttest'>fn main() {
    let x: &amp;&#39;static str = &quot;Hello, world.&quot;;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;Hello, world.&quot;</span>;
</pre>

<p>Строковые литералы имеют тип <code>&amp;&#39;static str</code>, потому что ссылка должна быть
действительна на протяжении работы всей программы: они располагаются в сегменте
данных конечного двоичного файла. Другой пример - глобальные переменные:</p>
<span class='rusttest'>fn main() {
    static FOO: i32 = 5;
    let x: &amp;&#39;static i32 = &amp;FOO;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>static</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>FOO</span>;
</pre>

<p>В этом примере <code>i32</code> добавляется в сегмент данных двоичного файла, а <code>x</code>
ссылается на него.</p>

<h2 id="Опускание-времени-жизни" class='section-header'><a
                           href="#Опускание-времени-жизни">Опускание времени жизни</a></h2>
<p>В Rust есть мощный локальный вывод типов. Однако, сигнатуры объявлений верхнего
уровня не выводятся, чтобы можно было рассуждать о типах на основании одних лишь
сигнатур. Из соображений удобства, введён ограниченный механизм вывода типов
сигнатур функций, называемый &quot;опускание времени жизни&quot; (“lifetime elision”). Он
выводит типы на основании только элементов сигнатуры - тело функции при этом не
учитывается. При этом его назначение - это вывести лишь параметры времени жизни
аргументов. Для этого он реализует три простых правила. Таким образом, опускание
времени жизни упрощает написание сигнатур, одновременно не скрывая реальные типы
аргументов.</p>

<p>Когда речь идет о неявном времени жизни, мы используем термины <em>входное время
жизни</em> (<em>input lifetime</em>) и <em>выходное время жизни</em> (<em>output lifetime</em>). <em>Входное
время жизни</em> связано с передаваемыми в функцию параметрами, а <em>выходное время
жизни</em> связано с возвращаемым функцией значением. Например, эта функция имеет
входное время жизни:</p>
<span class='rusttest'>fn main() {
    fn foo&lt;&#39;a&gt;(bar: &amp;&#39;a str)
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>bar</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>)
</pre>

<p>А эта имеет выходное время жизни:</p>
<span class='rusttest'>fn main() {
    fn foo&lt;&#39;a&gt;() -&gt; &amp;&#39;a str
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>
</pre>

<p>Эта же имеет как входное, так и выходное время жизни:</p>
<span class='rusttest'>fn main() {
    fn foo&lt;&#39;a&gt;(bar: &amp;&#39;a str) -&gt; &amp;&#39;a str
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>bar</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>
</pre>

<p>Ниже представлены три правила:</p>

<ul>
<li><p>Каждое неявное время жизни в аргументах функции становится индивидуальным
временем жизни.</p></li>
<li><p>Если есть ровно одно входное время жизни, явное или неявное, то это время
жизни назначается всем неявным выходным временам жизни.</p></li>
<li><p>Если есть несколько входных вемен жизни, но один из них это <code>&amp;self</code> или <code>&amp;mut self</code>, то всем неявным выходным временам жизни назначается время жизни <code>self</code>.</p></li>
</ul>

<p>В противном случае, неявное задание выходного времени жизни является ошибкой.</p>

<h3 id="Примеры" class='section-header'><a
                           href="#Примеры">Примеры</a></h3>
<p>Вот некоторые примеры функций, представленные в 2 видах: с явно и неявно
заданным временем жизни:</p>
<span class='rusttest'>fn main() {
    fn print(s: &amp;str); // неявно
    fn print&lt;&#39;a&gt;(s: &amp;&#39;a str); // явно
    
    fn debug(lvl: u32, s: &amp;str); // неявно
    fn debug&lt;&#39;a&gt;(lvl: u32, s: &amp;&#39;a str); // явно
    
    // В предыдущем примере, для `lvl` не требуется указывать время жизни, потому
    // что это не ссылка (`&amp;`). Только элементы, связанные с ссылками (например,
    // такие как `struct`, которая содержит ссылку) требуют указания времени жизни.
    
    fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // неявно
    fn substr&lt;&#39;a&gt;(s: &amp;&#39;a str, until: u32) -&gt; &amp;&#39;a str; // явно
    
    fn get_str() -&gt; &amp;str; // НЕКОРРЕКТНО, нет входных параметров
    
    fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // НЕКОРРЕКТНО, два входных параметра
    fn frob&lt;&#39;a, &#39;b&gt;(s: &amp;&#39;a str, t: &amp;&#39;b str) -&gt; &amp;str; // Expanded: Output lifetime is unclear
    
    fn get_mut(&amp;mut self) -&gt; &amp;mut T; // неявно
    fn get_mut&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; &amp;&#39;a mut T; // явно
    
    fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command // неявно
    fn args&lt;&#39;a, &#39;b, T:ToCStr&gt;(&amp;&#39;a mut self, args: &amp;&#39;b [T]) -&gt; &amp;&#39;a mut Command // явно
    
    fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // неявно
    fn new&lt;&#39;a&gt;(buf: &amp;&#39;a mut [u8]) -&gt; BufWriter&lt;&#39;a&gt; // явно
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>); <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>print</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>); <span class='comment'>// явно</span>

<span class='kw'>fn</span> <span class='ident'>debug</span>(<span class='ident'>lvl</span>: <span class='ident'>u32</span>, <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>); <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>debug</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>lvl</span>: <span class='ident'>u32</span>, <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>); <span class='comment'>// явно</span>

<span class='comment'>// В предыдущем примере, для `lvl` не требуется указывать время жизни, потому</span>
<span class='comment'>// что это не ссылка (`&amp;`). Только элементы, связанные с ссылками (например,</span>
<span class='comment'>// такие как `struct`, которая содержит ссылку) требуют указания времени жизни.</span>

<span class='kw'>fn</span> <span class='ident'>substr</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>until</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>; <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>substr</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>until</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>; <span class='comment'>// явно</span>

<span class='kw'>fn</span> <span class='ident'>get_str</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>; <span class='comment'>// НЕКОРРЕКТНО, нет входных параметров</span>

<span class='kw'>fn</span> <span class='ident'>frob</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>t</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>; <span class='comment'>// НЕКОРРЕКТНО, два входных параметра</span>
<span class='kw'>fn</span> <span class='ident'>frob</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>t</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>; <span class='comment'>// Expanded: Output lifetime is unclear</span>

<span class='kw'>fn</span> <span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>T</span>; <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>get_mut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>; <span class='comment'>// явно</span>

<span class='kw'>fn</span> <span class='ident'>args</span><span class='op'>&lt;</span><span class='ident'>T</span>:<span class='ident'>ToCStr</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>args</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Command</span> <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>args</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span>, <span class='ident'>T</span>:<span class='ident'>ToCStr</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> [<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Command</span> <span class='comment'>// явно</span>

<span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>BufWriter</span>; <span class='comment'>// неявно</span>
<span class='kw'>fn</span> <span class='ident'>new</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> [<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>BufWriter</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='comment'>// явно</span>
</pre>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>